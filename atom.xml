<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>电光石火</title>
  
  <subtitle>阿迪的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://adi0229.github.io/"/>
  <updated>2019-07-21T09:03:09.681Z</updated>
  <id>https://adi0229.github.io/</id>
  
  <author>
    <name>Jerry Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI编剧续写《老友记》-- 基于 GPT2 开源版</title>
    <link href="https://adi0229.github.io/2019/06/27/2019-06-27-gpt2-friends/"/>
    <id>https://adi0229.github.io/2019/06/27/2019-06-27-gpt2-friends/</id>
    <published>2019-06-27T02:45:34.000Z</published>
    <updated>2019-07-21T09:03:09.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019-06"><a href="#2019-06" class="headerlink" title="2019-06"></a>2019-06</h2><h4 id="6-27"><a href="#6-27" class="headerlink" title="6.27"></a>6.27</h4><p>引子：“Like, you guys all have job? ”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-90f85681b021d0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>大萧条时代再度降临？大家都失业了，Ross的在职朋友，也是异类。</li><li>原本斯文的博士Ross，变得古怪–大呼小叫，次日飞往佛蒙特州，参加某个免费的活动？</li><li>Rachel 捧着一束花，以祝贺 Joey。Joey 谦虚回答，这很容易啦，去书店。Rachel 接话，拿起“她”的书就好啦。her book 指的是谁的书呢？</li></ul><h4 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-a6d77cedc8f15064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>盼星星，盼月亮，盼周末？Chandler厌倦了整天面对数字的日常工作？奇怪的是，钱德勒不适应快言快语？其实，在真实剧集中，钱德勒妙语连珠，常开冷笑话。</li><li>Rachel 带了音乐专辑？记得某一集里，大家讨论 Kiss 接吻，Rachel 建议“Word of advice: Bring back the comedian.Or next time you’ll find yourself listening to that album alone” Rachel出现在音乐专辑封面？她跨界玩音乐了？客串嘉宾？MV 女主角？</li><li>奇怪的场景：Rachel观赏鸭子游泳，Joey在帮忙划水？ - - </li></ul><p>（AI 写手，还真的是脑洞大开啊，还写得快。）</p><h4 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-a645767f0e36d0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>续写上集「鸭子游泳」</p><ul><li>鸭子在水桶里戏水。Rachel又和意大利人约会，叫 Pete。</li><li>Joey 出场，带着巨型陶瓷杯，对比之下，Rachel 拿着小啤酒杯，里头是巧克力摩丝。双方互相吐槽，Rachel 笑话 Joey：“你不懂给陶瓷杯加热”，Joey 反击：“你都没做过这事。”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-5a05451c93824e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>续写上集的一句话「瑞秋拿着啤酒杯回来了」-&gt; “Rachel returns carrying a beer mug”</p><ul><li>Phoebe和 Monica 争吵，因为 Phoebe 带朋友的孩子来玩，但是孩子走丢了。于是，她想离开 Central Perk&amp;老伙计们。Monica 反应激烈，在浴室哭泣，“砰砰砰”，摔门而出。</li><li>GPT2写手对电视剧里的「广告插播」这一套路，是了然于胸，他写道“Commercial Break”，接着就是广告回来的 Scene：四个家伙在抢盘子。</li></ul><p>进化中的AI 写手，在「内隐化」-&gt; 「戏剧化冲突」这一故事内核？</p><h2 id="2019-07"><a href="#2019-07" class="headerlink" title="2019-07"></a>2019-07</h2><h4 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-d4c42a224c517b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>四人抢夺盘子之后……</p><ul><li>Chandler幽默嘲讽Rachel：“一个人吃完整个小麦面包，挺难的。”</li><li>Rachel转头对Monica说：“你是职业大厨，应该给咱们大家庭全部供餐。”</li><li>Monica毫不领情：“等等，只有一个顾客。”指的是自己只给老公Chandler一人做菜？</li><li>Ross温情帮腔：“Rachel是我妻子，我给她做菜吧。但是我不擅长做菜，姐姐你得帮我。”</li></ul><p>简短对话，无厘头风延续 -&gt; GPT2写手，了然于胸-&gt; Rachel 是 Ross 妻子。</p><h4 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-36f8e84bdbe682ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这个GPT2-Friends 写手，喜欢转移场景，它续写人类句子，很少对「灵感激活句」扩展，只是一笔带过。比如，Monica 是职业大厨，她空余时间，就爱清理地板。（嗯，AI 写手知道 Monica 的洁癖）而关于Monica 在哪做厨师，擅长什么菜，做菜有何特别之处？没有写出。</li><li>场景依然围绕「饮食」展开，比如，免费开胃菜（free appetizer）、牛排(steak), 出现新人物 -&gt; 慈善女孩（Charity Girl)， 话题围绕的是慈善女孩的梦境 -&gt; 在梦里，她是国王，而中国武士集合列队(assembled china people)，守护着她。</li></ul><h4 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-0de8a2cb0ad4e484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Monica厨娘风范尽显，回家做甜饼，是给 Chandler 准备？第一集开场时，Chandler说过一句：“Cookie？”，他爱吃甜饼。</li><li>奇葩事情，Rachel 从 Monica 手中夺过电话，然后递给 Monica？似乎 GPT2-Friends 写手对「人物概念关系」还不太熟悉。 </li></ul><h4 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-fbb4eda230af9c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>场景：Monica与某个男人调情。他试着抚慰她，与此同时，在电话一端，她跟 Rachel抱怨：“我的脸颊疼疯了。” Rachel打趣道：“你可以把你的不爽，发泄到他身上啊。”最后，那个男人很满意，他说第三次约会很赞。（这让我联想到了某一集里，Monica 跟红酒先生Paul说的，“So there will be a fifth date.”）</li><li>场景：月之舞餐厅。（这个场景定位，学得惟妙惟肖。）Joey 的约会对象 Emily 想让他越说越多。故意闲扯了各种让人紧张得竖起耳朵的话，“要不，我告诉 Phoebe，我怀孕了，我们有小孩了。”“哈哈，别紧张，开玩笑哒。”“你知道吗？有些事我没告诉你，我爸爸曾是色情明星，你们一周能看一次。”Joey 这一回学乖了，盯着背景，有来有回的 -&gt; “得了吧，你说的是我吧。”这段话有启发，张力十足，狗血剧情。</li></ul><h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-45321d6c3ce00ce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>“What’s your problem？”（根据近日著名的泼水事件得到启发的句子。）</p><p>GPT2-Friends 写手，续写了一个少男少女式对话，Joey 和 Alice，关于吉他练习，关于吃醋和分手。</p><ul><li>Joey 勾搭上了另一个叫 Alice 的女孩，她想要 Joey 的华丽吉他，彻夜弹奏它。同时，她吃醋，逼着 Joey跟Emily 分手。Joey 安抚她，说自己正在赶走 Emily。Joey 太坏了，跟正剧里一样，有「一吨前女友」。</li></ul><h4 id="7-6"><a href="#7-6" class="headerlink" title="7.6"></a>7.6</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c19f60e84782adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的剧本，略凌乱，略无聊。</p><ul><li>Monica&amp;Phoebe 是蕾丝&amp;女同性恋？她们看上了 Monica丈夫之妹？<ul><li>“She’s beautiful,she got these big breasts and a crush on you!”<ul><li>女同性恋也看「大胸」？那个小姐姐也喜欢 Monica？？</li></ul></li></ul></li></ul><p>小结：GPT2 -Friends 微调写手学到了各种八卦式对话，依然是老问题，人物的关系和事件，没学到。只是表面模仿人类的词句组合。这当然，只是一个拟合统计模型。</p><h4 id="7-7"><a href="#7-7" class="headerlink" title="7.7"></a>7.7</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-16c58477190de11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>回到「最初的开始」，剧本首句，”There’s nothing to tell, just some guy I work with!”。人们常说 -&gt;「莫忘初心，方得始终」-&gt; ( ´◔ ‸◔’)</p><p>但是，GPT2-Friends 写手并不领情，他没有写什么常规的剧情，“只是我一个同事”之类的陈词滥调。</p><ul><li>它思维跳跃,如此写道 -&gt; Phoebe 刚出狱，她很开朗，但她的老伙计们，中央公园(Central Perk)的朋友们，反而难以承受 -&gt; Ross 闷闷不乐，Chandler 躲起来。</li><li>Phoebe 是开心果，戴上勋章，给 Ross 逗乐-&gt; 看， 我都没事，嗨起来。</li><li>Phoebe找到 Chandler的号码，“铃铃铃！”，嗨，快接电话啊，老伙计 Chandler！</li></ul><h4 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-c7b538eacb6c0445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的引子，来自第一季的纽约大停电，“This is so cool, the entire city is  black out.”(这是我根据松散记忆敲出来的，似乎句子并不合语法。）</p><ul><li>Joey忘拿了通往纽约尼克斯队的密匙？或者是他要上场打篮球？英文词典里，keys 也有着「罚球区」的语义。或者是 Ross 说的，这是类似老牌隧道羞辱游戏，是纽约尼克斯主场的球迷互动游戏?</li><li>剩下的对话，又进入了「闲扯」频道，各种「你要杀我啊」之类的吐槽。Ross 神补刀-&gt;Joey 这家伙，好像都折腾死了一百万个姑娘。</li></ul><h4 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-09b00a237a9c847a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>(问题来了 -&gt; 前端界面，体验不佳–&gt; 排版混乱, 不同人物角色的对白，都密密麻麻，难以区分。少了「留白」。好吧，待办事项+1)</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-a71af66a0a6410ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在命令行界面，GPT2 生成模型的输出，都是另起一行的。</p><p>今天的引子，依然来自第一季的纽约大停电，“This is so cool, you guys, the entire city is  blacked out.”(这次用了过去时，照着剧本复制进来的。语法应该是准确无误的。）</p><ul><li>AI 写手硬伤——不按给定的「主题」来续写剧本。我的 GPT2-Friends写手蛮任性——不按给定的「主题」来续写剧本。今天，我给她的引子句子，其话题是「停电」，她「一意孤行」写了「结婚旅行」的对话场景。上面的其他对话，也是如此。与其说是续写剧本，不如说是接过话题，开始满嘴跑火车。当然了，如果对她的奇异跳跃思维，进行修葺，创造出合乎情理的「远距离联想」，也未可知。</li><li>奇怪&amp;搞笑的对话。似乎六个老伙计之中，有两人结婚了，也不知道是 Ross &amp; Rachel 还是 Monica &amp; Chandler。只是，在结尾处，Chandler 跟Joey开冷笑话，“有机会，咱也结个婚吧。”其他，主要是旅游中的话痨场景，诸如“地铁里怎么换乘啊，地图看起来很乱。”“在纽约旅行？看看如何在纽约蒸发吧。”“快看!那里有个疯子””你记得吗？上班时，我有几个晚上能回家的？”</li></ul><h4 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-ca7c3a7cde4ad5ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天是个艳阳天，从猖狂的恶魔奴才们开始吧。<br>“Satan’s minions at work again!”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-466314c4a6253044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>GPT2-Friends写手，他闻过则喜，接受了昨天的反馈。它续写话题了。</li></ul><p>“恶魔的奴才们开始活动了！”<br>“这就是为什么，Rachel 邀请他们来！他们一点也不好，我可不想跟他们在一块，都是推销商！”——爱嘲讽的 Chandler</p><ul><li>转场 -&gt; 考古生物学家 Ross 的主场 -&gt; 场景「自然历史博物馆」</li></ul><p>“看，窗口外那个姑娘，她拿着化石耶。天啊，她真是与众不同”。Ross一边说，一边模仿蝙蝠的动作。<br>“这个姑娘，我最喜欢的一点——她超级聪明。她说，科学就是她的生命。虽然她有点瘦，但是她超可爱哒。天啊，她是我见过的最棒的姑娘了！”</p><p>这个情景，似乎是从第一季里 Ross 在博物馆里得知他的女同性恋前妻怀孕消息得到启发的。这段场景，我给五星评价，对话自然有趣，符合人物特点。<br>在这个生成模型的文本里，Ross 很幽默，以身作则，带她逛自然历史博物馆，感染了妻子 Rachel ，让她对女科学家产生崇敬之情。</p><h4 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c04b26d58e19083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的开头台词，是第一季里经典的”Welcome to the real world, it sucks, you gonna love it” ——欢迎来到现实，它很渣，但是你会爱上它的！</p><ul><li>机器人写手的自嘲！现实很骨感，但是你会爱它，胜过爱机器人的！“Welcome to the real world, it sucks, you gonna love it <strong>more with a robot</strong>.”</li><li>Rachel 的文艺与愤怒：“你怎么会不欣赏这样的人——它迷上了自己看不见的东西。”</li><li>Ross 卡在床上，动弹不得，难以脱离。也许可以设计一个搞笑的「内事」场景——就想某一集里，Ross 喝醉之后，跟 Rachel 睡到一张床上。</li></ul><h4 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c04b26d58e19083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的开头台词，是第一季里经典的”If you spent it, it will be like shopping!” Pecebo收到了某个银行神秘的钱和足球电话，她感到烦恼，感觉像是偷东西（Stealing）。瑞秋给她打气，激发自信，如果你花掉这些钱，就像去购物一样啦。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-e99108698b1fb083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在Ellen 脱口秀节目里，Rachel的扮演者Jennifer Aniston仍然能顺出这句台词。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-27144409f494fa8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天续写的剧情，显得很「普通」。</p><p>邀请「某个她」来「聚会」，或者叫「开趴」，关键词也是常见的「吸引」、「晚餐」&amp;「礼物」等等。当然了，几个老伙计，邀请年轻朋友来聚餐，享受一个乐呵乐呵的普通日子，你嘟哝几句，他唠叨几句，也是极好的。</p><p>嘟嘟哝哝，也是参差百态&amp;生机勃勃，进而获得幸福本源。</p><h4 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h4><p>笔者今天路过国家博物馆，看到了路边指示牌上的英文「National Museum」，因此，今天的开头台词——“Today, we go to the National Museum”。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-da2445113cc1446a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2-Friends 学乖了，这一次剧情紧扣主题「博物馆」，而且只有 2 个人物，对话线索清晰，易读。</p><ul><li>它又玩黑色幽默了。Rachel 和一个叫「博物馆」的人，准备去参观自然历史国家博物馆。</li><li>这个叫「博物馆」的人，从对话上看，说话显得刻薄「你忘了带上那些装着古生代恐龙的盒子吗？我可要抓住你，把你跟那些恐龙化石一起扁死！」、「我看你在找那些化石，你知道我要做什么吗？把你的头丢到后面」。这时候，我脑海里，这是一个叫「博物馆」的 AI 机器人，开始叛变了，十分绝情冷酷，它痛恨人类，又不得不跟人类合作生活。因此，它有着毒舌属性。</li></ul><h4 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h4><p>今天的开头，来自上周的慈善女孩疯狂之梦。<br>“Charity Girl’s wild dream.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-171b8c02b6140835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>场景「没糖吃的生气女孩」——Rachel 气得在卧室里进进出出，来来回回地摔门，还说：“好吧，就是该我来拿钥匙！”兴许，她摔门时，特别气愤，忘记给自己带钥匙，于是把自己锁在了门里。记得正剧里，有一集特别搞笑的场景，就是 Rachel 和 Monica 争吵。”你说你拿了钥匙的！”“你才说你拿了钥匙的！”也不记得她们是否上手打了起来。</li><li>场景「办公室里的产品评测报告」。正剧里，Rachel 进军时尚业，如今自称律师。Monica 老妈曾经吹嘘过，Monica 是开餐馆。难道这一次，Rachel 做了律师，帮助 Monica 审阅某个餐饮业的产品报告？</li></ul><p>看得出，这个AI 文本生成器，是对语料里的文本结构有着超强的模仿能力。对于「门外的钥匙」&amp;「办公室里的文档」等事物，都模仿得惟妙惟肖。</p><h4 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h4><p>今日，人工智能媒体《机器之心》刊文，介绍了一位大四小哥，基于GPT-2的NLP模型，制作了一个编程插件Tabline，用于编程中的「智能关联推荐」任务。所以，两个文本模型都是系出同门。因此，今天就吹捧一下OpenAI团队开源的这个自然语言处理大杀器吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-aa1de51991a6a5f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>截图：构思创作中的 GPT2</p><p>今天的 GPT2-Friend 微调写手，开了几个冷幽默。<br><img src="https://upload-images.jianshu.io/upload_images/452087-1cda3403759aa5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>“GPT-2 can help developers to write codes better. Maybe a 3D Touch game controls the end. ”——用 3D Touch 游戏作为结束吧。机器学习智能补全代码了？那么码农社畜们，可以下班前玩一把采用了 3D Touch 技术的游戏了？或者。或者，意思是——将来3D Touch 技术将成为主流交互方式，长按按钮，发出命令，让 AI 自己生成一堆代码去吧。</li><li>Monica 的冷笑话——“我发现一件特别的事！” “是什么？”“网上什么也找不到了！”哈哈，信息爆炸时代，在网上找不到一点东西，确实是诡异的小概率事件。Rachel 也不甘示弱——“没事，找不到东西不要紧。看看这玩意！”她拿出了一个 CD-ROM，在互联网的“上古时代”，在宽带网络普及之前，老哥老姐们用 CD 碟片来安装软件和游戏啊。</li></ul><h4 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h4><p> 笔者喜欢 Chandler 的富有文化的冷幽默。今天用他在第一季第六集的台词——对 Joey 饰演话剧的评价。</p><p>“You can spot someone who’s never seen his plays.”<br>“Notice, no fear. No sense of impending doom.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-1082aeaf13e62c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的草稿，写的似乎是一个「追逐巨型气球」&amp;「被室友锁在屋外」的场景。也许是某个以热气球做为标志的反派，要来追杀老友记四个朋友们，他面无表情的直奔屋子，正要撞开们。有些小伙伴在外面，想敲门进去，其他小伙伴恐惧过度，不敢开门。</p><p>嗯，契合了第一句——厄运将至</p><h4 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h4><p>今天，笔者刚刚读了36 氪的一篇商业报道，关于计算机视觉技术驱动的创业公司「格灵深瞳」的低谷。简而言之，创始人过分关注技术，「每一分钟都想写代码」，而他的创业搭档 CEO 也没有「下注」中彩，他们在创业初期，没有找对适合三维CV技术落地的市场——当时零售市场不景气。细节参见：<a href="[https://tech.sina.com.cn/it/2019-07-18/doc-ihytcerm4587044.shtml](https://tech.sina.com.cn/it/2019-07-18/doc-ihytcerm4587044.shtml">格灵深瞳 天才AI公司跌入谷底之后</a>)</p><p>于是，下意识地用微软的翻译应用，将“人工智能技术，需要符合市场需求，而不是一群技术人员在实验室里研究不实用的技术。”转成了英文——“Artificial intelligence technology needs to meet market demand, rather than a group of technicians working on less practical technology in the lab.”</p><p>看看 AI 写手怎么看待 AI 落地（如何模仿人类文本）？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-135dba8d12b6b8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>也许是发现了”Artificial Intelligence” 经常与”Engine”&amp;”Computer”等词汇出现,都是计科领域高频词汇。</li><li>这段剧集草稿里，大家互相都用高音（High pitch voice）在尖叫，在体现冲突的场景里，角色们歇斯底里，显得很戏剧性吗？</li><li>“The Pope’ coming tonight.”&amp;”Scuse me”——《教皇今夜降临》&amp;《借过》，特别文艺范的标题，是AI 拟好的话剧名？</li></ul><h4 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h4><p>(竟然遗漏了一天7.19日，嗯，证明我是血肉真人，不是机器人写手。)</p><p>音乐操纵情绪。嗯，今日的开头，我的金句。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-bdc2c3e142f88938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>于是，我的 GPT-2 是情绪化了吗？今天写了一段完整的约会对话。而且跟真实剧集无缝连接啊。</p><p>Ross 在高中便暗恋 Rachel，一直念念不忘。Joey 在他和同性恋前妻离婚之后，给他做过一个隐喻暗示——「Grab a spoon」，拿起一个勺子——找一个姑娘勾搭起来。</p><p>于是——</p><ul><li>Rachel 和 Ross 在讨论 「Grab a big plate」，嗯 Rachel 是盘子，比勺子的容量要大。两口子的余生，互相指教吧。</li><li>Rachel 邀请 Ross 一起看电影，还各种变相夸赞和表白 Ross。甜蜜的场景。</li></ul><h4 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h4><p>今天，以笔者的桌面，编程大师 Linus Torvalds 的名言：“A computer is like air conditioning, it becomes useless when you open windows.”作为第一句。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-941d57bdc4f2fb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2 对剧情里的设定还是挺了解的，它知道 Rachel 老是忘记带钥匙，Joey 是演电影的。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-354abd1483754331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第一个场景：Rachel 去见 2 个医生，但是因为没带钥匙，所以没有收到某种消息。诡异的是 Haldane 医生在脸颊上夹着一个很大的酒瓶。这是描写医生嗜酒如命？</li><li>第二个场景： Joey 家里来了一个漂亮女郎，看起来很像他在电影里亲吻过的女人。Rachel 通过门前的窥视孔查看 Joey 金屋里的娇女郎——一个穿着长裙的光头美女。Joey 摇头，但是 Rachel 没有摇头。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019-06&quot;&gt;&lt;a href=&quot;#2019-06&quot; class=&quot;headerlink&quot; title=&quot;2019-06&quot;&gt;&lt;/a&gt;2019-06&lt;/h2&gt;&lt;h4 id=&quot;6-27&quot;&gt;&lt;a href=&quot;#6-27&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>2018 世界杯 -&gt; 看数据，猜全场最佳球员？机器学习可解释性 -&gt; 特征重要性</title>
    <link href="https://adi0229.github.io/2019/06/24/2019-06-24-fifa18eda/"/>
    <id>https://adi0229.github.io/2019/06/24/2019-06-24-fifa18eda/</id>
    <published>2019-06-24T09:08:20.114Z</published>
    <updated>2019-06-24T09:16:48.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/452087-ad8d8d0c9e5f04ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2018 男足世界杯（128 场比赛）基本统计信息</p><p>完整数据分析报告：<a href="https://github.com/adi0229/ML-DL/blob/master/fifa2018.ipynb" target="_blank" rel="external">https://github.com/adi0229/ML-DL/blob/master/fifa2018.ipynb</a></p><h3 id="数据特征包含："><a href="#数据特征包含：" class="headerlink" title="数据特征包含："></a>数据特征包含：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Index([&apos;Date&apos;, &apos;Team&apos;, &apos;Opponent&apos;, &apos;Goal Scored&apos;, &apos;Ball Possession %&apos;,</div><div class="line">       &apos;Attempts&apos;, &apos;On-Target&apos;, &apos;Off-Target&apos;, &apos;Blocked&apos;, &apos;Corners&apos;, &apos;Offsides&apos;,</div><div class="line">       &apos;Free Kicks&apos;, &apos;Saves&apos;, &apos;Pass Accuracy %&apos;, &apos;Passes&apos;,</div><div class="line">       &apos;Distance Covered (Kms)&apos;, &apos;Fouls Committed&apos;, &apos;Yellow Card&apos;,</div><div class="line">       &apos;Yellow &amp; Red&apos;, &apos;Red&apos;, &apos;Man of the Match&apos;, &apos;1st Goal&apos;, &apos;Round&apos;, &apos;PSO&apos;,</div><div class="line">       &apos;Goals in PSO&apos;, &apos;Own goals&apos;, &apos;Own goal Time&apos;],</div><div class="line">      dtype=&apos;object&apos;)</div></pre></td></tr></table></figure><h3 id="随机森林分类器（Baseline）及特征重要性"><a href="#随机森林分类器（Baseline）及特征重要性" class="headerlink" title="随机森林分类器（Baseline）及特征重要性"></a>随机森林分类器（Baseline）及特征重要性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import pandas as pd</div><div class="line">from sklearn.model_selection import train_test_split</div><div class="line">from sklearn.ensemble import RandomForestClassifier</div><div class="line"></div><div class="line"></div><div class="line">data = pd.read_csv(path + &apos;FIFA_2018_Statistics.csv&apos;)</div><div class="line"></div><div class="line">y = (data[&apos;Man of the Match&apos;] == &quot;Yes&quot;)  </div><div class="line"></div><div class="line"># 特征工程 -&gt; 选取numerical类数值作为训练特征</div><div class="line"></div><div class="line">feature_names = [i for i in data.columns if data[i].dtype in [np.int64]]</div><div class="line"></div><div class="line">X = data[feature_names]</div><div class="line"></div><div class="line">train_X, val_X, train_y, val_y = train_test_split(X, y, random_state=1)</div><div class="line"></div><div class="line">rf = RandomForestClassifier(random_state=0).fit(train_X, train_y)</div><div class="line"></div><div class="line">from sklearn.metrics import accuracy_score</div><div class="line"></div><div class="line">predictions = rf.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.59375</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import eli5</div><div class="line">from eli5.sklearn import PermutationImportance</div><div class="line"></div><div class="line">perm = PermutationImportance(rf, random_state=1).fit(val_X, val_y)</div><div class="line">eli5.show_weights(perm, feature_names = val_X.columns.tolist())</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/452087-837533ba4cf64c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="随机森林分类器（微调）及特征重要性变化"><a href="#随机森林分类器（微调）及特征重要性变化" class="headerlink" title="随机森林分类器（微调）及特征重要性变化"></a>随机森林分类器（微调）及特征重要性变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rf = RandomForestClassifier(random_state=0,n_estimators=500).fit(train_X, train_y)</div><div class="line"></div><div class="line">predictions = rf.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.71875</div></pre></td></tr></table></figure><p>分析：「随机森林」准确率（60% - 72%）提升之后</p><ul><li><p>扑救、传球准确率、射门命中率的重要性上升</p></li><li><p>角球、全场跑动距离的重要性下降</p><p>符合足球战术常识</p></li></ul><h3 id="Xgboost-分类器（微调）及特征重要性"><a href="#Xgboost-分类器（微调）及特征重要性" class="headerlink" title="Xgboost 分类器（微调）及特征重要性"></a>Xgboost 分类器（微调）及特征重要性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from xgboost import XGBRFClassifier</div><div class="line"></div><div class="line">xgb = XGBRFClassifier(silent=False, </div><div class="line">                      scale_pos_weight=1,</div><div class="line">                      learning_rate=0.01,  </div><div class="line">                      colsample_bytree = 0.4,</div><div class="line">                      subsample = 0.8, </div><div class="line">                      n_estimators=1000, </div><div class="line">                      reg_alpha = 0.3,</div><div class="line">                      max_depth=4, </div><div class="line">                      gamma=10).fit(train_X, train_y)</div><div class="line"></div><div class="line">predictions = xgb.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.71875</div></pre></td></tr></table></figure><p>Xgboost发现进球是唯一重要特征。<br>简单粗暴，也更符合足球常理。进球多，更容易获胜，获胜一方容易出 MVP 球员。其他数据的关系并不大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perm_xgb = PermutationImportance(xgb, random_state=1).fit(val_X, val_y)</div><div class="line">eli5.show_weights(perm_xgb, feature_names = val_X.columns.tolist())</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-e34d1c02dcd6787f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>特征重要性（Permutation Importance）</p><p>Ref: <a href="https://eli5.readthedocs.io/en/latest/blackbox/permutation_importance.html?highlight=PermutationImportance" target="_blank" rel="external">https://eli5.readthedocs.io/en/latest/blackbox/permutation_importance.html?highlight=PermutationImportance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/452087-ad8d8d0c9e5f04ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
      <category term="技术, 机器学习" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>百事可乐 Or 可口可乐？深度学习图片分类器部署</title>
    <link href="https://adi0229.github.io/2019/06/18/2019-06-24-cola-image-clf/"/>
    <id>https://adi0229.github.io/2019/06/18/2019-06-24-cola-image-clf/</id>
    <published>2019-06-18T04:23:12.000Z</published>
    <updated>2019-06-24T09:38:57.557Z</updated>
    
    <content type="html"><![CDATA[<p>简单的可乐图片分类器 Web 部署，根据 fastai MOOC 2019 版制作。</p><p>URL 地址：<a href="https://adi-pic.onrender.com/" target="_blank" rel="external">https://adi-pic.onrender.com/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-3b757a8ab88b172a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百事可乐"></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-17499fdd67485562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可口可乐"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的可乐图片分类器 Web 部署，根据 fastai MOOC 2019 版制作。&lt;/p&gt;
&lt;p&gt;URL 地址：&lt;a href=&quot;https://adi-pic.onrender.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://a
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>「ML 笔记」- 假阳性&amp;假阴性</title>
    <link href="https://adi0229.github.io/2019/06/07/2019-06-07-ml-fp-fn/"/>
    <id>https://adi0229.github.io/2019/06/07/2019-06-07-ml-fp-fn/</id>
    <published>2019-06-07T15:35:23.000Z</published>
    <updated>2019-07-11T07:23:35.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题：机器学习里，什么是假阳性，什么是假阴性？"><a href="#问题：机器学习里，什么是假阳性，什么是假阴性？" class="headerlink" title="问题：机器学习里，什么是假阳性，什么是假阴性？"></a>问题：机器学习里，什么是假阳性，什么是假阴性？</h1><blockquote><p>学习ing，在机器学习之旅，麻省博士小姐姐带我 ︿(￣︶￣)︿</p></blockquote><p>曾经，在 python 的机器学习开源库 sklearn 的混淆矩阵模块 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" target="_blank" rel="external">scikit-learn-confusion_matrix</a> 里，笔者常常看<code>tn</code>, <code>fp</code>, <code>fn</code>, <code>tp</code>等缩写变量，百思不得其解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tn, fp, fn, tp = confusion_matrix([0, 1, 0, 1], [1, 1, 1, 0]).ravel()</div><div class="line">&gt;&gt;&gt; (tn, fp, fn, tp)</div><div class="line">(0, 2, 1, 1)</div></pre></td></tr></table></figure></p><p>如下图，检索得到的网络资料，专业论述严谨准确，但解释起来冷冰冰，对我而言，仍然显得晦涩</p><blockquote><p>混淆表格（有时候也称为混淆矩阵），是由false positives，falsenegatives，true positives和true negatives组成的两行两列的表格。<br><img src="https://upload-images.jianshu.io/upload_images/452087-85ccefae584f7319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/452087-0152fc1d4e7b9fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>True positive (TP) ：真实为P，预测为P<br>True negative (TN): 真实为N，预测为N<br>False positive (FP)：真实为N，预测为P<br>False negative (FN)：真实为P，预测为N</p></blockquote><p>包括博客文章里解释的「猫狗识别分类」例子，听过之后，笔者依然「一头雾水」。</p><p>看过这个视频之后，豁然开朗。</p><p><a href="https://www.youtube.com/watch?v=Ivc8c9ijWIQ" target="_blank" rel="external">ML Basics: False Positives, False Negatives</a></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-ec97920487dfdf56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="回答：假阳性False-Positives-amp-假阴性False-Negatives"><a href="#回答：假阳性False-Positives-amp-假阴性False-Negatives" class="headerlink" title="回答：假阳性False Positives&amp;假阴性False Negatives"></a>回答：假阳性False Positives&amp;假阴性False Negatives</h1><p>快乐学习，从形象的例子开始。</p><p>假设：给你一百张图片。让你来判断 -&gt; 每张图片中是否有人类？</p><p>这个任务需要预测两种情况——有人&amp;没人，叫做二元分类。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-53b15fbdff30e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>图片里有人，你识别「有人」——叫做「真阳性(True positive)」</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-9e11ab4508d3ee0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>图片里没人，你识别「没人」——叫做「真阴性(True negative)」<br><img src="https://upload-images.jianshu.io/upload_images/452087-250e40bbe0e8ca2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>图片里没人，你识别「有人」——叫做「假阳性(False postive)」<br><img src="https://upload-images.jianshu.io/upload_images/452087-6f3ad1036400de98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>图片里有人，你识别「没人」——叫做「假阴性(False negative)」</p></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>预测正确，以「True」开头。</li><li>预测错误，以「False」开头。</li><li>预测结果是阳性（比如「有人」、「患病」），以「 postive」结尾。</li><li>预测结果是阴性（比如「没人」、「无病」），以「 negative」结尾。</li></ul><h3 id="术语：准确率（Accuracy）"><a href="#术语：准确率（Accuracy）" class="headerlink" title="术语：准确率（Accuracy）"></a>术语：准确率（Accuracy）</h3><p><img src="https://upload-images.jianshu.io/upload_images/452087-1f2993d2e211ae53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>正确识别的图片的百分数——准确率（Accuracy）= TP+TN / TP+TN+FP+FN</p><h3 id="误区：TP-amp-TN-比-FP-amp-FN-更重要"><a href="#误区：TP-amp-TN-比-FP-amp-FN-更重要" class="headerlink" title="误区：TP&amp;TN 比 FP&amp;FN 更重要"></a>误区：TP&amp;TN 比 FP&amp;FN 更重要</h3><p>比如，在医学影像诊断疾病的应用中。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-45c6976689334aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于没有疾病的监测者，预测 TA 可能有病，需要进一步检查。这个无伤大雅。<br>但对于患病的监测者，预测 TA 没有疾病风险，那就是严重问题。</p><p>我们会更关注「假阴性率（False Negative Rate）」 = FN/FN+FP<br>换句话说，我们关注——对于多少包含患病风险的检测者，我们预测错误的比例是多少？</p><p>在安全防护领域，「假阳性率」需要关注：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-1ac9ab3229a8e5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于，自己手机的指纹识别功能，识别错了自己的指纹，这是「假阴性」，几秒钟之内多按几次，也能解锁手机，那也还好。<br>但如果，用别人的指纹，也能解锁你的手机。那就问题严重了，这是「假阳性」。</p><p>这个例子里，我们会更关注「假阳性率（False Postive Rate）」 = FP/FP+TN。换句话说，我们关注——对于多少不是本机主人指纹的打开尝试，我们预测错误的比例是多少？</p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>在智能医疗领域，比如患病风险监测的应用，我们会更关注「假阴性率（False Postive Rate）」，对于多少包含患病风险的检测者，我们预测错误的比例是多少？备注：阴性定义是——检测者没有患病风险，无需进一步检查。</li><li>在安全防护领域，比如指纹解锁功能，我们会更关注「假阳性率（False Postive Rate）」，对于多少不是本机主人指纹的打开尝试，我们预测错误的比例是多少？备注：阳性定义是——指纹是本机主人的。</li></ul><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>19.06.07 init<br>19.07.11 publish</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：机器学习里，什么是假阳性，什么是假阴性？&quot;&gt;&lt;a href=&quot;#问题：机器学习里，什么是假阳性，什么是假阴性？&quot; class=&quot;headerlink&quot; title=&quot;问题：机器学习里，什么是假阳性，什么是假阴性？&quot;&gt;&lt;/a&gt;问题：机器学习里，什么是假阳性，什
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>「ML笔记」- 机器学习生命周期（Machine Learning Lifecycle）</title>
    <link href="https://adi0229.github.io/2019/05/13/2019-05-13-mllifecyle/"/>
    <id>https://adi0229.github.io/2019/05/13/2019-05-13-mllifecyle/</id>
    <published>2019-05-13T05:34:21.000Z</published>
    <updated>2019-07-09T07:59:58.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h4 id="问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。"><a href="#问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。" class="headerlink" title="问题：公众视角 -&gt; 机器学习是「黑盒&amp;黑魔法」。"></a>问题：公众视角 -&gt; 机器学习是「黑盒&amp;黑魔法」。</h4><p>一些研究调查表明，尽管机器学习技术以及渗透到了各行各业的应用之中，但公众对机器学习知之甚少。</p><p>2017 年The Royal Society对英国普通大众进行采访，发现大部分被试对机器学习“一无所知”。虽然大部分人都知道一些采用了机器学习的科技应用，但是他们不知道机器学习如何运作，就算是比较宽泛的概念也不了解。</p><p>另一项调研，对机器学习项目里的 UX 设计师进行了调查，发现他们对机器学习也缺乏常识了解。其中一位被试，TA 把机器学习看做「黑魔法」，TA 表示：“设计师不理解科技的「边界限制」以及如何合理地应用它。”</p><p>传送门：<a href="https://mltidbits.github.io/aboutus.html" target="_blank" rel="external">mltidbits小姐姐们自我简介</a></p><h4 id="问题：机器学习从业者-gt-缺乏人种多样性-gt-「女性-amp-黑人」是少数派"><a href="#问题：机器学习从业者-gt-缺乏人种多样性-gt-「女性-amp-黑人」是少数派" class="headerlink" title="问题：机器学习从业者-&gt; 缺乏人种多样性 -&gt; 「女性&amp;黑人」是少数派"></a>问题：机器学习从业者-&gt; 缺乏人种多样性 -&gt; 「女性&amp;黑人」是少数派</h4><ul><li>2018 年，在 21 个机器学习学术会议中，仅有 18%的第一作者是女性。</li><li>黑人在谷歌员工中占比 2.5%。</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在油管的ML Tidbits频道，2位麻省AI相关专业的女博士，通过视频来阐释机器学习的整个工作循环周期，内容通俗易懂且有趣，通过此举，她们致力于减少公众对机器学习的理解偏差，以及提升机器学习相关从业人士的背景多样性。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-8548308bb6edbc70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>视频传送门：<a href="https://www.youtube.com/watch?v=ZmBUnJ7lGvQ" target="_blank" rel="external">https://www.youtube.com/watch?v=ZmBUnJ7lGvQ</a></p><h1 id="总流程：机器学习生命周期"><a href="#总流程：机器学习生命周期" class="headerlink" title="总流程：机器学习生命周期"></a>总流程：机器学习生命周期</h1><p><img src="https://upload-images.jianshu.io/upload_images/452087-31738854d768981d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义问题（Problem Definition） -&gt; 数据收集(Data Collection) -&gt; 数据分割(Dataset Spit up) -&gt; 模型训练(Model Training) -&gt; 模型评估(Model Evaluation) -&gt; 应用部署(System Deployment) -&gt; 改变世界(Impact the world)！</p><h1 id="例子-gt-一个类似朋友圈的-APP"><a href="#例子-gt-一个类似朋友圈的-APP" class="headerlink" title="例子 -&gt; 一个类似朋友圈的 APP"></a>例子 -&gt; 一个类似朋友圈的 APP</h1><p>MIT 的博士2位小姐姐，通过介绍一个有趣好懂的例子，来讲解机器学习应用的全流程。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-9b16f71f759b66cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设: 你有一个点子，想要为朋友们做一个类似微信朋友圈的APP</p><ul><li>这个 APP，采用机器学习技术（图片分类 -&gt; 人脸情绪识别）<ul><li>根据他们上传的照片，判断TA是不是心情悲伤。</li><li>如果判断TA心情悲伤，给TA发送提示消息，让TA给朋友打语音电话，或者发送一张萌图给 TA<ul><li>默认假设：看了萌图，你的朋友更容易高兴起来。</li></ul></li></ul></li></ul><p>问题来了：</p><ul><li>如何创建这个机器学习应用系统？</li><li>相应的道德问题有哪些？如何处理？</li></ul><h4 id="1-定义问题-Problem-Definition"><a href="#1-定义问题-Problem-Definition" class="headerlink" title="1.定义问题(Problem Definition)"></a>1.定义问题(Problem Definition)</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-0ec8b714e911488e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从点子 -&gt; 应用，需要走过很长的流程啊。</p><ul><li>定义问题</li></ul><p>首先，我们需要定义待解决的问题，明确问题的可操作性定义。<br>然后，问题明确之后，相关的团队成员才能协同开展工作，整个团队可以围绕着同一个目标，朝着同一个轨道在前进。</p><p>根据本次例子中的产品逻辑，使用机器学习术语来表述，这个问题定义该为「二元分类」任务。也就说，我们让电脑来预测情绪，你的朋友上传的照片是否体现了 TA 有着悲伤情绪，这里包含两个情况，也就是两种分类，因此称为「二元分类」任务。</p><ul><li>问题假设</li></ul><p>同时，我们需要对情绪下一个可操作性定义，这样，在后续工作中，我们才能确认数据集图片样本对应的标签，是准确无误的。<br>比如什么是悲伤，什么是不悲伤，如何定义，如何判断？如果是复合情绪呢？本例中，我们假设人们只有 2 种情绪，悲伤或不悲伤。这样做，牺牲了对复合情绪的考虑。（当然，有人可以既悲伤又高兴，或者看起来悲伤，其实内心狂喜。同时，如果脸部表情不能准确呈现用户内心情绪呢？（根据莉莎.巴瑞特教授的「情绪建构论」）。</p><ul><li>问题限制</li></ul><p>本例中，我们本能地「假设」，根据用户上传的照片（包含 TA的影像），我们可以判断用户的情绪。现实世界中，这个假设成立吗？如何界定对假设的置信度？</p><p>总之，模型难以完美，要有妥协。</p><p>如果悲伤的人，上传照片之后，收看了萌图，或者得到提示，给朋友打了一通语音电话，心情变好了，那不就是实现了初心吗？</p><h4 id="2-数据收集（Data-Collection）"><a href="#2-数据收集（Data-Collection）" class="headerlink" title="2. 数据收集（Data Collection）"></a>2. 数据收集（Data Collection）</h4><ul><li>第一步：总体定义</li></ul><p>从哪些用户总体（Population）收集数据？用来做什么？</p><p>若用户总体不具有代表性，那么机器从数据集中学到的特征，也是没有代表性的，实际的模型应用表现，会很差劲。</p><p>样本群体需要如何从用户总体中获取，他们之间的相似度及差别是什么？<br>用户总体数量需要多少，也就是说，多少人你需要考虑顾及到？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-061f33696dc08fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第二步：特征衡量</li></ul><blockquote><p>你无法管理你不能衡量的东西 – [Morris A. Cohen]<br>You can’t manage things you can’t measure</p></blockquote><p>考虑下列问题：</p><ul><li>我们假设，要从总体用户群中手机照片图片，那么，在总体中，他们的照片（自拍/他拍）的质量是否稳定可靠？</li><li>是否收集其他信息 -&gt; 用户人口学特征（性别/年龄/坐标等）？</li><li>是否需要收集标签（label）？本例中，图片的标签类别分为悲伤（sad）或不悲伤（not sad）</li><li>标签如何收集？拍照时做调研，或者找专业人员来手工标注？注意，务必评估标签的准确程度，包括偏差（bias，有些标签存在争议。）乃至错误的比率。</li><li>样本平衡。每种标签类别都有足够的样本数，以及比例均衡。本例中，悲伤和不悲伤的标签数目应该是五五开。这样，模型才能充分学习到图片中的人物悲伤与否的视觉特征。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-c5d93bbb487f0e5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>接着，数据科学&amp;机器学习工作的脏话累活到了。</p><p>这一步叫做「数据预处理」。（以下省略数十万字）<br>本例中，数据预处理或许是图片处理成为一致的大小和分辨率。</p><ul><li>数据收集（其他可选方法）：</li></ul><p>获取开源数据集。例如，我们在网上找到已经处理好的数据集，对图片进行了是否在微笑的标注。为了能处理我们的任务，我们可以-&gt;转换标签–&gt;微笑/不微笑 -&gt; 不悲伤/悲伤</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d7265ad3602d92a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同时，需要验证数据是否可靠：</p><p>这个公开数据集，是否可信？数据是如何收集的，总体是多少？是否很好的测量？是否适合我们的任务？</p><p>有时候，根据手头可用数据及标签，我们会迭代&amp;修正初始的「问题定义」。也就是说，重新定义问题（Redefine Problem）。此外，真实的机器学习工作流，并不是一个顺时针不变的进程，流程有时会根据现实变化，反复回溯修改，这是一个螺旋式进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-431376e7018762af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-数据集分割"><a href="#3-数据集分割" class="headerlink" title="3.数据集分割"></a>3.数据集分割</h4><p>数据收集完毕之后，我们需要分割数据集，一般会把数据集分成三份：训练集-验证集-测试集。</p><p>训练集：模型学习数据特征的那部分，数量占比最大。类似我们考试时，做的常规习题<br>验证集：模型做常规习题之后，会做模拟题，比如高考前每月进行月考模拟考，以此来评估日常学习的效果。<br>测试集：模型学习了训练集及在验证集评估之后，类似于真正一锤定音的高考题目。需要真刀真枪地在一些它没有学习过的题目上，进行预测分类等任务。</p><h4 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4.  定义模型"></a>4.  定义模型</h4><p>前期的数据准备好了之后，万事俱备只欠东风。这时候，就是「机器」学习的时候了。</p><p>模型结构，需要根据数据类型来搭建。比如，如果你的数据是时序数据（timeseries），那么你最好选择擅长学习时序关系的模型架构。</p><p>常见的数据结构类型：</p><p>文本数据（text）<br>结构数据（tabular）<br>图片数据（image）</p><p>本例中，对于图片数据，卷积神经网络是当前最合适的。卷积神经网络的简易应用，参见笔记[旧调重弹—— Fastai-v3版尝鲜之猫狗图片识别(<a href="https://www.jianshu.com/p/7f315d0482a4" target="_blank" rel="external">https://www.jianshu.com/p/7f315d0482a4</a>)</p><p>模型结构的深度及广度，不是越高级越复杂越好，针对具体的数据集，合适就好。<br>对于简单的数据集，模型无需太复杂。<br>对于复杂的数据集，模型不能太简单。</p><p>如何微调模型的结构和参数等，目前更多地依靠数据科学家们的直觉经验，更像一门艺术，而非严谨的科学。fastai创始人Jeremy曾解释过，他都是根据经验法则（Rule of Thumb）来选择超参数（HyperParameters）中的学习率（LearningRate）的。</p><h4 id="5-训练模型"><a href="#5-训练模型" class="headerlink" title="5.   训练模型"></a>5.   训练模型</h4><ul><li>不同模型，有着不同的步骤来优化表现。例如，神经网络反向传播技术（BackPropagation）来迭代模型各层的权重来优化模型整体表现。</li><li>通过对比评估在验证集上的表现，我们可以选择最优的模型结构，选择训练时长。（比如，在过拟合之前停止训练。）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-af5f63dbeb9a0659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="6-评估模型"><a href="#6-评估模型" class="headerlink" title="6.   评估模型"></a>6.   评估模型</h4><ul><li>测试集。模型训练完毕之后，我们可以在测试集上评估其整体表现。</li><li>基准（benchmark）数据集。我们可以在公开的基准数据集上测试，以对比我们与其他模型的性能。别忘了「交叉验证」思维，同时，需要对基准数据集的是否可靠进行评估。</li><li>衡量模型的指标。针对不同任务，我们需要选择不同的指标（metrics）来评估模型。如果你了解「真阳性（True Positive）」、「False Negative（假阴性）」等概念，那么，在本例中，你应该明白，模型预测时出现了太多的「假阳性」的错误判断，并不是那么重要，因为如果你的朋友并不悲伤，但是给 TA 发送萌图，也并不影响，这是锦上添花。但是如果模型有太多的「假阴性（False Negative）」，那就表现差劲了，因为，我们不想错失那些上传了在图片里表现悲伤的朋友们。所以，我们更密切关注「 假阴性率（False Negative Rate）」这一指标。</li><li>评估模型在不同用户群（sub-group）中的表现，我们需要保证，在不同的用户分群中，模型的表现都是一致的。比如，如果训练集的图片，大多来自女性，那么在预测其他性别朋友的图片时，模型的表现会很差。在部署模型前，我们需要测试，及时发现这些表现不均衡的问题。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-de52b9f123eb97ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="7-应用部署"><a href="#7-应用部署" class="headerlink" title="7.   应用部署"></a>7.   应用部署</h4><ul><li>第一步</li></ul><p>为了确保模型高效及正确地部署到现实世界，请考虑模型的外在呈现：</p><p>用户交互界面如何设计？模型预测结果如何在界面中视觉化呈现？<br>如何让用户上传图片？是否需要考虑相应地调整亮度？<br>如何获取用户实时反馈：如果某些图片中的用户情绪，我们的模型预测错了，如何收集这些错误的例子？</p><ul><li>第二步</li></ul><p>假如，这个产品原型冷启动之后，在朋友之间大受欢迎，我们想要提升（Scale it up）用户规模和群体。请考虑如何 适配新增的用户群：</p><ul><li>新增用户群：其他用户群？比如，老年人&amp;小孩，模型是否还适用？是否需要新增关于「老年人」&amp;「小孩」的数据集？甚至邀请「老年人」来做用研测试？</li><li>与利益相关者沟通：随着应用的影响力范围规模增大，更多的利益相关者会参与进来，如何协同平衡各方的利益？</li><li>用户隐私&amp;数据知情权：用户数据如何收集？如何使用？本例中，最开始，我们假设用户都知道了他们的图片会被收集，但如果我们提升了用户群体的规模，我们也需要让其他用户对自己的隐私数据是如何被收集/存储/处理的。</li></ul><p>当模型在现实中运转时，我们需要密切监控的表现，保证其朝着积极的方向在运行。<br>如果出现故障bugs或社会争议（比如，有人认为YouTube推荐系统存在政治偏见及用户内容的刻意诱导。<a href="https://www.fast.ai/2019/05/28/google-nyt-mohan/" target="_blank" rel="external">Was this Google Executive deeply misinformed or lying in the New York Times?</a>）</p><p>结尾鸡汤：记住，世界在变，新问题每天降临，让我们用机器学习的集体智慧，来拥抱不确定吧。</p><h1 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h1><p>2019.5.13 init<br>2019.5.15 add content<br>2019.5.17 finish draft<br>2019.7.06 edit<br>2019.7.09 publish</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h4 id=&quot;问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。&quot;&gt;&lt;a href=&quot;#问题：公众视角-gt-机器学习是「黑盒-amp-
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>在Google Colab 中显示Plotly</title>
    <link href="https://adi0229.github.io/2019/04/10/2019-04-10-plotlycolab/"/>
    <id>https://adi0229.github.io/2019/04/10/2019-04-10-plotlycolab/</id>
    <published>2019-04-10T14:42:57.000Z</published>
    <updated>2019-04-10T14:42:54.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Google-Colab-中显示-Plotly"><a href="#在-Google-Colab-中显示-Plotly" class="headerlink" title="在 Google Colab 中显示 Plotly"></a>在 Google Colab 中显示 Plotly</h1><h2 id="Python绘图可视化工具包-Plotly"><a href="#Python绘图可视化工具包-Plotly" class="headerlink" title="Python绘图可视化工具包-Plotly"></a>Python绘图可视化工具包-Plotly</h2><p>Plotly 能够绘制交互式的数据可视化图表，提供印刷品质的图表图片。</p><p> 近日，笔者在 colab 上使用 Plotly，遇到了一个小坑，需要运行特定函数，才能在 colab 上显示 Plotly 的交互图表。</p><p>解决代码分享：</p><p><a href="https://colab.research.google.com/drive/14oudHx5e5r7hm1QcbZ24FVHXgVPD0k8f" target="_blank" rel="external">Plotly in Colab.ipynb</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import plotly.plotly as py</div><div class="line">from plotly.offline import init_notebook_mode, iplot</div><div class="line"></div><div class="line"></div><div class="line">def configure_plotly_browser_state():</div><div class="line">  import IPython</div><div class="line">  display(IPython.core.display.HTML(&apos;&apos;&apos;</div><div class="line">        &lt;script src=&quot;/static/components/requirejs/require.js&quot;&gt;&lt;/script&gt;</div><div class="line">        &lt;script&gt;</div><div class="line">          requirejs.config(&#123;</div><div class="line">            paths: &#123;</div><div class="line">              base: &apos;/static/base&apos;,</div><div class="line">              plotly: &apos;https://cdn.plot.ly/plotly-latest.min.js?noext&apos;,</div><div class="line">            &#125;,</div><div class="line">          &#125;);</div><div class="line">        &lt;/script&gt;</div><div class="line">        &apos;&apos;&apos;))</div><div class="line"></div><div class="line">configure_plotly_browser_state()</div><div class="line">init_notebook_mode(connected=False)</div></pre></td></tr></table></figure><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.04.10 init</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在-Google-Colab-中显示-Plotly&quot;&gt;&lt;a href=&quot;#在-Google-Colab-中显示-Plotly&quot; class=&quot;headerlink&quot; title=&quot;在 Google Colab 中显示 Plotly&quot;&gt;&lt;/a&gt;在 Google Co
      
    
    </summary>
    
    
      <category term="技术" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python新手练习-PyBite</title>
    <link href="https://adi0229.github.io/2019/03/02/2019-03-02-pybite/"/>
    <id>https://adi0229.github.io/2019/03/02/2019-03-02-pybite/</id>
    <published>2019-03-02T04:47:11.000Z</published>
    <updated>2019-07-19T14:59:07.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python新手练习-PyBite"><a href="#Python新手练习-PyBite" class="headerlink" title="Python新手练习-PyBite"></a>Python新手练习-PyBite</h2><h4 id="Bite-108-循环历遍可命名元祖计算总分-Loop-over-a-dict-of-namedtuples-calculating-a-total-score"><a href="#Bite-108-循环历遍可命名元祖计算总分-Loop-over-a-dict-of-namedtuples-calculating-a-total-score" class="headerlink" title="Bite 108 循环历遍可命名元祖计算总分(Loop over a dict of namedtuples calculating a total score)"></a>Bite 108 循环历遍可命名元祖计算总分(Loop over a dict of namedtuples calculating a total score)</h4><blockquote><p>有一个字典，字典中包含了不同颜色的pybite忍者腰带奖章，以及对应的分数及获得人数。需要构建一个函数，计算python所有忍者的总得分。</p></blockquote><p>知识点：</p><ul><li><code>collection</code> 的 <code>nametuple</code></li><li>列表推导式</li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"></div><div class="line">BeltStats = namedtuple(&apos;BeltStats&apos;, &apos;score ninjas&apos;)</div><div class="line"></div><div class="line">ninja_belts = &#123;&apos;yellow&apos;: BeltStats(50, 11),</div><div class="line">               &apos;orange&apos;: BeltStats(100, 7),</div><div class="line">               &apos;green&apos;: BeltStats(175, 1),</div><div class="line">               &apos;blue&apos;: BeltStats(250, 5)&#125;</div><div class="line"></div><div class="line"></div><div class="line">def get_total_points(belts=ninja_belts):</div><div class="line">    &quot;&quot;&quot;Calculate the amount of points rewarded on PyBites given the</div><div class="line">       ninja_belts dictionary, formula: belt score x belt owners (aka ninjas)</div><div class="line">       (of course there are more points but let&apos;s keep it simple)</div><div class="line"></div><div class="line">       Make your code generic so if we update ninja_belts to include</div><div class="line">       more belts (which we do in the tests) it will still work.</div><div class="line"></div><div class="line">       Ah and you can get score and ninjas from the namedtuple with nice</div><div class="line">       attribute access: belt.score / belt.ninjas (reason why we get</div><div class="line">       you familiar with namedtuple here, because we love them and use</div><div class="line">       them all over the place!)</div><div class="line">       </div><div class="line">       Return the total number of points int from the function.&quot;&quot;&quot;</div><div class="line">       </div><div class="line">       total_points = 0</div><div class="line">    </div><div class="line">    for belt in belts.values():</div><div class="line">        scores = belt.score * belt.ninjas</div><div class="line">        total_points += scores</div><div class="line">    </div><div class="line">    return total_points</div></pre></td></tr></table></figure><p>列表推导式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return sum([belt[0] * belt[1] for belt in belts.values()])</div></pre></td></tr></table></figure><h4 id="Bite-109-健身字典查询及抛出异常-Workout-dict-lookups-and-raising-an-exception"><a href="#Bite-109-健身字典查询及抛出异常-Workout-dict-lookups-and-raising-an-exception" class="headerlink" title="Bite 109 健身字典查询及抛出异常(Workout dict lookups and raising an exception)"></a>Bite 109 健身字典查询及抛出异常(Workout dict lookups and raising an exception)</h4><blockquote><p>查询健身周计划的字典，并在日期输入键值错误时，抛出异常</p></blockquote><p>知识点：</p><ul><li>抛出异常 -&gt; <code>exception</code></li><li><code>format</code></li><li><code>title()</code></li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">workout_schedule = &#123;&apos;Friday&apos;: &apos;Shoulders&apos;,</div><div class="line">                    &apos;Monday&apos;: &apos;Chest+biceps&apos;,</div><div class="line">                    &apos;Saturday&apos;: &apos;Rest&apos;,</div><div class="line">                    &apos;Sunday&apos;: &apos;Rest&apos;,</div><div class="line">                    &apos;Thursday&apos;: &apos;Legs&apos;,</div><div class="line">                    &apos;Tuesday&apos;: &apos;Back+triceps&apos;,</div><div class="line">                    &apos;Wednesday&apos;: &apos;Core&apos;&#125;</div><div class="line">rest, chill, go_train = &apos;Rest&apos;, &apos;Chill out!&apos;, &apos;Go train &#123;&#125;&apos;</div><div class="line"></div><div class="line"></div><div class="line">def get_workout_motd(day):</div><div class="line">    &quot;&quot;&quot;Title case passed in day argument (monday or MONDAY -&gt; Monday)</div><div class="line">       and check if it is in the given workout_schedule dict.</div><div class="line"></div><div class="line">       If it is there retrieve the workout, if not raise a KeyError.</div><div class="line"></div><div class="line">       Return the chill or go_train variable depending the retrieved</div><div class="line">       workout value (&apos;Rest&apos; or workout bla)</div><div class="line"></div><div class="line">       Trivia: /etc/motd is a file on Unix-like systems that contains</div><div class="line">       a &apos;message of the day&apos;&quot;&quot;&quot;</div><div class="line">    try:</div><div class="line">        workout = workout_schedule[day.title()]</div><div class="line">    except KeyError:</div><div class="line">        raise KeyError(&apos;Workout does not exist.&apos;)</div><div class="line">    return chill if workout == rest else go_train.format(workout)</div></pre></td></tr></table></figure><h4 id="Bite-110-类型转换-amp-处理异常-Type-conversion-and-exception-handling"><a href="#Bite-110-类型转换-amp-处理异常-Type-conversion-and-exception-handling" class="headerlink" title="Bite 110 类型转换&amp;处理异常(Type conversion and exception handling)"></a>Bite 110 类型转换&amp;处理异常(Type conversion and exception handling)</h4><blockquote><p>写一个函数，输入包含分子&amp;分母，把分子&amp;分母转换成整数的数据类型，然后分子除以分母。处理两种异常，输入值异常&amp;分母为零。</p></blockquote><p>知识点</p><ul><li><code>ValueError</code></li><li><code>ZeroDivisonError</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def divide_numbers(numerator, denominator):</div><div class="line">    &quot;&quot;&quot;For this exercise you can assume numerator and denominator are of type</div><div class="line">       int/str/float.</div><div class="line">       Try to convert numerator and denominator to int types, if that raises a</div><div class="line">       ValueError reraise it. Following do the division and return the result.</div><div class="line">       However if denominator is 0 catch the corresponding exception Python</div><div class="line">       throws (cannot divide by 0), and return 0&quot;&quot;&quot;</div><div class="line">    try:</div><div class="line">        numerator = int(numerator)</div><div class="line">        denominator = int(denominator)</div><div class="line">    except ValueError:</div><div class="line">        raise</div><div class="line"></div><div class="line">    try:</div><div class="line">        return numerator / denominator</div><div class="line">    except ZeroDivisionError:</div><div class="line">        return 0</div></pre></td></tr></table></figure><h4 id="Bite-1-累加-N-个数字-Sum-n-numbers"><a href="#Bite-1-累加-N-个数字-Sum-n-numbers" class="headerlink" title="Bite 1 累加 N 个数字(Sum n numbers)"></a>Bite 1 累加 N 个数字(Sum n numbers)</h4><blockquote><ul><li>输入：n个数字或者无输入</li><li>计算：将所有输入的序列元素数字相加，计算它们总数。如果没有输入数字，则返回从 1、2、3、……到 100 的总数</li><li>输出：总数</li></ul></blockquote><p>知识点</p><ul><li><code>sum</code></li><li><code>range</code></li></ul><p>思路：</p><ol><li>判断 numbers 是否是 None，如果是None,计算并返回 1……100（<code>range(1,101)</code>） 的叠加总数</li><li>如果 numbers 不是 None，计算并返回所输入的数字的叠加总数</li></ol><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def sum_numbers(numbers=None):</div><div class="line">    if numbers is None:</div><div class="line">        return sum(range(1,101))</div><div class="line">    else:</div><div class="line">        return sum(numbers)</div></pre></td></tr></table></figure><h4 id="Bite-5-解析一个列表中的名字-Parse-a-list-of-names"><a href="#Bite-5-解析一个列表中的名字-Parse-a-list-of-names" class="headerlink" title="Bite 5 解析一个列表中的名字(Parse a list of names)"></a>Bite 5 解析一个列表中的名字(Parse a list of names)</h4><blockquote><ul><li>输入：一个列表，包含一串名字的字符串</li><li>计算：1. 对名字去重 2.按照surname倒序排序 3. 获取长度最短的 firstname</li><li>输出：1.去重后的名字，每个单词首个字母大写 2. 返回排序后的名字列表 3.返回最短的首名 firstname</li></ul></blockquote><p>知识点</p><ul><li><code>sorting</code></li><li><code>min</code></li><li><code>lambda</code></li><li><code>list comprehesions</code></li></ul><p>思路：</p><ol><li>set()获取NAMES独特值(unique),（set 是 unordered）,再用列表推导式，将每一个 set 中的元素 title(), 返回列表</li><li>匿名函数 lambda x: x.split(“ “),将NAMES的元素按照空格 whitespace 拆分成 firstname surname</li><li>string[-1]切片获取列表中的倒数第一个元素</li><li><code>sorted</code>方法对元素进行排序,reverse=True(Desending order)</li><li>列表推导式，生成只包含 first name的列表。再用 min()返回最短的firstname</li></ol><p>问题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NAMES = [&apos;arnold schwarzenegger&apos;, &apos;alec baldwin&apos;, &apos;bob belderbos&apos;,</div><div class="line">         &apos;julian sequeira&apos;, &apos;sandra bullock&apos;, &apos;keanu reeves&apos;,</div><div class="line">         &apos;julbob pybites&apos;, &apos;bob belderbos&apos;, &apos;julian sequeira&apos;,</div><div class="line">         &apos;al pacino&apos;, &apos;brad pitt&apos;, &apos;matt damon&apos;, &apos;brad pitt&apos;]</div><div class="line"></div><div class="line"></div><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    pass</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    # ...</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    # ...</div></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from names import (NAMES, dedup_and_title_case_names,</div><div class="line">                   sort_by_surname_desc, shortest_first_name)</div><div class="line"></div><div class="line"></div><div class="line">def test_dedup_and_title_case_names():</div><div class="line">    names = dedup_and_title_case_names(NAMES)</div><div class="line">    assert names.count(&apos;Bob Belderbos&apos;) == 1</div><div class="line">    assert names.count(&apos;julian sequeira&apos;) == 0</div><div class="line">    assert names.count(&apos;Brad Pitt&apos;) == 1</div><div class="line">    assert len(names) == 10</div><div class="line">    assert all(n.title() in names for n in NAMES)</div><div class="line"></div><div class="line"></div><div class="line">def test_sort_by_surname_desc():</div><div class="line">    names = sort_by_surname_desc(NAMES)</div><div class="line">    assert names[0] == &apos;Julian Sequeira&apos;</div><div class="line">    assert names[-1] == &apos;Alec Baldwin&apos;</div><div class="line"></div><div class="line"></div><div class="line">def test_shortest_first_name():</div><div class="line">    assert shortest_first_name(NAMES) == &apos;Al&apos;</div></pre></td></tr></table></figure><p>解题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    return [name.title() for name in set(names)]</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return sorted(names, key = lambda x: x.split(&quot; &quot;)[-1] , reverse = True )</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return min([name.split(&quot; &quot;)[0] for name in names])</div></pre></td></tr></table></figure><p>参考答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">NAMES = [&apos;arnold schwarzenegger&apos;, &apos;alec baldwin&apos;, &apos;bob belderbos&apos;,</div><div class="line">         &apos;julian sequeira&apos;, &apos;sandra bullock&apos;, &apos;keanu reeves&apos;,</div><div class="line">         &apos;julbob pybites&apos;, &apos;bob belderbos&apos;, &apos;julian sequeira&apos;,</div><div class="line">         &apos;al pacino&apos;, &apos;brad pitt&apos;, &apos;matt damon&apos;, &apos;brad pitt&apos;]</div><div class="line"></div><div class="line"></div><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    return list(&#123;name.title() for name in names&#125;)</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return sorted(names,</div><div class="line">                  key=lambda x: x.split()[-1],</div><div class="line">                  reverse=True)</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    names = [name.split()[0] for name in names]</div><div class="line">    return min(names, key=len)</div></pre></td></tr></table></figure><p>缺漏处：</p><ul><li>第一个函数，用的是字典推导式。因为字典不允许重复 Key</li><li>第三个函数，min()的key参数设置为 len</li></ul><h4 id="Bite-8-调换字母顺序-Rotate-string-characters"><a href="#Bite-8-调换字母顺序-Rotate-string-characters" class="headerlink" title="Bite 8 调换字母顺序(Rotate string characters)"></a>Bite 8 调换字母顺序(Rotate string characters)</h4><blockquote><ul><li>输入：字符串string&amp;整数n</li><li>计算：若整数大于0，则将前 n 个字母调换到末尾。/ 若整数小于0，则将后n 个字母调换到末尾。</li><li>输出：调换后的字符串（rotated string）</li></ul></blockquote><p>知识点</p><ul><li><code>slice</code>切片</li><li><code>deque</code>双端队列</li></ul><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Last login: Wed Jul 10 14:50:31 on ttys004</div><div class="line">adi0229 (adi0229 *) ~</div><div class="line"></div><div class="line">&gt;&gt;&gt; string = &apos;hello&apos;</div><div class="line">&gt;&gt;&gt; string[2:] + string[:2]</div><div class="line">&apos;llohe&apos;</div><div class="line">&gt;&gt;&gt; string[-2:] + string[:-2]</div><div class="line">&apos;lohel&apos;</div></pre></td></tr></table></figure><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def rotate(string, n):</div><div class="line">    &quot;&quot;&quot;Rotate characters in a string.</div><div class="line">       Expects string and n (int) for number of characters to move.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    return string[n:] + string[:n]</div></pre></td></tr></table></figure><h4 id="Bite-15-列举-2-个序列-Enumerate-2-sequence"><a href="#Bite-15-列举-2-个序列-Enumerate-2-sequence" class="headerlink" title="Bite 15 列举 2 个序列(Enumerate 2 sequence)"></a>Bite 15 列举 2 个序列(Enumerate 2 sequence)</h4><blockquote><ul><li>输入：2 个列表，包含名字和国家字段</li><li>计算：列举2个列表的字段——名字和国家，根据索引位置，一一对应。</li><li>输出：按照索引的数字顺序，打印出对应的列表字段。</li></ul></blockquote><p>知识点</p><ul><li><code>enumerate</code>列举，枚举</li><li><code>string formatting</code>字符串格式</li></ul><p>代码实例参考</p><p><code>enumerate</code>列举，枚举</p><p><a href="https://stackoverflow.com/questions/16326853/enumerate-two-python-lists-simultaneously/16326876" target="_blank" rel="external">https://stackoverflow.com/questions/16326853/enumerate-two-python-lists-simultaneously/16326876</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for index, (value1, value2) in enumerate(zip(data1, data2)):</div><div class="line">    print index, value1 + value2</div></pre></td></tr></table></figure><ul><li><code>string formatting</code>字符串对齐</li></ul><p>在 <code>format</code>方法中，使用<code>&lt;</code>,<code>&gt;</code>,<code>^</code>等符号来指定左对齐、右对齐或者居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;&#123;1:&lt;15&#125;&#123;0:^10&#125;&#123;2:&gt;15&#125;&quot;.format(center, left_aligned, right_aligned)</div><div class="line">&apos;Left Align      Centered     Right Align&apos;</div></pre></td></tr></table></figure><p>python 3.6 的 <code>f-string</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f&quot;&#123;left_aligned:&lt;15&#125;&#123;center:^10&#125;&#123;right_aligned:&gt;15&#125;&quot;</div><div class="line">&apos;Left Align      Centered     Right Align&apos;</div></pre></td></tr></table></figure><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Last login: Wed Jul 10 14:50:31 on ttys004</div><div class="line">adi0229 (adi0229 *) ~</div><div class="line"></div><div class="line">&gt;&gt;&gt; names = &apos;Julian Bob PyBites Dante Martin Rodolfo&apos;.split()</div><div class="line">&gt;&gt;&gt; countries = &apos;Australia Spain Global Argentina USA Mexico&apos;.split()</div><div class="line">&gt;&gt;&gt; names</div><div class="line">[&apos;Julian&apos;, &apos;Bob&apos;, &apos;PyBites&apos;, &apos;Dante&apos;, &apos;Martin&apos;, &apos;Rodolfo&apos;]</div><div class="line">&gt;&gt;&gt; countries</div><div class="line">[&apos;Australia&apos;, &apos;Spain&apos;, &apos;Global&apos;, &apos;Argentina&apos;, &apos;USA&apos;, &apos;Mexico&apos;]</div></pre></td></tr></table></figure><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">names = &apos;Julian Bob PyBites Dante Martin Rodolfo&apos;.split()</div><div class="line">countries = &apos;Australia Spain Global Argentina USA Mexico&apos;.split()</div><div class="line"></div><div class="line"></div><div class="line">def enumerate_names_countries():</div><div class="line">    &quot;&quot;&quot;Outputs:</div><div class="line">       1. Julian     Australia</div><div class="line">       2. Bob        Spain</div><div class="line">       3. PyBites    Global</div><div class="line">       4. Dante      Argentina</div><div class="line">       5. Martin     USA</div><div class="line">       6. Rodolfo    Mexico&quot;&quot;&quot;</div><div class="line">    for index, (name, country) in enumerate(zip(names, countries)):</div><div class="line">        print(&quot;&#123;0:&lt;3&#125;&#123;1:&lt;11&#125;&#123;2&#125;&quot;.format(str(index+1)+&apos;.&apos;,name,country))   </div><div class="line">        </div><div class="line">enumerate_names_countries()</div><div class="line"></div><div class="line">$ /Users/apple/anaconda3/envs/magenta/bin/python /Users/apple/Desktop/pybite_intro_08.py</div><div class="line">1. Julian     Australia</div><div class="line">2. Bob        Spain</div><div class="line">3. PyBites    Global</div><div class="line">4. Dante      Argentina</div><div class="line">5. Martin     USA</div><div class="line">6. Rodolfo    Mexico</div></pre></td></tr></table></figure><p>思路：</p><ul><li><code>zip</code>打包，name和 country2 个可迭代的列表对象</li><li>在 for 循环中，<code>enumerate</code>组合成索引序列</li><li><code>format</code>指定第二个位置左对齐 11 个chars。第一个位置是调试出来的，字符串的间距3chars？</li></ul><h4 id="Bite-16-PyBite日期生成器-PyBites-date-generator"><a href="#Bite-16-PyBite日期生成器-PyBites-date-generator" class="headerlink" title="Bite 16 PyBite日期生成器(PyBites date generator)"></a>Bite 16 PyBite日期生成器(PyBites date generator)</h4><blockquote><ul><li>输入：2 个列表，包含名字和国家字段</li><li>计算：  每年每一百天</li><li>输出：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">from itertools import islice</div><div class="line"></div><div class="line">from gendates import gen_special_pybites_dates</div><div class="line"></div><div class="line"></div><div class="line">def test_gen_special_pybites_dates():</div><div class="line">    gen = gen_special_pybites_dates()</div><div class="line">    dates = list(islice(gen, 100))</div><div class="line"></div><div class="line">    expected = [datetime.datetime(2017, 3, 29, 0, 0),</div><div class="line">                datetime.datetime(2017, 7, 7, 0, 0),</div><div class="line">                datetime.datetime(2017, 10, 15, 0, 0),</div><div class="line">                datetime.datetime(2017, 12, 19, 0, 0),</div><div class="line">                datetime.datetime(2018, 1, 23, 0, 0),</div><div class="line">                datetime.datetime(2018, 5, 3, 0, 0),</div><div class="line">                datetime.datetime(2018, 8, 11, 0, 0),</div><div class="line">                datetime.datetime(2018, 11, 19, 0, 0),</div><div class="line">                datetime.datetime(2018, 12, 19, 0, 0),</div><div class="line">                datetime.datetime(2019, 2, 27, 0, 0)]</div><div class="line"></div><div class="line">    assert dates[:10] == expected</div></pre></td></tr></table></figure><p>知识点</p><ul><li><code>islice</code></li></ul><p><a href="http://funhacks.net/2017/02/13/itertools/" target="_blank" rel="external">http://funhacks.net/2017/02/13/itertools/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">islice(iterable, [start,] stop [, step])</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from itertools import count, islice</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice([10, 6, 2, 8, 1, 3, 9], 5))</div><div class="line">[10, 6, 2, 8, 1]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice(count(), 6))</div><div class="line">[0, 1, 2, 3, 4, 5]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice(count(), 3, 10))</div><div class="line">[3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; list(islice(count(), 3, 10 ,2))</div><div class="line">[3, 5, 7, 9]</div></pre></td></tr></table></figure><p>关于<code>itertool</code>里的<code>count</code></p><p>官方文档：<a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.count" target="_blank" rel="external">https://docs.python.org/zh-cn/3/library/itertools.html#itertools.count</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def count(start=0, step=1):</div><div class="line">    # count(10) --&gt; 10 11 12 13 14 ...</div><div class="line">    # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</div><div class="line">    n = start</div><div class="line">    while True:</div><div class="line">        yield n</div><div class="line">        n += step</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">itertools.count(start=0, step=1)</div></pre></td></tr></table></figure><p>可见，count()返回 0 开头，1 为步长的序列。</p><p>上面的代码块，最后一行代码解读，count()返回一个可迭代对象（），开始索引是 3，结束索引 10，step 步长是 2。<br>所以，加上list()之后，输出是[3,5,7,9]</p><p><code>datetime.datetime</code></p><p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="external">https://docs.python.org/3/library/datetime.html</a></p><p>一个<code>datetime</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</div></pre></td></tr></table></figure><p>年月日是必需参数。测试脚本里的 2 个0，指的是小时hour和分钟minute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">PYBITES_BORN = datetime(year=2016, month=12, day=19)</div><div class="line"></div><div class="line"></div><div class="line">def gen_special_pybites_dates():</div><div class="line">    pass</div></pre></td></tr></table></figure><p><code>datetime</code></p><p><a href="https://www.guru99.com/date-time-and-datetime-classes-in-python.html#5" target="_blank" rel="external">https://www.guru99.com/date-time-and-datetime-classes-in-python.html#5</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt; datetime.today()</div><div class="line">datetime.datetime(2019, 7, 12, 19, 27, 59, 688655)</div><div class="line">&gt;&gt;&gt; from datetime import timedelta</div><div class="line">&gt;&gt;&gt; timedelta(days=100)</div><div class="line">datetime.timedelta(100)</div><div class="line">&gt;&gt;&gt; datetime.timedelta(100)</div></pre></td></tr></table></figure><p>语言问题，对题目具体要求不甚了解，代码没写出，因此直接看了答案，恍然大悟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime, timedelta</div><div class="line"></div><div class="line">PYBITES_BORN = datetime(year=2016, month=12, day=19)</div><div class="line"></div><div class="line"></div><div class="line">def gen_special_pybites_dates():</div><div class="line">    days = 0</div><div class="line">    while True:</div><div class="line">        days += 1</div><div class="line">        if days % 100 == 0 or days % 365 == 0:</div><div class="line">            yield PYBITES_BORN + timedelta(days=days)</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建 Days 变量，初始赋值 0</li><li>永久循环，每次循环迭代变量+1</li><li>当days 是 100 或者 365 的整数时，返回 PYBITES_BORN + 当前天数的时间 delta</li></ol><p>反思：</p><ul><li>查询<code>timedelta()</code>等相关函数知识，是必要的</li><li>需要强化英语语言的理解水平</li></ul><h4 id="Bite-19-写一个简单的属性-Write-a-Simple-Property"><a href="#Bite-19-写一个简单的属性-Write-a-Simple-Property" class="headerlink" title="Bite 19 写一个简单的属性(Write a Simple Property)"></a>Bite 19 写一个简单的属性(Write a Simple Property)</h4><blockquote><ul><li>输入：格式为字符串的名称（name），格式为 datetime 的过期时间（expires）</li><li>计算：当前时间，是否大于过期时间。</li><li>输出：一个名为番茄钟的类（class），包含过期与否的布尔值属性</li></ul></blockquote><p>知识点：</p><ul><li><code>datetime</code></li><li><code>properties</code></li></ul><p>一个疑问，如何指定函数参数的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def pick(l: list, index: int) -&gt; int:</div><div class="line">    return l[index]</div></pre></td></tr></table></figure><p>从上面的示例可知，pick 函数输入 2 个参数，一个<code>l</code>列表，一个<code>index</code>整数，输出是整数（integer）。</p><p>另一个疑问，如何传入<code>datetime</code>类型的对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">class Person:</div><div class="line"></div><div class="line">    def __init__(self, first_name, last_name, birth_date):</div><div class="line">        self.first_name = first_name</div><div class="line">        self.last_name = last_name</div><div class="line">        self.birth_date = datetime.strptime(birth_date, &apos;%b %d %Y&apos;)</div><div class="line"></div><div class="line">    def fullname(self):</div><div class="line">        return self.first + &apos; &apos; + self.last_name</div><div class="line"></div><div class="line">person = Person(&apos;John&apos;, &apos;Doe&apos;, &apos;Jun 1 2005&apos;)</div><div class="line"></div><div class="line">print(person.birth_date)</div></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2005-06-01 00:00:00</div></pre></td></tr></table></figure><p>想法：判断 -&gt; NOW(当前时间) 大于&gt; expires(过期时间),返回布尔值</p><p>解题过程：</p><p>查看datetime.now()的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; datetime.now()</div><div class="line">datetime.datetime(2019, 7, 15, 14, 13, 34, 943274)</div></pre></td></tr></table></figure><p>检索“compare date python”,获得示例代码</p><p>来源：<a href="https://www.geeksforgeeks.org/comparing-dates-python/" target="_blank" rel="external">https://www.geeksforgeeks.org/comparing-dates-python/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import datetime </div><div class="line">  </div><div class="line"># date in yyyy/mm/dd format </div><div class="line">d1 = datetime.datetime(2018, 5, 3) </div><div class="line">d2 = datetime.datetime(2018, 6, 1) </div><div class="line">  </div><div class="line"># Comparing the dates will return </div><div class="line"># either True or False </div><div class="line">print(&quot;d1 is greater than d2 : &quot;, d1 &gt; d2) </div><div class="line">print(&quot;d1 is less than d2 : &quot;, d1 &lt; d2) </div><div class="line">print(&quot;d1 is not equal to d2 : &quot;, d1 != d2)</div></pre></td></tr></table></figure><p>测试脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import timedelta</div><div class="line"></div><div class="line">from simple_property import Promo, NOW</div><div class="line"></div><div class="line"></div><div class="line">def test_promo_expired():</div><div class="line">    past_time = NOW - timedelta(seconds=3)</div><div class="line">    twitter_promo = Promo(&apos;twitter&apos;, past_time)</div><div class="line">    assert twitter_promo.expired</div><div class="line"></div><div class="line"></div><div class="line">def test_promo_not_expired():</div><div class="line">    future_date = NOW + timedelta(days=1)</div><div class="line">    newsletter_promo = Promo(&apos;newsletter&apos;, future_date)</div><div class="line">    assert not newsletter_promo.expired</div></pre></td></tr></table></figure><p>解题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">NOW = datetime.now()</div><div class="line"></div><div class="line"></div><div class="line">class Promo:</div><div class="line">    </div><div class="line">    def __init__(self, name, datetime):</div><div class="line">        self.name = name</div><div class="line">        self.datetime = datetime</div><div class="line">        self.expired = NOW-datetime</div></pre></td></tr></table></figure><p>显然，函数的「参数格式」以及「datetime」格式转化，在本题中不需要处理。<br>只需要 -&gt; 添加 self.expired 属性，通过判断时间大小，返回 True&amp;False 的布尔值</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-00a6dc8800bbae1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="Bite-21-查询一个嵌入式数据结构-Query-a-nested-data-structure"><a href="#Bite-21-查询一个嵌入式数据结构-Query-a-nested-data-structure" class="headerlink" title="Bite 21 查询一个嵌入式数据结构(Query a nested data structure)"></a>Bite 21 查询一个嵌入式数据结构(Query a nested data structure)</h4><blockquote><ul><li>输入：一个<code>cars</code>字典</li><li>计算：1、根据字符的 key，获取value 2、匹配字符串 3、根据阿拉伯字母顺序排序</li><li>输出：1、所有 jeeps 的模型名称 2、获取每个制造商的第一种车型 3、获取所有名称中包含字符串<code>Trail</code>的车型 3、按照阿拉伯字母对车型字典中的值进行排序</li><li>根据论坛讨论，2018.12.18日的讨论，每个函数都传入 cars 字典作为局部变量(Scope local)，这样写法更好。</li></ul></blockquote><p>知识点</p><ul><li><code>dictionary comprehesions</code></li><li><a href="https://stackoverflow.com/questions/14032521/python-data-structure-sort-list-alphabetically" target="_blank" rel="external"><code>sorted</code></a></li><li></li></ul><p>任务 1</p><p>获取所有 jeeps 的型号名称，返回相应字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def get_all_jeeps(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a comma  + space (&apos;, &apos;) separated string of jeep models</div><div class="line">       (original order)&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>思路：</p><p><code>join()</code>将序列中的元素以指定字符串连接生成新的字符串,输出：’, ‘（逗号+空格）分割的 Jeep models（吉普车型号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.join(sequence)</div></pre></td></tr></table></figure><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def get_all_jeeps(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a comma  + space (&apos;, &apos;) separated string of jeep models</div><div class="line">       (original order)&quot;&quot;&quot;</div><div class="line">    </div><div class="line">    # print(&apos;, &apos;.join(cars[&apos;Jeep&apos;]))</div><div class="line"></div><div class="line">    return &apos;, &apos;.join(cars[&apos;Jeep&apos;])</div><div class="line"></div><div class="line">get_all_jeeps()</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Grand Cherokee, Cherokee, Trailhawk, Trackhawk</div></pre></td></tr></table></figure><p>任务 2</p><p>获取所有制造商的第一个车型名称,返回相应列表 list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def get_first_model_each_manufacturer(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a list of matching models (original ordering)&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    grep_list = []</div><div class="line"></div><div class="line">    for models in cars.values():</div><div class="line">        for model in models:</div><div class="line">            if grep.casefold() in model.casefold():</div><div class="line">                grep_list.append(model)</div><div class="line">    return sorted(grep_list)</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;Falcon&apos;, &apos;Commodore&apos;, &apos;Maxima&apos;, &apos;Civic&apos;, &apos;Grand Cherokee&apos;]</div></pre></td></tr></table></figure><p>任务 3</p><p>获取所有包含某段字符串（本例是<code>trail</code>）的型号名称，按照阿拉伯字母顺序排序，返回相应列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建一个空的列表</li><li>使用<code>in</code>运算符,历遍所有字典中的values(注：case-insensitive,意思是大小写不敏感，所以用<a href="https://stackoverflow.com/questions/319426/how-do-i-do-a-case-insensitive-string-comparison" target="_blank" rel="external"><code>casefold()</code></a>转换),判断其对应的字符串中，是否包含grep所对应的’trail’字符串</li><li>如果包含’trail’添加入空列表之中，最后，按照阿拉伯字母排序(注：sorted(list),如果列表元素是数字，那么默认是按照增序排序。如果列表元素是字符串，则按照字母顺序（alphabetical order）排序）。</li></ol><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    grep_list = []</div><div class="line"></div><div class="line">    for models in cars.values():</div><div class="line">        for model in models:</div><div class="line">            if grep.casefold() in model.casefold():</div><div class="line">                grep_list.append(model)</div><div class="line">    return sorted(grep_list)</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&apos;Trailblazer&apos;, &apos;Trailhawk&apos;]</div><div class="line">[&apos;Accord&apos;, &apos;Commodore&apos;, &apos;Falcon&apos;]</div></pre></td></tr></table></figure><p>任务 4</p><p>获取型号名称，按照阿拉伯字母顺序排序，返回相应字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line"> pass</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建一个空的字典</li><li>历遍<code>cars</code>字典，获取它的所有键值</li><li>按照所有键值，添加入新字典，并使用<code>sorted</code>方法来重新按字母排序 value 里的元素。</li></ol><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def sort_car_models(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a copy of the cars dict with the car models (values)</div><div class="line">       sorted alphabetically&quot;&quot;&quot;</div><div class="line">    cars_sorted = &#123;&#125;</div><div class="line"></div><div class="line">    for key, value  in cars.items():</div><div class="line">        cars_sorted[key] = sorted(value)</div><div class="line"></div><div class="line">    return cars_sorted</div></pre></td></tr></table></figure><p>最后通关成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-fb97cd300fedd548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>小结：</p><ul><li>Debug 时，务必查看<code>test_cars.py</code>,里面详细写明了代码是如何得到验证的，也熟悉了 asert。在任务三时，发现会另外传入一个’CO’，包含大写字母的字符串。这时候，把原来的变量grep“加上<code>casefold</code>便通过测试了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">from cars import (get_all_jeeps, get_first_model_each_manufacturer,</div><div class="line">                  get_all_matching_models, sort_car_models)</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_jeeps():</div><div class="line">    expected = &apos;Grand Cherokee, Cherokee, Trailhawk, Trackhawk&apos;</div><div class="line">    actual = get_all_jeeps()</div><div class="line">    assert type(actual) == str</div><div class="line">    assert actual == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_first_model_each_manufacturer():</div><div class="line">    actual = get_first_model_each_manufacturer()</div><div class="line">    expected = [&apos;Falcon&apos;, &apos;Commodore&apos;, &apos;Maxima&apos;, &apos;Civic&apos;, &apos;Grand Cherokee&apos;]</div><div class="line">    assert actual == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_matching_models_default_grep():</div><div class="line">    expected = [&apos;Trailblazer&apos;, &apos;Trailhawk&apos;]</div><div class="line">    # sorting requirement might be missed and is not essential for this method</div><div class="line">    assert sorted(get_all_matching_models()) == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_matching_models_different_grep():</div><div class="line">    expected = [&apos;Accord&apos;, &apos;Commodore&apos;, &apos;Falcon&apos;]</div><div class="line">    # sorting requirement might be missed and is not essential for this method</div><div class="line">    assert sorted(get_all_matching_models(grep=&apos;CO&apos;)) == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_sort_dict_alphabetically():</div><div class="line">    actual = sort_car_models()</div><div class="line">    # Order of keys should not matter, two dicts are equal if they have the</div><div class="line">    # same keys and the same values.</div><div class="line">    # The car models (values) need to be sorted here though</div><div class="line">    expected = &#123;</div><div class="line">        &apos;Ford&apos;: [&apos;Fairlane&apos;, &apos;Falcon&apos;, &apos;Festiva&apos;, &apos;Focus&apos;],</div><div class="line">        &apos;Holden&apos;: [&apos;Barina&apos;, &apos;Captiva&apos;, &apos;Commodore&apos;, &apos;Trailblazer&apos;],</div><div class="line">        &apos;Honda&apos;: [&apos;Accord&apos;, &apos;Civic&apos;, &apos;Jazz&apos;, &apos;Odyssey&apos;],</div><div class="line">        &apos;Jeep&apos;: [&apos;Cherokee&apos;, &apos;Grand Cherokee&apos;, &apos;Trackhawk&apos;, &apos;Trailhawk&apos;],</div><div class="line">        &apos;Nissan&apos;: [&apos;350Z&apos;, &apos;Maxima&apos;, &apos;Navara&apos;, &apos;Pulsar&apos;],</div><div class="line">    &#125;</div><div class="line">    assert actual == expected</div></pre></td></tr></table></figure><h4 id="Bite-26-字典推导式-gt-酷炫-Dictionary-comprehensions-are-awesome"><a href="#Bite-26-字典推导式-gt-酷炫-Dictionary-comprehensions-are-awesome" class="headerlink" title="Bite 26 字典推导式 -&gt; 酷炫(Dictionary comprehensions are awesome)"></a>Bite 26 字典推导式 -&gt; 酷炫(Dictionary comprehensions are awesome)</h4><blockquote><p>字典推导式与列表推导式相似，只是构建的是字典，而不是列表。它是方便快速地操作键和值的方法。通常只有一行代码，或者在检查 PEP8 规范之后是两行代码。<br>知识点：<br>输入：原始字典，排除的键值<br>计算：复制字典，匹配排除的键值，并从字典从删除<br>输出：排除对应键之后的字典</p></blockquote><ul><li><code>collection</code> 的 <code>nametuple</code></li><li>列表推导式</li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">bites = &#123;6: &apos;PyBites Die Hard&apos;,</div><div class="line">         7: &apos;Parsing dates from logs&apos;,</div><div class="line">         9: &apos;Palindromes&apos;,</div><div class="line">         10: &apos;Practice exceptions&apos;,</div><div class="line">         11: &apos;Enrich a class with dunder methods&apos;,</div><div class="line">         12: &apos;Write a user validation function&apos;,</div><div class="line">         13: &apos;Convert dict in namedtuple/json&apos;,</div><div class="line">         14: &apos;Generate a table of n sequences&apos;,</div><div class="line">         15: &apos;Enumerate 2 sequences&apos;,</div><div class="line">         16: &apos;Special PyBites date generator&apos;,</div><div class="line">         17: &apos;Form teams from a group of friends&apos;,</div><div class="line">         18: &apos;Find the most common word&apos;,</div><div class="line">         19: &apos;Write a simple property&apos;,</div><div class="line">         20: &apos;Write a context manager&apos;,</div><div class="line">         21: &apos;Query a nested data structure&apos;&#125;</div><div class="line">exclude_bites = &#123;6, 10, 16, 18, 21&#125;</div><div class="line"></div><div class="line"></div><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    return &#123;  k:v    for k,v in  bites.items() if k not in bites_done  &#125;</div></pre></td></tr></table></figure><p>查看了例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># dict comprehension example to reverse key:value pair in a dictionary</div><div class="line">&gt;f_dict = &#123;f:i for i,f in enumerate(fruits)&#125;</div><div class="line">&gt;f_dict</div><div class="line">&#123;&apos;apple&apos;: 0, &apos;banana&apos;: 2, &apos;cherry&apos;: 3, &apos;mango&apos;: 1&#125;</div><div class="line"># dict comprehension to reverse key:value pair in a dictionary</div><div class="line">&gt;&#123;v:k for k,v in f_dict.items()&#125;</div><div class="line">&#123;0: &apos;apple&apos;, 1: &apos;mango&apos;, 2: &apos;banana&apos;, 3: &apos;cherry&apos;&#125;</div></pre></td></tr></table></figure><p>思路：若 k 不在给定的 set 里，便添加入新的字典之后。第一次拼写少了<code>in</code>，之后通关。<img src="https://upload-images.jianshu.io/upload_images/452087-4ba80f57adc238c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    return &#123;  k:v    for k,v in  bites.items() if k not in bites_done  &#125; </div><div class="line">    </div><div class="line">a = filter_bites(bites=bites, bites_done=exclude_bites)</div><div class="line">print(a)</div></pre></td></tr></table></figure><h1 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h1><blockquote><p>改成每题一小篇，以固定标题的形式，组织成专栏，写给六个月前的自己，帮助 0 基础，甚至是负基础的小白入门同学朋友。</p><p>重新调整笔记结构，让别人更易读，而不是偏私人的呢喃。</p></blockquote><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.03.02 init pybite108</p><p>2019.03.05 update pybite109</p><p>2019.03.08 update pybite110</p><p>2019.03.12 update pybite8</p><p>2019.03.16 update pybite15</p><p>2019.03.19 update pybite16</p><p>2019.03.20 update pybite19</p><p>2019.03.22 update pybite21</p><p>2019.03.23 update pybite26</p><p>2019.03.24 update pybite1</p><p>2019.03.27 update pybite5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python新手练习-PyBite&quot;&gt;&lt;a href=&quot;#Python新手练习-PyBite&quot; class=&quot;headerlink&quot; title=&quot;Python新手练习-PyBite&quot;&gt;&lt;/a&gt;Python新手练习-PyBite&lt;/h2&gt;&lt;h4 id=&quot;Bite-
      
    
    </summary>
    
    
      <category term="技术" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>人生是选择的总和——读《畅销的原理》</title>
    <link href="https://adi0229.github.io/2019/01/17/2019-01-17-thebusinessofchoice/"/>
    <id>https://adi0229.github.io/2019/01/17/2019-01-17-thebusinessofchoice/</id>
    <published>2019-01-17T08:54:57.000Z</published>
    <updated>2019-07-23T04:41:30.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人生的选择"><a href="#人生的选择" class="headerlink" title="人生的选择"></a>人生的选择</h1><p><img src="https://upload-images.jianshu.io/upload_images/452087-b0ed819b9b5b1643.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在电影《罪与罚》结尾，艾迪-伍伦让剧中人物莱维教授说出了一句话：</p><blockquote><p>人生，事实上是选择的总和。——路易斯-莱维教授</p></blockquote><p>《畅销的原理》作者马修-威尔科克斯觉得，这句话“听上去似乎有点轻蔑，却是显而易见的事实。”</p><p>如果说，人生每一次选择，都是在面对分叉的道路，选择向左还是向右，那么，马修-威尔科克斯从30年前选择的广告公司入口，选择20年后在旧金山的商务策划，进而选择了与《选择的悖论》作者巴里-施瓦茨接触，最后，选择了写出《畅销的原理：为什么好观念、好产品会一炮而红？》。</p><h1 id="我们是消费者，还是选择者？"><a href="#我们是消费者，还是选择者？" class="headerlink" title="我们是消费者，还是选择者？"></a>我们是消费者，还是选择者？</h1><p>曾经，笔者一看到「营销」一词，想到西装革履的“直销”销售员在讲台上口吐横沫，把一个劣质无用的产品吹得天花乱坠，便会心生反感。后来，翻过大学教科书《市场营销》等书，脑海里的「营销」是销售人员巧舌如簧地安利商品，是公交站旁的贴着明星笑脸的广告牌。简而言之，营销是商业方面的市场推广和品牌管理等活动。在过去，这是我的营销常识。</p><p>对于「营销」是什么，马修-威尔科克斯给出反常识解读：<strong>营销是影响人们选择的过程。</strong></p><p>本书英文标题为《The Business of Choice:Marketing to Consumer’s Instincts》,顾名思义，书中强调的「营销思维」，指的是在商业领域中，<br>选择者面对汽车、保险、球鞋或者移动软件，他们特定的选择或许不同，但演化600万年而来的人类，他们都有着类似的大脑，都是用着类似的决策选择系统来思考。（消费者作者建议少用“消费者”一次，而是推荐“选择者”一词。）</p><p>原因如下：</p><ul><li>了解更宏大的背景，对于如何理解人们如何做出决策至关重要</li></ul><p>从行为科学的角度，他引述《影响力》作者西奥迪尼的观点：</p><blockquote><p>市场调研行业存在一个巨大的缺口，营销人员要更多地关注人类做出决策的一般规律，而不是只关心特定产品市场中对决策过程的理解。</p></blockquote><p>书中有一个例子，解释了为什么了解更宏大的背景，对于如何理解人们如何做出决策至关重要——对于「尾骨疼痛」这一疾病，普通医生只能从尾骨的医学性质来理解，但想不到从进化史来理解尾骨（人类和其他无尾灵长动物尾巴退化的遗迹），因此，无法理解整个环境、整个身体与尾骨的关系。</p><ul><li>选择耗费了人们生活中大量的时间</li></ul><p>2010年《经济学人》的一篇文章《你选择》显示:</p><blockquote><p>“根据食品市场营销协会的数据，如今美国普通超市就有超过 48,750 种商品，这一数字是 1975 年的五倍多。英国乐购超市出售 91 种不同的洗发水，93 个品种的牙膏，家用清洁剂品种的数量则达到 115。”</p></blockquote><ul><li>营销越来越复杂</li></ul><p>因为，在大数据时代，营销越来越复杂，数据海洋一波未平一波又起，冲刷到企业写字楼里。在2014年的大数据广告研究基金会上，作者即兴发言:</p><blockquote><p>“数据分析一半徒劳无功，但我不知道是哪一半。”</p></blockquote><p>这句话，对应了广告界的老谚语“广告奏效了一半，但我不知道是哪一半。”</p><p>下面摘录书中几个关于消费者选择的反常识案例：</p><h2 id="人们选择奢侈品的原因是什么？"><a href="#人们选择奢侈品的原因是什么？" class="headerlink" title="人们选择奢侈品的原因是什么？"></a>人们选择奢侈品的原因是什么？</h2><p>印象里，消费者总是容易这么想——那些陈列的装潢富丽堂皇的店铺里的奢侈品，比如爱马仕、迪奥和路易威登包包，人们购买他们，是因为他们做工精致，用料考究，设计奢华等等。”其实，根据书中所给的例子，在《Spent:Sex, Evolution, and Consumer Behavior》一书中，进化心理学家杰弗里-米勒写道（Geoffrey Miller）写道：“所有广告都有两种观众：潜在的产品买家和潜在的产品看客。产品看客会将各种想要的性状与产品联系起来。产品越昂贵、越独特，看客越多，买家越少。”他认为，奢侈品是性选择的标记。我们珍视美丽稀有的事物，代表想要别人珍视我们，这依赖于别人熟悉这些“标记”。所以，人们买奢侈品包包，不只是因为包包奢华无比，而是因为左邻右舍或者同事领导能认出来，“哇哦，你拿的是爱马仕的包哦。”</p><h2 id="为什么人们有时候选择随波逐流，有时候选择特立独行"><a href="#为什么人们有时候选择随波逐流，有时候选择特立独行" class="headerlink" title="为什么人们有时候选择随波逐流，有时候选择特立独行?"></a>为什么人们有时候选择随波逐流，有时候选择特立独行?</h2><p>在书中，作者引述《影响力》作者西奥迪尼讲了弗拉达的一个实验：观看赌城拉斯维加斯的旅游广告，一版强调流行，每年数百万人来。一版强调独特，去的人更加别出心裁。在观看广告之前，实验对象先看了库布里克心理惊悚片《闪灵》(The Shining)和浪漫爱情片《爱在黎明破晓前》（Before Sunrise）。观看过被试《闪灵》的，更喜欢强调流行的一版广告。观看过《爱在破晓黎明前》的被试更喜欢别出心裁的一版广告。这说明，人们有时从众，有时自我。电影能够激发观众的进化心理，如果观看了恐怖片，更偏向于引发自卫本能，此时观众更容易有从众心理。如果观看的是浪漫爱情片，会激发了求偶的本能，这时候，观众的心理更希望寻求独一无二的感觉。</p><h1 id="作者：马修·威尔科克斯"><a href="#作者：马修·威尔科克斯" class="headerlink" title="作者：马修·威尔科克斯"></a>作者：马修·威尔科克斯</h1><p><img src="https://upload-images.jianshu.io/upload_images/452087-5428f1d3b02fbf63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Matthew Willcox"></p><blockquote><p>马修·威尔科克斯（Matthew Willcox），博达大桥广告公司（FCB）决策制定研究所的创立者和执行常委。博达大桥广告公司（FCB）是世界最早的广告公司之一，也是全球最早上市的广告公司之一，决策制定研究所是其中一个非常独特的机构，它把研究人类行为和人们如何做 选择的科学新发现拓展应用于市场营销实践中。马修在品牌战略领域已经有25年的从业经历，足迹遍布欧洲、亚洲和北美洲。他服务过李维斯、美国艺电、希尔顿酒店集团、联合利华、雀巢、壳牌和葛兰素史克等大企业。在马修的帮助下，这些企业的产品比以往更受消费者的喜爱。在这个过程中，他还为客户们赢得了8座艾菲奖（Effie）。马修还是美国食品和药品管理局的行为变化事务专家，经常在各大商学院和营销交流大会上做演讲。</p></blockquote><p>人容易对有着相同爱好的人有好感，作者威尔科克斯跟我一样，都是足球迷。他是爱尔兰人，在书中提到了他观看爱尔兰队对阵法国队的世界杯预选赛里亨利手球获利进球，而引发他呼吁各个足协协会让球员在赛前签字承诺，以借助“助推”影响球员公平竞赛行为。</p><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>针对书中的营销建议，我列出了对应的术语概念：</p><ul><li>靠直觉还是靠分析？过滤信息才能高效决策。<br>「启发法」——选择者们常用直觉，而不是理性分析来做决策。</li><li>被人熟知还是保持距离？<br>「熟悉的扭曲」悖论——要持续吸引选择者，不仅需要维持熟悉度，更要有新奇与惊喜。</li><li>“曾经拥有的”带来损失的更大<br>「损失厌恶」——就像陈奕迅 Eson 唱的那样：“你的背包，背到现在还没烂，却成为我身体另一半。千金不换，它已熟悉我的汗。”</li><li>“给人们带去聪明、好看和幸运的感觉”<br>「自我效能」—— 让人们感觉到胜任感，他们会更乐意去做某事。</li></ul><h1 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h1><p>2019/01/16 初稿 2.5h</p><p>2019/04/02 删除封面图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人生的选择&quot;&gt;&lt;a href=&quot;#人生的选择&quot; class=&quot;headerlink&quot; title=&quot;人生的选择&quot;&gt;&lt;/a&gt;人生的选择&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4
      
    
    </summary>
    
    
      <category term="运营" scheme="https://adi0229.github.io/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>队服撞衫？如何让AI区分相似球衣？</title>
    <link href="https://adi0229.github.io/2019/01/04/2019-01-04-aisimilarshirt/"/>
    <id>https://adi0229.github.io/2019/01/04/2019-01-04-aisimilarshirt/</id>
    <published>2019-01-04T04:44:23.000Z</published>
    <updated>2019-04-06T13:49:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>#问题</p><p>笔者最近在学人工智能领域的深度学习技术，在 fast.ai的课程里，我学会了：复用简洁的示例代码来训练卷积神经网络CNN。它能够精准地让机器对图片进行分类。（课程里的例子是识别猫狗图片的二元分类任务，在2000张测试图片中，它的识别准确率达到了99%。）</p><p>我认为，真正的学习，是带着好奇心，自己来解决实际问题，探究输入-输出之间的关系，从而构建自己的知识体系。</p><p><strong>因为自己是多年的足球迷，从兴趣出发，我“凿开”了一个脑洞：能否训练一个卷积神经网络训练，识别区分两件相似足球队衣图片？</strong></p><p>于是，我搜索到了公众号点妹侃球的一篇帖子 <a href="https://kuaibao.qq.com/s/20180511G1NJ6N00?refer=spider" target="_blank" rel="external">《撞衫不可怕，谁丑谁尴尬！这些球衣相似度竟高达99％》</a>，看看都有哪些足球队的队服比较相似。</p><p>其中，我发现，大名鼎鼎的巴塞罗那队服是红蓝箭条衫，而瑞士巴赛尔队的队服也是红蓝箭条衫，两队的主场战袍相似度很高。因此，我打算用 fast.ai的模块来以及预训练的 CNN 卷积神经网络（比如，resnet34）来进行迁移学习，看看我们的 AI 图片分类器，能否较好地识别两个队的队服。</p><p>下面是两队的队服示例:</p><p><img src="http://inews.gtimg.com/newsapp_match/0/3549393347/0" alt="巴塞罗那队服"></p><p><img src="http://inews.gtimg.com/newsapp_match/0/3549393346/0" alt="巴塞尔队服"></p><p>任务定义：区分图片是「巴塞罗那队队服」还是「巴赛尔队队服」？</p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><ul><li>通过开源的 Python 脚本 <a href="https://github.com/hardikvasa/google-images-download" target="_blank" rel="external">google-images-download</a>，根据关键词来批量谷歌图片里的图像。每队批量下载了140张图片，训练集每队约83张图片，验证集每队约60张图片。</li></ul><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><p>定义数据路径及图片大小（324*324）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PATH = &quot;./data/basel_or_barcelona/&quot;</div><div class="line">sz=324</div></pre></td></tr></table></figure></p><p>设置预训练模型为resnet34，然后生成模型，学习率设为0.01，并训练10次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">arch=resnet34</div><div class="line">data = ImageClassifierData.from_paths(PATH, tfms=tfms_from_model(arch, sz)) </div><div class="line">learn = ConvLearner.pretrained(arch, data, precompute=True) </div><div class="line">learn.fit(0.01, 10)</div><div class="line"></div><div class="line">100% 10/10 [00:01&lt;00:00, 5.81it/s]</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.773914   0.711084   0.586777  </div><div class="line">    1      0.694298   0.670647   0.644628                </div><div class="line">    2      0.597124   0.62849    0.710744                </div><div class="line">    3      0.505373   0.600698   0.735537                </div><div class="line">    4      0.450973   0.583853   0.760331        </div><div class="line">    5      0.42152    0.595698   0.768595        </div><div class="line">    6      0.373794   0.610405   0.785124        </div><div class="line">    7      0.33496    0.624578   0.77686                 </div><div class="line">    8      0.304601   0.634755   0.77686         </div><div class="line">    9      0.277069   0.641988   0.77686</div></pre></td></tr></table></figure></p><p>采用预训练的模型，120多张的测试数据，准确率达到了77.6%，还不错。这是最简单的办法，fast.ai课程还讲授了其他的提示准确率的办法，对于这个小型的足球图片数据集，我来实验一下，看看准确率能否有明显提升。</p><h3 id="寻找最佳学习率"><a href="#寻找最佳学习率" class="headerlink" title="寻找最佳学习率"></a>寻找最佳学习率</h3><p><img src="https://upload-images.jianshu.io/upload_images/452087-1e9de08bc7ee725b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用了一个寻找最佳学习率的函数，但是数据图里是空的，没有曲线，暂时无解，先跳过，我决定沿用0.01的学习率。</p><h3 id="数据扩充（Data-Argumentation）"><a href="#数据扩充（Data-Argumentation）" class="headerlink" title="数据扩充（Data Argumentation）"></a>数据扩充（Data Argumentation）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tfms = tfms_from_model(resnet34, sz, aug_tfms=transforms_side_on, max_zoom=1.5)</div></pre></td></tr></table></figure><p>随机对图片进行水平旋转，并放大1.5倍</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-2aba8a9bc2b3af4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = ImageClassifierData.from_paths(PATH, tfms=tfms)</div><div class="line">learn = ConvLearner.pretrained(arch, data, precompute=True)</div><div class="line">learn.fit(1e-2, 1)</div></pre></td></tr></table></figure><p>用了 数据扩充（Data Argumentation） 之后，第一次训练，准确率较低，只有52.8%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">learn.precompute=False</div><div class="line">learn.fit(1e-2, 3, cycle_len=1)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.711067   0.799083   0.561983  </div><div class="line">    1      0.673241   0.670506   0.652893                </div><div class="line">    2      0.632643   0.606632   0.644628</div></pre></td></tr></table></figure><h1 id="解冻-微调"><a href="#解冻-微调" class="headerlink" title="解冻-微调"></a>解冻-微调</h1><p>之前训练的是最后一层，通过 Unfreeze函数,“解冻”所有神经层，进一步做 Fine-Tuning 参数微调，并且，不同深浅的神经层，采用不同的学习率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">learn.unfreeze()</div><div class="line">lr=np.array([1e-4,1e-3,1e-2])</div><div class="line">learn.fit(lr, 3, cycle_len=1, cycle_mult=2)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.577406   0.585321   0.652893  </div><div class="line">    1      0.574191   0.495774   0.727273                </div><div class="line">    2      0.505914   0.456579   0.752066                 </div><div class="line">    3      0.456115   0.393354   0.801653                </div><div class="line">    4      0.408209   0.363914   0.818182                </div><div class="line">    5      0.370777   0.353467   0.834711                </div><div class="line">    6      0.342305   0.350941   0.842975 </div><div class="line"></div><div class="line">learn.fit(lr, 6, cycle_len=1, cycle_mult=2)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.224649   0.351165   0.842975  </div><div class="line">    1      0.201187   0.343334   0.867769                </div><div class="line">    2      0.192907   0.339028   0.867769                </div><div class="line">    3      0.187865   0.32258    0.867769                </div><div class="line">    4      0.167363   0.309566   0.867769                </div><div class="line">    5      0.165586   0.302056   0.859504                </div><div class="line">    6      0.162697   0.303541   0.859504                </div><div class="line">    7      0.160678   0.301258   0.867769                </div><div class="line">    8      0.150494   0.315228   0.876033                </div><div class="line">    9      0.149012   0.333124   0.876033                </div><div class="line">    10     0.140085   0.341198   0.884298                </div><div class="line">    11     0.133135   0.343363   0.884298                </div><div class="line">    12     0.125423   0.339807   0.884298                </div><div class="line">    13     0.1168     0.33534    0.884298                </div><div class="line">    14     0.109273   0.33899    0.884298                </div><div class="line">    15     0.10801    0.32313    0.884298                </div><div class="line">    16     0.101856   0.313022   0.892562                </div><div class="line">    17     0.099126   0.29976    0.884298                 </div><div class="line">    18     0.094342   0.293067   0.884298                 </div><div class="line">    19     0.090559   0.291236   0.884298                 </div><div class="line">    20     0.089409   0.294657   0.884298                 </div><div class="line">    21     0.085061   0.292772   0.884298                 </div><div class="line">    22     0.080943   0.294916   0.884298                 </div><div class="line">    23     0.077687   0.289591   0.884298                 </div><div class="line">    24     0.073291   0.290864   0.884298                  </div><div class="line">    25     0.070136   0.289896   0.884298                  </div><div class="line">    26     0.071041   0.291556   0.876033                 </div><div class="line">    27     0.067812   0.287182   0.884298                  </div><div class="line">    28     0.06408    0.287058   0.884298                 </div><div class="line">    29     0.062913   0.288546   0.884298                  </div><div class="line">    30     0.060431   0.286025   0.884298                 </div><div class="line">    31     0.060556   0.284598   0.884298                 </div><div class="line">    32     0.058281   0.290405   0.884298                 </div><div class="line">    33     0.056919   0.295286   0.892562                  </div><div class="line">    34     0.054588   0.29396    0.900826                 </div><div class="line">    35     0.052521   0.292013   0.892562                 </div><div class="line">    36     0.051742   0.281408   0.892562                  </div><div class="line">    37     0.050915   0.274899   0.892562                  </div><div class="line">    38     0.048206   0.265904   0.892562                 </div><div class="line">    39     0.048089   0.2706     0.892562                 </div><div class="line">    40     0.045976   0.286523   0.892562                 </div><div class="line">    41     0.046062   0.297521   0.892562                  </div><div class="line">    42     0.043593   0.297748   0.900826                 </div><div class="line">    43     0.041344   0.293669   0.900826                 </div><div class="line">    44     0.040934   0.297795   0.900826                 </div><div class="line">    45     0.039792   0.300095   0.900826                 </div><div class="line">    46     0.038014   0.300615   0.900826                 </div><div class="line">    47     0.037288   0.298393   0.892562                 </div><div class="line">    48     0.037229   0.294151   0.900826                 </div><div class="line">    49     0.035728   0.290464   0.884298                 </div><div class="line">    50     0.034198   0.286805   0.884298                 </div><div class="line">    51     0.033855   0.286428   0.876033                 </div><div class="line">    52     0.032238   0.282124   0.884298                 </div><div class="line">    53     0.031438   0.276031   0.892562                 </div><div class="line">    54     0.031037   0.282506   0.876033                 </div><div class="line">    55     0.02959    0.285489   0.884298                 </div><div class="line">    56     0.028276   0.282334   0.892562                 </div><div class="line">    57     0.027054   0.278635   0.892562                 </div><div class="line">    58     0.025802   0.281353   0.892562                 </div><div class="line">    59     0.024861   0.282644   0.892562                 </div><div class="line">    60     0.023592   0.281519   0.892562                 </div><div class="line">    61     0.023124   0.283864   0.884298                 </div><div class="line">    62     0.022198   0.284992   0.892562</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">log_preds,y = learn.TTA()</div><div class="line">probs = np.mean(np.exp(log_preds),0)</div><div class="line">accuracy_np(probs, y)</div><div class="line">0.8925619834710744</div></pre></td></tr></table></figure><p>采用了 TTA（测试集也使用 Data Argumentation） 之后，最后的准确率达到了89.2%。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h3 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h3><p>画出一个混淆矩阵——查看不同分类，识别错误的图片都有哪些？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-621fc190111f5c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Confusion Matrix"></p><p>看图可知</p><p>巴塞罗那队服：54张正确，6张错误。<br>巴塞尔队服：54张正确，7张错误。</p><p>下面我们看看具体哪些图片识别错了：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d67f75a921cb63bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一行几张图片，判断错误还是有点奇怪的，因为图片本身有着巴塞罗那队的标志，标志人物梅西和队徽。也许是训练集还太小的缘故吧。</p><p>第二行判断错误的巴赛尔队服，第二张是异常图片，呈黑白色。其他三张与训练集里典型的巴赛尔队服还是有点区别的。这样也许解释得过去。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://towardsdatascience.com/fun-with-small-image-data-sets-8c83d95d0159" target="_blank" rel="external">Fun with small image data-sets</a><br><a href="https://medium.com/@apiltamang/case-study-a-world-class-image-classifier-for-dogs-and-cats-err-anything-9cf39ee4690e" target="_blank" rel="external">Case Study: A world class image classifier for dogs and cats</a><br><a href="https://docs.fast.ai/" target="_blank" rel="external">fastai-doc</a></p><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.01.04 初稿<br>2019.04.05 删除时效图片，发布至博客 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#问题&lt;/p&gt;
&lt;p&gt;笔者最近在学人工智能领域的深度学习技术，在 fast.ai的课程里，我学会了：复用简洁的示例代码来训练卷积神经网络CNN。它能够精准地让机器对图片进行分类。（课程里的例子是识别猫狗图片的二元分类任务，在2000张测试图片中，它的识别准确率达到了99%。
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念之树状笔记</title>
    <link href="https://adi0229.github.io/2018/04/11/2018-04-11-workflowy/"/>
    <id>https://adi0229.github.io/2018/04/11/2018-04-11-workflowy/</id>
    <published>2018-04-10T16:54:57.000Z</published>
    <updated>2019-04-02T11:35:03.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Workflowy-VS-幕布"><a href="#Workflowy-VS-幕布" class="headerlink" title="Workflowy VS 幕布"></a>Workflowy VS 幕布</h1><p>这一年来，有幸接触开智学堂，参与开智的认知写作学课程，信息密度超大，受益良多，尤其是其中强调的“卡片大法”和“树形结构”，我一直念念不忘。</p><p>其中，阳老曾在博文中提到：</p><blockquote><p>我提过多次的 MIT 认知科学家 Joshua B. Tenenbaum 发表在 PNAS 的论文（ The discovery of structural form ）中，比较了抽象知识的不同表征结构……最终还是意识到，人类的最佳知识结构是树形结构。只有树形结构，才是最符合人类认知特点的一种结构，从树的上一层到下一层，是具备唯一通道，便于大脑将知识从记忆底层快速提取出来，符合人类大脑是个认知吝啬鬼的特点；树又是兼具横向扩展与纵向扩展能力的最优雅的结构。——<a href="http://www.yangzhiping.com/tech/zotero2.html" target="_blank" rel="external">Zotero（2）：作为知识管理工具的Zotero - 阳志平的网志</a></p></blockquote><p>过去用印象笔记，笔记越用越臃肿，认知超载，继而行动瘫痪。换工具，势在必行。</p><p>一周前，开始接触一款轻量级的笔记软件——Workflowy，一番试用过后，喜出望外，漫存笔记喜欲狂。电闪雷鸣，350条免费空间已然塞满。它正好满足了我想要践行“卡片大法”和“树形结构”的工具需求。</p><p>曾因 Workflowy 不能添加图片而纠结，国产版的同类产品幕布支持在笔记中添加图片，还能将笔记导出思维导图，又是一番产品试用，结果不遂人意。原因无他，幕布的多文档，或者说多画布模式，不符合打开即用的原则。每次打开幕布，需要在三个文档中选择，点击进去，再做笔记。经过这一步，我早已没有了输出欲望。</p><p>对此，我有一则 Workflowy 笔记在次为证：</p><blockquote><p>启动后的第一屏，幕布是多文档对应多个树状笔记。而Workflowy一个白板，清清爽爽，一进去就有敲敲打打码字的冲动。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Workflowy-VS-幕布&quot;&gt;&lt;a href=&quot;#Workflowy-VS-幕布&quot; class=&quot;headerlink&quot; title=&quot;Workflowy VS 幕布&quot;&gt;&lt;/a&gt;Workflowy VS 幕布&lt;/h1&gt;&lt;p&gt;这一年来，有幸接触开智学堂，参与开智
      
    
    </summary>
    
    
      <category term="data" scheme="https://adi0229.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>拉新促活，了解一下？读《增长黑客》</title>
    <link href="https://adi0229.github.io/2017/09/04/2017-09-07-growthhacker/"/>
    <id>https://adi0229.github.io/2017/09/04/2017-09-07-growthhacker/</id>
    <published>2017-09-04T13:24:57.000Z</published>
    <updated>2018-04-07T17:54:25.353Z</updated>
    
    <content type="html"><![CDATA[<p>花了两个下午的时间，看完了同龄人范冰写的《增长黑客》，作者出书时，年纪轻轻，已是成绩斐然，他曾任职盛大创新院，担任「WiFi 万能钥匙」产品经理。</p><p>读完之后，对AARRR漏斗印象较深，书中有关增长黑客的工作，都是围绕着AARRR漏斗来开展的。</p><h2 id="何为增长黑客"><a href="#何为增长黑客" class="headerlink" title="何为增长黑客"></a>何为增长黑客</h2><p>与预想的不同，本书并不为难普通读者，并没有涉及繁杂的数据分析。整体行文较为友好，有IT科技媒体的风格。</p><p>作者简要地介绍了增长黑客的由来:</p><p>2012年4月，Andrew Chen发表了《Growth Hacker is the new VP Marketing》首次提出了增长黑客的概念。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00005.jpeg" alt=""></p><p>在外行眼里，他们就像是极客、发明家和广告狂人的混合体。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00006.jpeg" alt=""></p><p>这里的黑客，并不是一般常识所认为的，是入侵计算机系统，谋取不当利益的危险分子。黑客的含义，更多的是指不走寻常路的科技发烧友。</p><h2 id="AARRR漏斗"><a href="#AARRR漏斗" class="headerlink" title="AARRR漏斗"></a>AARRR漏斗</h2><p>产品增长是Growth Hacker的核心任务，根据不同阶段用户参与产品的行为，拆分成了 AARRR 转化漏斗，即Acquisition（获取用户）、Activation（激发活跃）、Retention（留存）、Revenue（收入）、Referral（口碑推荐传播）。对应着五个模块，书中列举了很多案例，不少提及的产品，当下活得并不好，比如作者参与过的“约TA”等。这说明了，一两个招式并不是整个产品生死的关键，只有产品符合PMF（Product&amp;Market Fit）的前提下，才适合谈增长。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00007.jpeg" alt=""></p><h2 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h2><p>精细化地数据分析，根据数据来驱动增长，A/B测试是增长黑客的一大利器。书里提到了几个有意思的案例，体现了A/B测试得出的反常识结果</p><p>案例一：HubSpot注册表单页</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00113.jpeg" alt=""></p><p>营销公司HubSpot，在注册表单上增加了一位女性微笑的照片，以试图丰富页面和增加亲和度。但测试效果不符合效果，转化率降低了24％</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00114.jpeg" alt=""></p><p>案例二：奥巴马的竞选网站“Change”</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00115.jpeg" alt=""></p><p>原先，”Change”上呈现的选举视频，远不如奥巴马的全家福照片，后者对选举支持率的提升比前者高出40.6％</p><p>当然了，书里的阐述还是浅显，只是一笔带过。但是A/B测试通过对照试验，用数据验证假设，也是符合心理学的实验精神的，能减少主观偏见的影响。</p><h2 id="Talk-is-cheap，show-me-the-code"><a href="#Talk-is-cheap，show-me-the-code" class="headerlink" title="Talk is cheap，show me the code"></a>Talk is cheap，show me the code</h2><p>书中所讲的案例，涵盖面广，够典型，但阐述也略浅，属于有用之作。</p><p>纸上得来终觉浅，绝知此事要躬行。下一个5年，10年，也许AI会给产品带来变革，那AI时代的产品该如何增长呢？要回答这个问题，绝对不是看看案例，写点总结就能做到的。对我而言，还是要参与实战。</p><p>就像作者，虽然毕业没几年，但实战经验丰富，是一个创造者，比如，他从小学开始用 Dreamweaver 搭建网站，中学时编写共享软件被《大众软件》，大学开发塞班手机上的校园社区等等。</p><h2 id="问号：增长黑客的职业道德"><a href="#问号：增长黑客的职业道德" class="headerlink" title="问号：增长黑客的职业道德"></a>问号：增长黑客的职业道德</h2><p>在后记中，作者谈到了增长黑客需要遵守的职业道德。但在第3章《用数据抓取“借鸡下蛋”》小节里，他曾提及自己参与过交友产品“追TA”，团队在冷启动时，为了在社区中伪造真实用户，爬取了唱吧上用户分享的头像。</p><p>不知道这一举措，是否经过了版权方的允许？又如果版权方允许，书中介绍此法，是鼓励增长黑客们伪造“僵尸用户”？（值得注意的是，此款应用在2015年1月4日之后，在苹果商店中变不再更新，产品并没有火起来。虽然产品停更的主因，不该是由此引起的）</p><p>相反地，在第3章“获取用户”部分，作者提到了一个自相矛盾的“从最笨的事情做起”，比如Airbnb创始团队挨家挨户帮房东拍照，网易云协作团队邀请近百位意见领袖参与内测。</p><p>我更欣赏的是，“笨办法”获取用户。<br>让我们多一些真诚，少一些套路。</p><h2 id="一句金句"><a href="#一句金句" class="headerlink" title="一句金句"></a>一句金句</h2><p>促活，是做产品的重中之重，最后用一句书中引用的日本谚语来结束这篇读书笔记。</p><p>“鸟不鸣，信长杀之；鸟不鸣，秀吉使鸣之；鸟不鸣，家康待鸣之。”</p><p>注：文中图片引用自 gitbook，侵删。</p><h2 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h2><p>2017-09-02 添加行动卡和金句卡 0.5h<br>2017-08-31 初稿 2.5h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了两个下午的时间，看完了同龄人范冰写的《增长黑客》，作者出书时，年纪轻轻，已是成绩斐然，他曾任职盛大创新院，担任「WiFi 万能钥匙」产品经理。&lt;/p&gt;
&lt;p&gt;读完之后，对AARRR漏斗印象较深，书中有关增长黑客的工作，都是围绕着AARRR漏斗来开展的。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="note" scheme="https://adi0229.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>【译】站在20岁的尾巴上</title>
    <link href="https://adi0229.github.io/2017/08/17/2015-07-31-20tail/"/>
    <id>https://adi0229.github.io/2017/08/17/2015-07-31-20tail/</id>
    <published>2017-08-17T04:14:57.000Z</published>
    <updated>2017-08-17T04:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>过去翻译的一个Quora回答，一次自我激励。<br>也是促成成长型心智的一小步。<br>可是，光有大方向可不行。还需要踩油门，而不是只在车上喊口号<br>——20170817</em></p><blockquote><p>Q：“I am in my late 20s and feel I have wasted a lot of time. Is it too late for me to achieve something worthwhile?</p></blockquote><p>现在，我站在在二十多岁的尾巴上，感觉浪费了很多时间。对我来说，去达成一些值得去做的事情，是不是已经太晚了？</p><blockquote><p>Tim MacGougan：</p><p>When I turned 27 I was:<br>Unemployed, had been for a year<br>Sleeping on a friend’s couch<br>Painfully single<br>Wondering if it was too late</p></blockquote><p>在我年满27岁时：</p><p>失业一年</p><p>睡朋友的沙发</p><p>痛苦的单身着</p><p>疑惑着是否一切都太晚了</p><blockquote><p>I had:<br>No hard skills<br>No work experience worth repeating<br>College grades that didn’t open grad school doors I wanted to walk through<br>Scant motivation<br>No direction</p></blockquote><p>我：</p><p>没有硬技能</p><p>没有值得一提的工作经历</p><p>大学成绩未能为我打开想要通过的毕业之门</p><p>缺乏动力</p><p>没有方向</p><blockquote><p>I asked my dad for advice and he said:”You can’t steer a parked car.”</p></blockquote><p>我向父亲寻求建议，他说：“ 你无法开动一辆停住的车”。</p><blockquote><p>I stopped thinking about what to do and started doing.  I refocused my search on small growing companies and after a dozen rejections I applied for a customer service job at a company I’d never heard of but that seemed interesting. A week later I was working atBonobos (company)with 25 smart, fun, engaging people. I chipped in on work in different departments and eventually found an application for my natural skills in a career path I hadn’t anticipated.  At 29 I’m a beginner in a new role.  It’s fantastic.</p></blockquote><p>我停止去想该做什么，开始行动。我重新聚焦于成长中的小型公司，然后，在许多次被拒之后，在一家没听说过但似乎挺有趣的公司，我申请了一份客户服务的工作。一周之后，我就任职于Bonnobos公司，与25位聪明、有趣、热心的伙伴一起工作了。我凑进不同的部门工作，终于，我使自己的天赋应用到了一个我未曾预料到的职业道路里。在29岁时，在新的角色里，我是一名初学者。这很神奇。</p><blockquote><p>I can only recommend what I’ve done:Find some fertile ground.You’ll figure the rest out later. There are tons of young companies looking for people who are energetic and capable, but most importantly they’re looking for people who care.  Startups require hard work and long hours but if you care about the mission and the quality of your work it’ll feel more like a lifestyle than a job.</p></blockquote><p><strong>我只能建议我所做过的：寻找某片肥沃的土壤。</strong></p><p>你自己会弄明白其他的。现在有大量的新兴企业在寻找有激情有能力的人，但最重要的是，他们要找的是真正在乎他们的人。创业公司需要长时间的勤奋工作。如果你在乎工作的使命和品质，那么，这会更像一种生活方式而不只是一份工作。</p><blockquote><p>You only have to be lucky once. I was. Maybe you will be too. There’s only one way to find out: Take the car out of park and step on the gas.</p></blockquote><p>你仅仅需要幸运一回。我曾经如此。也许，你也将如此。</p><p><strong>只有一种方法去寻找：把车开出泊位，踩上油门。</strong></p><p><a href="www.quora.com/I-am-in-my-late-20s-and-feel-I-have-wasted-a-lot-of-time-Is-it-too-late-for-me-to-achieve-something-worthwhile">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;过去翻译的一个Quora回答，一次自我激励。&lt;br&gt;也是促成成长型心智的一小步。&lt;br&gt;可是，光有大方向可不行。还需要踩油门，而不是只在车上喊口号&lt;br&gt;——20170817&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：“I am in my late 2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《国王，武士，祭司，情人》</title>
    <link href="https://adi0229.github.io/2017/08/04/2016-01-16-warrior/"/>
    <id>https://adi0229.github.io/2017/08/04/2016-01-16-warrior/</id>
    <published>2017-08-04T03:24:57.000Z</published>
    <updated>2017-08-04T03:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>旧笔记。做了一个思维导图。文字部分，摘抄为主。<br>若能提炼主题，用精炼文字自行叙述，更好。<br>回头看，四个人物原型的隐喻，鲜明而深刻。有趣的神话隐喻。<br>理论模型虽好，还需践行。</p></blockquote><div style="text-align: center"><br><img src="http://upload-images.jianshu.io/upload_images/452087-dcb80f2303484a55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p><img src="http://ou1rce4mw.bkt.clouddn.com/kwml.png" alt=""></p><p><a href="http://ou1rce4mw.bkt.clouddn.com/kwml.png" target="_blank" rel="external">查看清晰大图</a></p><p><a href="http://www.jianshu.com/p/a98e4e67e39d" target="_blank" rel="external">笔记全文</a></p><p><a href="https://book.douban.com/subject/2893591/" target="_blank" rel="external">King, Warrior, Magician, Lover</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;旧笔记。做了一个思维导图。文字部分，摘抄为主。&lt;br&gt;若能提炼主题，用精炼文字自行叙述，更好。&lt;br&gt;回头看，四个人物原型的隐喻，鲜明而深刻。有趣的神话隐喻。&lt;br&gt;理论模型虽好，还需践行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style
      
    
    </summary>
    
    
      <category term="note" scheme="https://adi0229.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>斯特鲁普效应统计报告</title>
    <link href="https://adi0229.github.io/2017/08/02/2017-08-04-stroop/"/>
    <id>https://adi0229.github.io/2017/08/02/2017-08-04-stroop/</id>
    <published>2017-08-02T07:54:57.000Z</published>
    <updated>2017-08-04T09:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斯特鲁普效应统计报告"><a href="#斯特鲁普效应统计报告" class="headerlink" title="斯特鲁普效应统计报告"></a>斯特鲁普效应统计报告</h1><h2 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息"></a>背景信息</h2><p>在一个 Stroop （斯特鲁普）任务中，参与者得到了一列文字，每个文字都用一种油墨颜色展示。参与者的任务是将文字的打印颜色大声说出来。这项任务有两个条件：一致文字条件，和不一致文字条件。在一致文字条件中，显示的文字是与它们的打印颜色匹配的颜色词，如“红色”、“蓝色”。在不一致文字条件中，显示的文字是与它们的打印颜色不匹配的颜色词，如“紫色”、“橙色”。在每个情况中，我们将计量说出同等大小的列表中的墨色名称的时间。每位参与者必须全部完成并记录每种条件下使用的时间。</p><h2 id="调查问题"><a href="#调查问题" class="headerlink" title="调查问题"></a>调查问题</h2><ol><li>我们的自变量是什么？因变量是什么？</li><li>此任务的适当假设集是什么？你想执行什么类型的统计测试？为你的选择提供正当理由。</li></ol><h3 id="一、-我们的自变量是什么？因变量是什么？"><a href="#一、-我们的自变量是什么？因变量是什么？" class="headerlink" title="一、    我们的自变量是什么？因变量是什么？"></a>一、    我们的自变量是什么？因变量是什么？</h3><p><strong> 自变量：文字列表的显示条件,两组条件</strong></p><ul><li>一致文字条件：颜色词汇与打印颜色匹配</li><li>不一致文字条件：颜色词汇与打印颜色不匹配<br><strong> 因变量：参与者说出颜色词汇的反应时间 </strong></li></ul><h3 id="二、-此任务的适当假设集是什么？你想执行什么类型的统计测试？为你的选择提供正当理由。"><a href="#二、-此任务的适当假设集是什么？你想执行什么类型的统计测试？为你的选择提供正当理由。" class="headerlink" title="二、    此任务的适当假设集是什么？你想执行什么类型的统计测试？为你的选择提供正当理由。"></a>二、    此任务的适当假设集是什么？你想执行什么类型的统计测试？为你的选择提供正当理由。</h3><p>假设集：显示颜色词汇时，若语义和打印颜色不一致，不太一致的打印颜色对参与者识别词汇造成干扰</p><p>零假设：颜色词汇与打印颜色是否一致的条件，对参与者反应时间无影响<br>对立假设：向参与者呈现两组同等大小的词汇组，在面对不一致条件词汇组时，参与者说出文字打印颜色的反应时间比面对一致条件下的反应时间要长</p><ul><li><strong> 零假设 Ho: μ2 - μ1 = 0 </strong></li><li><strong>对立假设 Ha: μ2 - μ1 > 0   </strong><br>注：μ1为一致组总体均值，μ2为不一致组总体均值</li></ul><p><strong>测试类型：相依样本单尾t 检验，正方向</strong></p><p>理由：</p><ul><li>本次测试，由于无法得知总体参数，比较的是两个样本，样本数为24，小于30。</li><li>测试任务中，记录的是同一参与者在两种文字条件下朗读文字颜色的反应时间，属于重复衡量设计的样本内测试。所提供的数据，属于相依样本。</li><li><p>样本符合 t 检验所需的前提条件：</p><pre><code>- 自变量是二元变量（ A，B group）</code></pre><ul><li>因变量的测量单位是时间，是连续分布的（Continuous）</li><li>因变量（反应时间）之间是独立的，互相不受影响</li><li><p>样本差值近似正态分布</p><p>  <img src="http://ou1rce4mw.bkt.clouddn.com/st1.png" alt="st1"></p></li><li><p>参与者是随机选择的</p><h3 id="三、提供显示样本数据分布的一个或两个可视化。用一两句话说明你从图中观察到的结果。"><a href="#三、提供显示样本数据分布的一个或两个可视化。用一两句话说明你从图中观察到的结果。" class="headerlink" title="三、提供显示样本数据分布的一个或两个可视化。用一两句话说明你从图中观察到的结果。"></a>三、提供显示样本数据分布的一个或两个可视化。用一两句话说明你从图中观察到的结果。</h3></li></ul></li></ul><p><img src="http://ou1rce4mw.bkt.clouddn.com/st2.png" alt=""><img src="http://ou1rce4mw.bkt.clouddn.com/st3.png" alt=""></p><p>从直方图可知：<br>一致组的反应时间，9-17秒之间最多。<br>不一致组的反应时间，17-23秒最多。</p><h3 id="四、报告关于此数据集的一些描述性统计。包含至少一个集中趋势测量和至少一个变异测量。"><a href="#四、报告关于此数据集的一些描述性统计。包含至少一个集中趋势测量和至少一个变异测量。" class="headerlink" title="四、报告关于此数据集的一些描述性统计。包含至少一个集中趋势测量和至少一个变异测量。"></a>四、报告关于此数据集的一些描述性统计。包含至少一个集中趋势测量和至少一个变异测量。</h3><ul><li><strong>差异均值为7.96</strong></li><li><strong>差异的标准方差SD=4.86</strong></li></ul><h3 id="五、现在，执行统计测试并报告你的结果。你的置信水平和关键统计值是多少？你是否成功拒绝零假设？对试验任务得出一个结论。结果是否与你的期望一致？"><a href="#五、现在，执行统计测试并报告你的结果。你的置信水平和关键统计值是多少？你是否成功拒绝零假设？对试验任务得出一个结论。结果是否与你的期望一致？" class="headerlink" title="五、现在，执行统计测试并报告你的结果。你的置信水平和关键统计值是多少？你是否成功拒绝零假设？对试验任务得出一个结论。结果是否与你的期望一致？"></a>五、现在，执行统计测试并报告你的结果。你的置信水平和关键统计值是多少？你是否成功拒绝零假设？对试验任务得出一个结论。结果是否与你的期望一致？</h3><ol><li><p><strong>  t 值检验</strong><br> <strong>按照 a= .001 的标准，t 临界值是3.85</strong><br> <strong> t(23)=8.02,p \&lt; .0001,单尾正方向</strong><br> <strong> t 统计量为8.02，超过了 t 临界值。因此，均值差异有着极其显著的统计学意义。</strong><br> <strong> 由此可拒绝零假设。</strong></p></li><li><p><strong> 置信水平 </strong><br><strong> 99.9%CI= (4.50-11.42) </strong>，解释：总体差异的均值，有99.9%的概率在上述数值范围内。</p></li><li><p><strong> r^2= .74</strong> 解释：74%的反应时间差异，是由不一致的打印颜色条件造成的。</p></li></ol><h3 id="六、结论："><a href="#六、结论：" class="headerlink" title=" 六、结论："></a><strong> 六、结论：</strong></h3><p>  <strong>不一致的印刷颜色会对受试者识别颜色词汇造成干扰，延长朗读的反应时长。</strong></p><blockquote><p>参考:<br><a href="https://en.wikipedia.org/wiki/Stroop_effect" target="_blank" rel="external">https://en.wikipedia.org/wiki/Stroop_effect</a><br><a href="https://discussions.youdaxue.com/t/topic/43305" target="_blank" rel="external">https://discussions.youdaxue.com/t/topic/43305</a><br><a href="http://www.csic.cornell.edu/Elrod/t-test/t-test-assumptions.html" target="_blank" rel="external">http://www.csic.cornell.edu/Elrod/t-test/t-test-assumptions.html</a><br><a href="http://www.statisticshowto.com/when-to-use-a-t-score-vs-z-score/" target="_blank" rel="external">http://www.statisticshowto.com/when-to-use-a-t-score-vs-z-score/</a><br><a href="https://discussions.youdaxue.com/t/t/32258/8" target="_blank" rel="external">https://discussions.youdaxue.com/t/t/32258/8</a><br><a href="http://www.cnblogs.com/msdynax/p/6099574.html" target="_blank" rel="external">http://www.cnblogs.com/msdynax/p/6099574.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;斯特鲁普效应统计报告&quot;&gt;&lt;a href=&quot;#斯特鲁普效应统计报告&quot; class=&quot;headerlink&quot; title=&quot;斯特鲁普效应统计报告&quot;&gt;&lt;/a&gt;斯特鲁普效应统计报告&lt;/h1&gt;&lt;h2 id=&quot;背景信息&quot;&gt;&lt;a href=&quot;#背景信息&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="data" scheme="https://adi0229.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://adi0229.github.io/2017/07/16/2017-07-16-flint/"/>
    <id>https://adi0229.github.io/2017/07/16/2017-07-16-flint/</id>
    <published>2017-07-16T11:22:57.000Z</published>
    <updated>2017-08-04T03:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flint-can-blaze"><a href="#flint-can-blaze" class="headerlink" title="flint can blaze."></a>flint can blaze.</h1><p>Just trying some cool stuff in digital world.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flint-can-blaze&quot;&gt;&lt;a href=&quot;#flint-can-blaze&quot; class=&quot;headerlink&quot; title=&quot;flint can blaze.&quot;&gt;&lt;/a&gt;flint can blaze.&lt;/h1&gt;&lt;p&gt;Just trying some
      
    
    </summary>
    
    
  </entry>
  
</feed>
