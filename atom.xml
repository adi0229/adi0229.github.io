<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>电光石火</title>
  
  <subtitle>阿迪的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://adi0229.github.io/"/>
  <updated>2020-01-28T06:51:52.090Z</updated>
  <id>https://adi0229.github.io/</id>
  
  <author>
    <name>Jerry Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于「记忆」的记忆——读《认知心理学及其启示》（上）</title>
    <link href="https://adi0229.github.io/2020/01/27/2020-01-27-cognitive-psychology-first/"/>
    <id>https://adi0229.github.io/2020/01/27/2020-01-27-cognitive-psychology-first/</id>
    <published>2020-01-27T02:12:23.000Z</published>
    <updated>2020-01-28T06:51:52.090Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/005XGpeigy1gbca1dqtg3j309n0cswj3.jpg" alt="cover"></p><blockquote><p>哪里没有兴趣，哪里就没有记忆。——歌德</p></blockquote><p>提到「认知心理学」，没有学过的朋友，或许会觉得它是专业性很强的领域，与日常生活离得远。其中的术语，显得晦涩难解，比如说，「认知」、「认知心理学」与「认知科学」是什么意思，分别有什么区别，它们有什么实用的指导意义呢？</p><p>但其实，有人的地方，就有「认知心理」。它与我们的生活，息息相关。它研究的是关于我们的「感觉」、「记忆」、「语言」。还有，我们如何「推理决策」和「解决问题」等。换用当下一些「知识付费」课程里常见的用语，这些知识都是关于人类社会的「认知思维」和「底层逻辑」，是一通百通的，可以举一反三，以此类推。例如，对于科技行业的产品经理，他们需要熟悉基本的心理学知识。在《俞军产品方法论》一书里，前百度及滴滴出行的副总裁俞军，他的产品经理书单，就列出了认知心理学的书籍，包括这本《认知心理学及其启示》。我想，了解人类的基本认知，也就是了解目标用户的基本认知。不管是做什么产品，都可以得到启发的。</p><p>而心理学专业的同学，也许会对「认知心理学」教材的学习，感到「刻骨铭心」。回想起，各种脑部结构图里的「颞叶」、「海马体」，还有各种生涩概念「图式」、「知识表征」，以及各种交错的函数线条，翻开书页，容易读得头脑发麻，不明所以。</p><p>其实，读书也可以一路风光无限的，在读这本教材时，我就地取「法」，采用书中介绍的PQ4Q阅读法，带着好奇心来翻书，以「问题」驱动来做笔记。惊喜的是，阅读这种原本晦涩的专业教材，也收获了不少乐趣。</p><p>以至于，我更多地「记忆」到了关于「记忆」的知识。</p><h2 id="记忆大师-约翰·安德森"><a href="#记忆大师-约翰·安德森" class="headerlink" title="记忆大师-约翰·安德森"></a>记忆大师-约翰·安德森</h2><p>此书的作者是约翰·R·安德森(John R. Anderson)，他是卡内基－梅隆大学心理学系和计算机科学系的教授，也是美国科学院的院士。<br>而此书的译者之一是他的弟子秦裕林。秦裕林在译序里，点明了师父的专长。他是「记忆」领域的公认大师。</p><blockquote><p>本书一共14章……其中的2个单元中有3章与记忆与学习有关，其系统和深刻细致程度远超国内外的其他认知心理学教材。</p><p>固然是因为记忆是一切高层次认知的基础，同时，也因为作者本人是国际公认的该领域的大师。</p></blockquote><p>老师划重点了，是「记忆」那两章。如果时间有限，只读重点，就读它了。</p><p>在谷歌学术主页上，我做了一个交叉验证，发现他的一篇四千八百多引用的论文，包含了「记忆」的字眼。</p><p><img src="http://ww1.sinaimg.cn/large/005XGpeigy1gbbhzzmyhjj30yg0h1dju.jpg" alt="anderson_google_scholar"></p><p>看来，约翰-安德森是记忆的学术权威，记住他的研究，获得启示，大体没错。  </p><p>所以，关于这本书，我们来谈谈大家都有的「记忆」。</p><h2 id="我们的当下记忆，大脑是如何处理的？"><a href="#我们的当下记忆，大脑是如何处理的？" class="headerlink" title="我们的当下记忆，大脑是如何处理的？"></a>我们的当下记忆，大脑是如何处理的？</h2><p>本书中，第六章回答的问题是：我们对于当前环境中的事物，是如何将其处理，并记在脑子里的。</p><h3 id="短时记忆"><a href="#短时记忆" class="headerlink" title="短时记忆"></a>短时记忆</h3><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20200128140452.png" alt=""></p><p>最初，在上世纪 60 年代，「短时记忆（short term memory）」的概念成为认知心理学的重要术语，由阿特金森和希夫林系统化地发展，人脑中存在一个「短时记忆」流程。学者们认为，「短时记忆」好比是一个「短时加工站」，人们对身边的事物投向了注意力之后，会进入这个加工站，因为其容量有限，新信息会挤占旧信息的存储空间，所以，需要人们反复地复述某些信息，才能长久的记住它。也就是说，当下的信息，变成「记忆」，进入「长时记忆」之中，被储存下来。比如说，一些实验发现重复多次，被试记得再认一些数字，会记得更准确。兰德斯认为信息在「短时记忆」中「服刑」越长，就越可能被记住。</p><p>可是，其他研究也有反对证据 ——「复述」信息，并不是信息进入「长时记忆」的保证。比如说，格兰博格做了一个实验，「忽悠」了被试，让他们在2秒钟内学一个四位数字，然后分别间隔2、6、8秒复述一个单词，他们误以为要测试的是对于数字的记忆，但其实，测试的是他们复述的单词。他们复述单词的时候，是被动的复述。结果，对应的测验正确率是11%、7%和13%。这说明，消极被动的复述，记忆效果不佳。</p><p>我也有过被动复述的经历。在中学时期，在课堂上，我跟着老师重复朗读课文，但我毫无兴致，只是无精打采，神游物外。结果，在考试时，我也没背出来几句课文。</p><h3 id="工作记忆"><a href="#工作记忆" class="headerlink" title="工作记忆"></a>工作记忆</h3><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20200128140824.png" alt="Baddeley"></p><p>后来，认知心理学家巴德利提出了「工作记忆（working memory）」模型，来取代「短时记忆」，以解释人们的记忆，在短暂的时间内，如何处理当下的信息。这个「工作记忆」模型，得到了四万多次的引用，这说明更多的证据证实，人们在处理当下的记忆时，更可能使用的是「工作记忆」系统。</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20200128140600.png" alt=""></p><p>「工作记忆」系统，通过「中枢系统」来控制两个伺服系统，包括「视觉画板」和「语音回路」。比如说，在心算35乘以23时，你可能是这样的：一边脑补「乘法公式画面」，一边说出「35乘以23等于105」的声音。它的容量有限，一般能容纳5-9块信息，比如说，一般人在短时间内，是记不住超过十件事的，往往是容易记住三四件事。这就是为什么，不少人在说话时，喜欢先说「我主要有三点意见……」。</p><p>看来，有人的做事时，喜欢「自言自语」，并不是神经病，而是会利用「语音回路」来帮助辅助记忆。</p><h2 id="我们的当下记忆，大脑是如何记下来的？"><a href="#我们的当下记忆，大脑是如何记下来的？" class="headerlink" title="我们的当下记忆，大脑是如何记下来的？"></a>我们的当下记忆，大脑是如何记下来的？</h2><h3 id="增细加工"><a href="#增细加工" class="headerlink" title="增细加工"></a>增细加工</h3><p>平常，许多人想要加强记忆，他们的做法就是一遍又一遍的复习，打开书本，一遍又一遍地回看，做标记。有时候，因为喜新厌旧的人类习性，读着读着，他他们便昏昏欲睡，还对记东西这件事，越来越抗拒。<br>打个呵欠，听过的音频书，左耳进，右耳出，就像吹过的耳边风。手机上刷过的电子书，阅后即「忘」。换句话说，信息只是在「工作系统」里流转，没有被保留下来，存储在「长时记忆」里。</p><p>而我们「工作记忆」系统之中的短暂记忆，有一部分会被遗忘，另外一部分信息，需要经过大脑的「深度精细加工」，才会被长久的记住，比如说过了几天，甚至几年，我们也能记住其他时空里出现过的信息。这就是记忆进入了「长时记忆」之中。</p><p>那么，到底怎样，可以让记忆进入「长时记忆」的呢？研究发现，更可能的原因是，信息经过了大脑的「增细加工（elaborative PQocessing）」，它又叫「精细加工」，意思就是对需要记忆的东西，补充与它相关的额外信息。在1979年的一次心理学实验中，斯坦和布兰斯福德发现，如果被试得到的补充细节跟要记住的句子很有关联，那么，这会大大提高被试回忆句子的准确程度。</p><p>比如说，要回忆的句子是「The fat man read the sign」。  </p><p>如果给被试一句提示，是有相关背景信息的——「warning about the ice」。因为，上一句说胖男子读到一个标识，下一句说标识提醒的是冰块。两句话之间，是用「标识（sign）」逻辑关联的。采用这样的辅助信息，被试们的回忆效果最好，10句话平均能记住7.8个。  </p><p>如果是让被试自己来补充细节，也就是自由发挥，10句话他们平均记住5.8个。</p><p>如果不补充细节，只是看句子呢？被试们平均可以记住4.2句。有趣的是，如果给被试一句不相干的话做提示——「that was two feet tall」，被试们平均记住的句子最少，只有2.2个。</p><p>这种句子填空的实验任务，让我联想到了著名的记忆辅助软件Anki，它的记忆卡片，分为正面和背面，正面写问题，背面写答案。它还可以自定义其他区域，有人就补充高级的模板，包含「疑问区」和「扩展区」等等。</p><p>怎么样做深度加工呢？要点就是：扩充+有关+多多益善。我想，对某个术语和方法绘制网状的概念图，节点之间的横线上，标注有意义的逻辑关联。也就是图示卡的样式，从一个节点开始，找关联，再扩展，然后就像一张铺开的网络，往外扩张延伸，这样会强化记忆。所以，我也装了概念图绘制软件「cmap」，来绘制概念网络图，这样能够大幅压缩信息，帮助我记忆和理解复杂的事物。</p><p><img src="https://cmap.ihmc.us/wp-content/uploads/2014/10/cmapimplementinacourse.jpg" alt="概念图示例。来源：cmap官网"></p><p>概念图示例。来源：cmap官网</p><h3 id="PQ4R阅读法"><a href="#PQ4R阅读法" class="headerlink" title="PQ4R阅读法"></a>PQ4R阅读法</h3><p>在「烧脑」的学习任务之中，不少学霸采用的「自问自答」、「日记回顾」、「费曼学习法」和「错题温习」等等，都属于这本书中提倡的「PQ4R阅读法」（Thomas &amp; Robinson，1972）的一部分，这就是一种「增细加工」的方法。</p><p><strong>PQ4R法的核心是“学会提问”和“学会解题”</strong>，科学实验证明，PQ4R法是一种对知识进行深层精细加工的阅读法，能够有效提高人们解决问题的能力。比如，研究人员弗瑞斯（Frase，1975）发现，在阅读课文时，对材料「增细加工」，大有好处。在实验组中，被试在阅读时，需要对课文进行加工，以回答预设的问题。结果，他们比只读课文的控制组被试，在答题正确率上更高，64%比57%。此外，弗瑞斯（Frase，1975）的另一个实验发现，尽管，提出问题和回答问题，都有助于记忆，但自主「提出问题」似乎更有益处。研究发现，阅读课文时「自主提问」的被试，在测试到相关问题时，正确率70%，而没有「自主提问」的被试，测试正确率只有50%。</p><p>这四个字母是什么意思呢，PQ4R法怎么操作？</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20200128140622.png" alt="PQ4R.jpg"></p><p>PQ4RR指的是PQeview-预习，Qustion-提问，Read-阅读，Reflect-思索，Recite-复述，Review是复习。这些步骤具体是什么意思呢？举个例子，我现在手头拿着一本《自然语言处理入门》，我要读第一章的第一节“自然语言与编程语言”。</p><p>我的阅读步骤是：</p><p><strong>第1步：PQeview-预习</strong>。我们无需从头到尾，逐字逐句地阅读所有内容，而是概览这章的目录，查看里头都写了哪些标题，从而确定本章的主题和关键术语。这一节的主题，是标题“自然语言与编程语言”，其中分了6个小标题，分别是词汇量、结构化、歧义性、容错性、易变性和简略性。</p><p><strong>第2步：提问-Question</strong>。在完成了上一步之后，我们可以对本章节的主题，带着知性的好奇心，进行提问。比如，我提出的疑问是，书里是如何定义「自然语言处理」这个术语的？「自然语言」跟「编程语言」有啥区别呢？</p><p><strong>第3步：阅读-Read</strong>。提出问题之后，带着好奇和疑惑，翻开书本，跳读和翻读，仔细阅读章节里头的文字，寻找答案。</p><p><strong>第4步：思索-Reflect</strong>。思考的时候，脑子转起来，把里面的术语和例子搞懂，最好能够关联到自己熟悉的事情来。比如说，在理解「自然语言」这个术语的时候，我就会回想起平常我们说话的习惯，试着去理解「自然语言」的特点。</p><p><strong>第5步：复述-Recite</strong>。复述这种方法，跟很著名的「费曼学习法」类似，用自己的语言把某个事情讲清楚。如果只是单纯的阅读，很快就会遗忘的，但是复述出来，写出来，能够让我们记得更牢。下面，是我复述「自然语言处理」所写的文字：</p><p>「自然语言处理，是一个结合了语言学、计算机科学和人工智能的交叉学科，它研究的是人与计算机通过自然语言进行沟通的方法。比如，我们对智能音箱说话，让它播放某一首歌曲，就是一种自然语言处理的应用。」</p><p><strong>第6步：复习-Review</strong>。古人说「温故而知新」，「温」就是复习的意思。书读完之后，我们可以在心里回顾一遍，试着回想其中的重点。在介绍这个例子的同时，我已经把刚刚读完的内容，在脑海里过了一遍。现在回想起来，真的是记得更清楚了。</p><p>我觉得，复习的间隔周期，还可以逐渐拉长，就像 Anki 软件采用的「艾宾浩斯遗忘曲线」那样，记不牢的，复习间隔更短，比如半天、一天或者三天复习一次。若是记得牢的信息或知识，复习时长，间隔更久一点，一周、半个月或者一个月以上，等等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总之，借助「硬核」认知心理学的研究，明白了「工作记忆」的原理之后，我们在做事时，可以一边做，一边解说，或者是画图做示意，都能让自己更好的处理当下的任务。</p><p>而利用「PQ4R法」来阅读，自己建构独一无二的阅读体验，使得阅读变得愉悦，充满探索的惊奇，还能「内化」阅读记忆。</p><p>学而时习之，不亦说乎。我决定了，今后就采用「PQ4Q阅读法」。你呢？不妨一试。</p><p>黄建迪<br>2020/1/27 </p><p>(版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/005XGpeigy1gbca1dqtg3j309n0cswj3.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哪里没有兴趣，哪里就没有记忆。——歌德&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://adi0229.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>舞！舞！舞！Spotify十年金曲</title>
    <link href="https://adi0229.github.io/2020/01/09/2020-01-16-spotify-2010-2019/"/>
    <id>https://adi0229.github.io/2020/01/09/2020-01-16-spotify-2010-2019/</id>
    <published>2020-01-09T08:21:26.000Z</published>
    <updated>2020-01-17T00:23:51.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spotify十年热歌"><a href="#Spotify十年热歌" class="headerlink" title="Spotify十年热歌"></a>Spotify十年热歌</h2><p>上次，笔者简单分析了 Spotify 在去年2019的流行歌曲。这一次，数据的广度更宽了，多了 9 年的数据，也就是上一个十年的数据。正好做一个交叉验证。</p><h3 id="流行舞曲（dance-pop）依然是最火的歌曲类型。"><a href="#流行舞曲（dance-pop）依然是最火的歌曲类型。" class="headerlink" title="流行舞曲（dance pop）依然是最火的歌曲类型。"></a><strong>流行舞曲（dance pop）依然是最火的歌曲类型。</strong></h3><p><a href="https://colab.research.google.com/gist/adi0229/107078b6cdd7dfc57dc2cb88d0b8685f/spotify_2010_2019_top.ipynb" target="_blank" rel="external">Jupyter笔记本-在 Colab 打开</a></p><iframe src="https://nbviewer.jupyter.org/github/adi0229/ML-DL/blob/master/spotify_2010_2019_top.ipynb" width="860" height="2000"></iframe> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spotify十年热歌&quot;&gt;&lt;a href=&quot;#Spotify十年热歌&quot; class=&quot;headerlink&quot; title=&quot;Spotify十年热歌&quot;&gt;&lt;/a&gt;Spotify十年热歌&lt;/h2&gt;&lt;p&gt;上次，笔者简单分析了 Spotify 在去年2019的流行歌曲。这一
      
    
    </summary>
    
    
      <category term="数据" scheme="https://adi0229.github.io/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记-Pandas数据分析的25项实用技巧</title>
    <link href="https://adi0229.github.io/2020/01/02/2020-01-02-pandas-top25-tricks/"/>
    <id>https://adi0229.github.io/2020/01/02/2020-01-02-pandas-top25-tricks/</id>
    <published>2020-01-02T11:56:23.000Z</published>
    <updated>2020-01-17T00:23:57.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pandas数据清理及分析的25项实用技巧（Tricks）"><a href="#Pandas数据清理及分析的25项实用技巧（Tricks）" class="headerlink" title="Pandas数据清理及分析的25项实用技巧（Tricks）"></a>Pandas数据清理及分析的25项实用技巧（Tricks）</h2><h3 id="Jupyter代码笔记"><a href="#Jupyter代码笔记" class="headerlink" title="Jupyter代码笔记"></a>Jupyter代码笔记</h3><p>一个学习笔记，根据 Data School 的 Kavin老师的YouTube视频，公开记录在此。</p><iframe src="https://nbviewer.jupyter.org/github/adi0229/ML-DL/blob/master/top_pandas_25_tricks.ipynb" width="860" height="2000"></iframe> <h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://www.youtube.com/watch?v=RlIiVeig3hc" target="_blank" rel="external">My top 25 pandas tricks</a></p><p><a href="https://nbviewer.jupyter.org/" target="_blank" rel="external">nbviewer</a></p><h1 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h1><p>2020/01/02 init  4h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Pandas数据清理及分析的25项实用技巧（Tricks）&quot;&gt;&lt;a href=&quot;#Pandas数据清理及分析的25项实用技巧（Tricks）&quot; class=&quot;headerlink&quot; title=&quot;Pandas数据清理及分析的25项实用技巧（Tricks）&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="数据" scheme="https://adi0229.github.io/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>舞！舞！舞！流行舞曲—Spotify2019最炫曲风</title>
    <link href="https://adi0229.github.io/2019/12/30/2019-12-30-spotify-top50-EDA/"/>
    <id>https://adi0229.github.io/2019/12/30/2019-12-30-spotify-top50-EDA/</id>
    <published>2019-12-30T15:01:56.000Z</published>
    <updated>2020-01-17T00:23:11.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大众“耳感”的曲线"><a href="#大众“耳感”的曲线" class="headerlink" title="大众“耳感”的曲线"></a>大众“耳感”的曲线</h2><h3 id="50-首歌曲里，大多数的“舞感”都蛮高，满分-100-分，大多都在-60分-90-分"><a href="#50-首歌曲里，大多数的“舞感”都蛮高，满分-100-分，大多都在-60分-90-分" class="headerlink" title="50 首歌曲里，大多数的“舞感”都蛮高，满分 100 分，大多都在 60分 - 90 分"></a><strong>50 首歌曲里，大多数的“舞感”都蛮高，满分 100 分，大多都在 60分 - 90 分</strong></h3><iframe src="https://nbviewer.jupyter.org/github/adi0229/ML-DL/blob/master/spotify_2019_top50.ipynb" width="860" height="2000"></iframe> <h2 id="Dance-Pop-歌单"><a href="#Dance-Pop-歌单" class="headerlink" title="Dance-Pop 歌单"></a>Dance-Pop 歌单</h2><ul><li>boyfriend (with Social House)</li><li>Loco Contigo (feat. J. Balvin &amp; Tyga)</li><li>No Guidance (feat. Drake)</li><li>7 rings</li><li>Never Really Over</li><li>fuck, i’m lonely (with Anne-Marie) </li><li>You Need To Calm Down</li><li>Shallow</li></ul><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>[Kaggele-DataSet-top50spotify2019] (<a href="https://www.kaggle.com/leonardopena/" target="_blank" rel="external">https://www.kaggle.com/leonardopena/</a>)</p><p><a href="https://zhuanlan.zhihu.com/p/33977558" target="_blank" rel="external">Python可视化 | Seaborn5分钟入门(一)——kdeplot和distplot</a></p><p><a href="https://www.kaggle.com/arpita28/analysis-of-spotify-trends" target="_blank" rel="external">Analysis of Spotify trends</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大众“耳感”的曲线&quot;&gt;&lt;a href=&quot;#大众“耳感”的曲线&quot; class=&quot;headerlink&quot; title=&quot;大众“耳感”的曲线&quot;&gt;&lt;/a&gt;大众“耳感”的曲线&lt;/h2&gt;&lt;h3 id=&quot;50-首歌曲里，大多数的“舞感”都蛮高，满分-100-分，大多都在-60分
      
    
    </summary>
    
    
      <category term="数据" scheme="https://adi0229.github.io/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>给“聪明人”的学习忠告</title>
    <link href="https://adi0229.github.io/2019/12/21/2019-12-21-teach-smart-person/"/>
    <id>https://adi0229.github.io/2019/12/21/2019-12-21-teach-smart-person/</id>
    <published>2019-12-21T15:57:56.000Z</published>
    <updated>2019-12-28T10:52:38.460Z</updated>
    
    <content type="html"><![CDATA[<p>聪明人需要学习的忠告吗？看到这里，你可能感到疑惑，既然都用上了“聪明”来形容了，他们不应该是脑子开明得很的吗？需要什么学习方面的建议呢？</p><p>其实，这里的“聪明人”指的是那些受过良好教育的专业人士，他们在职场上是占据核心职位的员工，手握重权，是话事人，管事的。尽管他们看起来顺风顺水，学业有成，职场得意，活得很光鲜，但是在行动科学创始人克里斯·阿吉里斯看来，他们是不善于学习的，一些“聪明人”的学习只是单环学习，甚至逃避真正的学习。他们“第一个错误是把学习界定得太窄了，认为学习就是「解决问题」”。简单而言，这些“聪明人”喜欢从外部环境寻找解决问题的方法，但是他们经常推卸自己应该承担起的责任，缺乏批判性的深刻反思。</p><blockquote><p>注：行动科学是一门探究人类相互间的行为是如何被设计被付诸实践的科学。克里斯·阿吉里斯是《行动科学》一书的作者，他认为“一个探究型团体是可能被创造出来的，在这个团体中，操作行动科学所必需的技术是可以叫出来的”。</p></blockquote><h2 id="单环学习-amp-双环学习"><a href="#单环学习-amp-双环学习" class="headerlink" title="单环学习&amp;双环学习"></a>单环学习&amp;双环学习</h2><p>为了更明白这种“精英人士”的单环学习问题。我们来看看克里斯·阿吉里斯的一个打比方。想象一下，假如自己家里有一个智能恒温器，如果它感应到温度低于了68℃，它就会自动供热。这种设备体现了一定的智能，能够根据一个规则进行判断，进而做出反馈，这个68℃的数字，也许是根据过去的经验和规则得出的，在大多数情况下有效，但是在高度不确定性的情境下，它可能就不那么智能了。克里斯·阿吉里斯认为这是一种“单环学习”的例子。这也是上述“聪明人”经常采用的策略。就像在应试教育环境里，那些擅长在考试中拿高分的尖子生，来到更加复杂的社会上，却不适应，难以有所斩获一样，他们更适应有着相对确定步骤和解法的考题，但是不善于从反面的角度来思考和质疑，从全有的别人传授的方法论的框框条条中跳出来。对他们所面临的真实进行独立思考和创新尝试。<br>而更好的学习策略，他称之为“双环学习”。比如说，如果这个恒温器能够提问，“为什么是68℃？设置在其他温度是不是更经济？”这就是双环学习，带有批判性的反思。</p><h2 id="戒备行为倾向"><a href="#戒备行为倾向" class="headerlink" title="戒备行为倾向"></a>戒备行为倾向</h2><p>克里斯·阿吉里斯强调，过去人们普遍持有的观点是一种误区：需要通过激励来促进企业组织内部人员的学习态度，如果激励有效，员工们持有积极正确的态度和强烈的责任感，有效学习就会相应地发生。比如说，企业创造各种新的结构，通过报酬方案、绩效评估、企业文化，让员工更加奋勇拼搏，乐于学习。</p><p>与这种常识相反的是，有效的双环学习，并不单单只是员工的感知问题。比如说，通过更加诱人的外部激励体系，比如更可观的报酬方案，更有竞争力的绩效评分方法，让员工的感知改变：努力学习有回报，回报很超值等等。更重要的是，如果改变员工的“主控程序”（masterprogram），它才真正决定人们的所有行为。克里斯·阿吉里斯对此的定义是：“它是人们思维方式的反映，是用来计划和实施行动的认知规则和逻辑。”</p><p>所谓的“聪明人”在学习方面的第二个错误，克里斯·阿吉里斯认为是这些人的戒备行为倾向，也就说，戒备行为倾向占据了他们的主控程序，他们抵触真正的双环学习。</p><p>那么，什么是戒备行为倾向呢？比如说，一些中国人好面子，喜欢按资排辈，捧年长者为尊，当领导或者长辈犯错之后, 害怕在公开场合的认错会感到尴尬，有损自己的地位和尊严，于是他们常常文过饰非，用漂亮的话术来掩盖自己的过错，错误都别人的，也许是客户愚蠢，也许是体制问题、也许是更高层的领导，总之，错误不在自己身上。无怪乎，被领导或同事“甩锅”也成为了流行的戏谑用语。</p><p>在某种程度上，“聪明人”在过去，他们的发展是一帆风顺的，那么这个人在应对挫折时，他们会经验不足，尽管不少书籍都写到了各种领域的失败案例，但是没有亲身经历过逆境，是很难从挫折中学习的。</p><p>他们在职场上一路顺风顺水，但是会在某个阶段被自己曾经的辉煌所羁绊，习惯了某种行动逻辑，但却意识不到陷入到了一种“单环学习”的思维误区里，他们失败经历少，很少从失败经历中得到有效学习和反思。成功经历让他们有着雄心壮志，但是他们心理也对失败异常脆弱，过度恐惧失败经历导致他们的极度失落。</p><p>克里斯·阿吉里斯认为，许多人身上存在着“个体的应用理论”，是这种戒备心理倾向的根源。</p><blockquote><p>个体的「应用理论」(theory-in-use)，是人们始终按照一种不一致的方式对待事物，他们没有意识到名义理论和应用理论之间的差异，没有意一识到他们所想的做事方式与实际做事方式的差异。</p><p>主控程序是戒备性反应的人，他们常见的四种基本价值。</p><ol><li>保持单线控制</li><li>「盈利」最大；「损失」最小。</li><li>压制消极的感觉。</li><li>尽可能保持「理性」，清楚地界定目标，并根据是否实现了目标来评估自己的行为。</li></ol></blockquote><p>这些价值观，是“他们思考自身行为和他人行为的方式。”。这也是为了规避尴尬、威胁、挫折感或无能感而存在的。这也使得他们更倾向于捍卫自己过去的主张和观点，这与自我证实偏差是类似的。</p><p>所以，那些位高权重的人，如果能够不顾及地位与身份之差，平等地与他人交流，自我剖析，自我否定，那才是真正的拥有学习大智慧的人啊。相形之下，有的人，为了掩盖自己高人一等的所谓能力，即便内心已经发现有问题的苗头了，还为了面子和自尊极力否定，归因至外界，通过强词夺理来争辩，这种行为是要不得的。</p><h2 id="如何教会聪明人学习？"><a href="#如何教会聪明人学习？" class="headerlink" title="如何教会聪明人学习？"></a>如何教会聪明人学习？</h2><p>既然如此，戒备性心理让“聪明人”陷入单环学习的陷阱。那么，我们应该如何教会“聪明人”学会学习呢？下面，看看我们应该如何对症下药吧。</p><p>答案：<strong>改变人们脑子里的主控程序，戒除过分的戒备性反应，重塑他们的行为。</strong> </p><p>更具体一些，就是使用“刚性逻辑”，有效地收集数据、分析数据、检验结论，让人们认识到自己在“名义理论”和“实际理论”之间的差异。</p><p>举个例子，如果是在企业里，那么，变革从高层管理者开始，结合企业当下所面临的现实问题，让参加者设计一份基本的案例研究。</p><p>比如说，一名企业高管写了一个会议计划书（类似影视剧本），与下属直接讨论该计划书，双方互相沟通，直面对方的缺点和问题。经过这样的行动，他发现了领导群体存在的问题，他们之前完全忽视了这样的问题——4个下属经常觉得他在扯谈，他的发言毫无意义。他经常假装自己外交能力强，让大家达到了一致意见，但其实下属对此感到警觉，总是怀疑他到底想干什么。他还发现他对部门领导的竞争问题的处理，是矛盾不通的。</p><p>下属们在讨论计划书的过程中，也认识到了自己需要改进的特定行为——他们经常把问题藏着掖着，避而不谈。总之，之前那些大家避而不谈的问题，以及公开合法化的成为了重要的讨论议题，高层中层和基层各方都从自身角度来反思了。</p><p>这样看来，高管和下属都在反思之下，开始学会了有效的双环学习。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当一个人在职场左右逢源的时候，成为了“别人家的孩子”那种成功人士的时候，需要小心了——也许你我都会陷入因戒备心理产生的单环学习，阻碍了自身和组织的成长。改变自己，从改变主控程序开始吧，多多反思，自己在知行合一方面，也就是喊口号的“名义理论”和真正改变的“应用理论”之间，到底存在哪些差异？</p><p>“吾日三省吾身”，共勉。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>《如何教聪明人学会学习？行动科学创始人阿吉里斯经典好文》</p><p>《如何才能完成真正改变？行动科学经典好书助你一臂之力》</p><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li><p>191222 2个番茄种 ，共1h</p></li><li><p>191221 约1h</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;聪明人需要学习的忠告吗？看到这里，你可能感到疑惑，既然都用上了“聪明”来形容了，他们不应该是脑子开明得很的吗？需要什么学习方面的建议呢？&lt;/p&gt;
&lt;p&gt;其实，这里的“聪明人”指的是那些受过良好教育的专业人士，他们在职场上是占据核心职位的员工，手握重权，是话事人，管事的。尽管
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://adi0229.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>马航空难源于政治阴谋？—来自中情局ACH分析法的推论</title>
    <link href="https://adi0229.github.io/2019/11/29/2019-11-29-ACH/"/>
    <id>https://adi0229.github.io/2019/11/29/2019-11-29-ACH/</id>
    <published>2019-11-29T15:57:56.000Z</published>
    <updated>2019-12-24T14:15:24.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>心存疑虑令人不快，但过分肯定却令人发笑。（Doubt is not a pleasant state, but certainty is a ridiculous one.）——《竞争情报分析法》读书笔记</p></blockquote><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191129215908.png" alt=""></p><h1 id="假设-gt-无处不在"><a href="#假设-gt-无处不在" class="headerlink" title="假设 - &gt;无处不在"></a>假设 - &gt;无处不在</h1><p>大千世界，世事纷繁，从家事、国事到天下事，人们常常做出不同假设:</p><ul><li>职场人士，常想：是否该跳槽转行，跳到哪个行业里去，转行做什么职业更适合自己？</li><li>青年男女，常想：该与哪个异性交往？与哪个人结婚会更幸福？</li><li>父母长辈，常想：房子应该买在哪，昂贵的学区房是否有必要购买？</li><li>中情局的情报分析人员，要想：1993 年美军轰炸伊拉克大使馆，对此，萨达姆会报复吗？</li><li>关注马航空难的人们，会想：马航飞机MH370离奇失踪，原因是不可抗拒的自然破坏，还是一场预谋已久的政治阴谋？</li></ul><p>我们作为选择者，总想做出理性决策——选择了对的人结婚，买到了合适的房子，识破敌人的意图，识破未解之谜……</p><p>那么，面对种种假设，如何验证假设的可靠性，辅助自己做出明智的选择呢？美国中情局给出了一种方法——ACH 竞争假设分析法。</p><h2 id="美国中情局-gt-ACH-内训资料"><a href="#美国中情局-gt-ACH-内训资料" class="headerlink" title="美国中情局 - &gt;ACH 内训资料"></a>美国中情局 - &gt;ACH 内训资料</h2><p>[图片上传失败…(image-69b16d-1577193821256)]<br>  图片来源：<a href="https://twitter.com/cia" target="_blank" rel="external">CIA官方推特</a></p><p>在美国影视里，CIA特工的形象屡见不鲜，比如美剧《国土安全》里的反恐特工，经常在枪林弹火里冒险执行任务，但除了外勤的军事特工以外，CIA 还有许多内勤人员，他们跟普通白领一样——在桌子前办公，主要进行反恐情报分析等工作。</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191129230933.png" alt=""></p><p><a href="[https://www.slideshare.net/IntelCollab/how-to-reduce-analytical-bias-using-analysis-of-competing-hypothesis](https://www.slideshare.net/IntelCollab/how-to-reduce-analytical-bias-using-analysis-of-competing-hypothesis">图片来源:slideshare</a><br>)</p><blockquote><p>“Most analysts…pick out what they suspect intuitively is the most likely answer, then look at the available information from the point of view of whether or not it supports this answer. If the evidence seems to support the favorite hypothesis, analysts pat themselves on the back and look no further. “<br>大多数分析师.. … 从直觉上挑出他们怀疑的最有可能的答案，然后从是否支持这个答案的角度来看现有的信息。 如果证据似乎支持最受欢迎的假设，分析师们就会互拍后背，不再继续观察。” – <a href="https://en.wikipedia.org/wiki/Richards_Heuer" target="_blank" rel="external">Richards Heuer</a></p></blockquote><p>《情报分析心理学》一书的作者 <a href="https://en.wikipedia.org/wiki/Richards_Heuer" target="_blank" rel="external">Richards Heuer</a>，有着一副美国军方硬派白人的形象（在笔者看来）， 是美国政府情报大脑——中情局（CIA，Central Intelligence Agency）的资深情报人员，在45年多的职业生涯里，他从事信息采集和信息分析等情报工作，他最杰出的成就之一，便是《情报分析心理学》（Psychology of Intelligence Analysis）这本书，从认知心理学学科的视角出发，对人类的认知偏差导致的决策失误进行了详细的阐述，并提出了竞争性假设情报法（ACH，Analysis of Competing Hypotheses）。</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191129231203.png" alt=""></p><h2 id="ACH分析法-gt-以“1993年，美国轰炸伊拉克情报总部”为例"><a href="#ACH分析法-gt-以“1993年，美国轰炸伊拉克情报总部”为例" class="headerlink" title="ACH分析法 - &gt;以“1993年，美国轰炸伊拉克情报总部”为例"></a>ACH分析法 - &gt;以“1993年，美国轰炸伊拉克情报总部”为例</h2><p>笔者采用“抽样阅读法”（根据图书的前言和目录等，直接阅读部分核心章节），在第八章提取重点信息：<a href="https://en.wikipedia.org/wiki/Analysis_of_competing_hypotheses" target="_blank" rel="external">ACH分析法（Analysis_of_competing_hypotheses）</a>的具体步骤。</p><p>根据书中的定义，竞争性假设分析法，是基于「认知心理学」的「决策分析」和「科学方法」，用以避免常见的分析陷阱（pitfalls），特别适用于「争议问题」。在审计存档（audit trail）工作流中，该方法是用来追踪记录情报分析师是如何「审视」以及「得出判断」的。</p><p>我们看看，书中的一个实战案例 -&gt; “1993年，美国轰炸伊拉克情报总部，伊拉克是否会报复反击？”</p><blockquote><p>事件背景：1993年1月17日，美国以伊拉克在其南部地区部署导弹为由，向巴格达以南约21公里处的一个核设施发射了40多枚“战斧”式巡航导弹。6月27日，美国借口伊拉克试图杀害美国前总统布什，向巴格达市内的伊拉克情报局总部发射了24枚“战斧”式巡航导弹。<br> ——资料来源：<a href="[http://www.people.com.cn/GB/guoji/24/20020907/817395.html](http://www.people.com.cn/GB/guoji/24/20020907/817395.html">人民网：美国对伊拉克和其他国家军事打击回顾</a><br>)</p></blockquote><p>竞争性假设分析法，一共分为八个步骤，关于1993 年的美军轰炸伊拉克事件，来自美国中情局的作者是这样分析的：</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191129234430.png" alt=""></p><h4 id="步骤一-针对议题，多人从不同视角做「头脑风暴」，列举「各种假设」。"><a href="#步骤一-针对议题，多人从不同视角做「头脑风暴」，列举「各种假设」。" class="headerlink" title="步骤一:针对议题，多人从不同视角做「头脑风暴」，列举「各种假设」。"></a>步骤一:针对议题，多人从不同视角做「头脑风暴」，列举「各种假设」。</h4><p>每一列都是情报人员列出的所有假设（Hypothesis）。比如：</p><ul><li>H1的假设是收到伊拉克不会报复 </li><li>H2的假设是伊拉克会支持一些小规模的恐怖活动 </li><li>H3的假设是伊拉克正在计划一次大型的恐怖袭击，也许会瞄准一个或更多CIA中情局设施。</li></ul><p>需要注意：如果议题越重要，信息越不确定，那么需要给出更多的假设。如果提出的假设数量 &gt; 7，可以对这些假设进行合并分组的操作。</p><h4 id="步骤二-列出「清单」，包含每个假设的「正反」证据。"><a href="#步骤二-列出「清单」，包含每个假设的「正反」证据。" class="headerlink" title="步骤二:列出「清单」，包含每个假设的「正反」证据。"></a>步骤二:列出「清单」，包含每个假设的「正反」证据。</h4><p>每一行都是情报人员列出的所有相关证据（Evidence），可以是事实，也可以是有理有据的假设。比如：</p><ul><li>E1的证据是萨达姆公开声明，他们无意报复。</li><li>E2的证据是1991年的海湾战争，没有恐怖攻击事件发生。</li><li>E3的证据是假设伊拉克不愿意引起美军的另一轮袭击。</li><li>E4的证据是监控到伊拉克情报人员的电报沟通频率和长度在增加。</li><li>E5的证据伊拉克大使馆收到加强安全措施的指示</li><li>E6的证据是假设如果报复失败，对于萨达姆来说是不可接受的，让他蒙羞。</li></ul><p>需要注意：哪些事，尚未发生？比如，敌军并未集结的情报，其重要性要大于其他的“风吹草动”。</p><h4 id="步骤三-列出「矩阵」：横向每行-gt-假设H-，竖向每列-gt-证据E，分析证据的「诊断性」。"><a href="#步骤三-列出「矩阵」：横向每行-gt-假设H-，竖向每列-gt-证据E，分析证据的「诊断性」。" class="headerlink" title="步骤三:列出「矩阵」：横向每行 - &gt; 假设H ，竖向每列 - &gt; 证据E，分析证据的「诊断性」。"></a>步骤三:列出「矩阵」：横向每行 - &gt; 假设H ，竖向每列 - &gt; 证据E，分析证据的「诊断性」。</h4><p>审视每一个证据，并给出其对某个假设支持与否的诊断性重要程度，比如说：</p><ul><li>E6证据“假设如果报复失败，对于萨达姆来说是不可接受的，让他蒙羞。”，支持后2个假设，有力反对第一个假设，因此划上（- -）++。</li><li>E4证据“监控到伊拉克情报人员的电报沟通频率和长度在增加”，支持后 2 个假设，因此划上符号 - + +。</li></ul><p>需要注意：关注证据的诊断性，特别是对“只对“某个假设的影响有着高权重的证据。比如，高体温对生病与否很有参考价值，但对诊断病种毫无价值。</p><p>标记的方法，书中的示例是「加减号」，两个减号“- -“是较强的反向支持，一个加号“+”是普通的正向支持。必要时，用「数字概率」来标记重要性，这样操作衡量起来更精确。</p><h4 id="步骤四-精简「矩阵」，重新权衡。"><a href="#步骤四-精简「矩阵」，重新权衡。" class="headerlink" title="步骤四:精简「矩阵」，重新权衡。"></a>步骤四:精简「矩阵」，重新权衡。</h4><p>这一步，主要是针对之前罗列的假设，在评估了各种证据的「诊断性」之后。重新审视一遍假设矩阵，然后再重组一遍。</p><p>比如：增删、合并、拆分- &gt; 假设 ，重述 - &gt;语言，删除 - &gt;「没有针对价值」的证据。补充 - &gt; 上次遗漏的假设</p><h4 id="步骤五-得出「初步结论」，试着证伪，而非证明。"><a href="#步骤五-得出「初步结论」，试着证伪，而非证明。" class="headerlink" title="步骤五:得出「初步结论」，试着证伪，而非证明。"></a>步骤五:得出「初步结论」，试着证伪，而非证明。</h4><p>这一步过程中，需要小心翼翼审视所得到的的初步结论，多从反面来思考，真的会是这样吗？在查看那些反对的证据。</p><p>需要注意：这个时候，让反省心智占据大脑，指挥自己的论证逻辑，首要的是压制初始的直觉，一个又一个地查看假设，将其视为一个整体，侦查反对证据（标记负号的）。</p><p>然后，再根据「负号」的多少，对假设做出初始的粗糙排序。继而，又重新开始新一轮的审视，对不同证据分配权重大小，最后，再精细严谨地排序。</p><p>记住：少即是多，使用少数的关键因素来指导判断</p><h4 id="步骤六-分析证据的「敏感度」。"><a href="#步骤六-分析证据的「敏感度」。" class="headerlink" title="步骤六:分析证据的「敏感度」。"></a>步骤六:分析证据的「敏感度」。</h4><p>需要注意：提问，如果关键证据或假设出错，有何后果？</p><p>查看步骤 3 的针对性假设和证据，评估与质疑。</p><p>复查原材料，而不是轻信别人的个人解读。</p><h4 id="步骤七-报告结论。讨论「所有假设」，而不是最可能的假设。"><a href="#步骤七-报告结论。讨论「所有假设」，而不是最可能的假设。" class="headerlink" title="步骤七:报告结论。讨论「所有假设」，而不是最可能的假设。"></a>步骤七:报告结论。讨论「所有假设」，而不是最可能的假设。</h4><p>判断总有不确定，别只给出你的结论，最好让决策者知晓 - &gt; 所有可能的相对概率。</p><p>如果概率范围在“55%-85%“之间，那么我们的推论是，某假设较可能正确。</p><p>如果概率范围在“15%-45%“之间，那么我们的推论是，某假设较可能错误。</p><p>需要注意：区分「主观概率」与基于数据的相对频率的「统计概率」</p><h4 id="步骤八-高亮「里程碑」-gt-揭示「真相」与「期望」背道而驰的标志。"><a href="#步骤八-高亮「里程碑」-gt-揭示「真相」与「期望」背道而驰的标志。" class="headerlink" title="步骤八:高亮「里程碑」- &gt; 揭示「真相」与「期望」背道而驰的标志。"></a>步骤八:高亮「里程碑」- &gt; 揭示「真相」与「期望」背道而驰的标志。</h4><p>万事常变，少提定论——多提“暂时结论“，持续监控。</p><h1 id="竞争性假设分析法——以“马航事件”为例"><a href="#竞争性假设分析法——以“马航事件”为例" class="headerlink" title="竞争性假设分析法——以“马航事件”为例"></a>竞争性假设分析法——以“马航事件”为例</h1><blockquote><p>2014年3月8日凌晨2点40分，<a href="https://baike.baidu.com/item/%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A%E8%88%AA%E7%A9%BA%E5%85%AC%E5%8F%B8/4902423" target="_blank" rel="external">马来西亚航空公司</a>称有一架载有239人的<a href="https://baike.baidu.com/item/%E6%B3%A2%E9%9F%B3777/1633384" target="_blank" rel="external">波音777</a>-200飞机与管制中心失去联系，该航班号为<a href="https://baike.baidu.com/item/MH370" target="_blank" rel="external">MH370</a>，原定由<a href="https://baike.baidu.com/item/%E5%90%89%E9%9A%86%E5%9D%A1/967683" target="_blank" rel="external">吉隆坡</a>飞往<a href="https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC/128981" target="_blank" rel="external">北京</a>，应于北京时间2014年3月8日6:30抵达北京。</p><p>2014年3月24日晚10点，马来西亚总理<a href="https://baike.baidu.com/item/%E7%BA%B3%E5%90%89%E5%B8%83/5354749" target="_blank" rel="external">纳吉布</a>在吉隆坡宣布，马航失联飞机在南印度洋坠毁，机上无一人生还。2015年1月29日，马来西亚民航局宣布，马航370航班失事，并推定机上所有239名乘客和机组人员已遇难。<br>据媒体报道，2019 年 7 月份时，只有法国司法部门仍在调查此事。</p></blockquote><p>下面的分析例子，引用自《竞争性假设分析法在大型突发性事件分析中的应用研究—以“马航mh370失联事件”为例》，对每个步骤的翻译，使用论文作者的译法。</p><h4 id="步骤一-提出假设"><a href="#步骤一-提出假设" class="headerlink" title="步骤一:提出假设"></a>步骤一:提出假设</h4><blockquote><p>针对马航失联事件,收集网上相关新闻及专家观点。 提出下面几种假设:<br>假设 1:外界天气原因造成系统失灵<br>假设 2:飞机自身原因造成引擎或通讯失灵<br>假设 3:高空解体<br>假设 4:恐怖袭击<br>假设 5:机长劫机<br>假设 6:政治阴谋</p></blockquote><p>论文作者，分别从技术、环境和政治等方面做出了多种假设。</p><h4 id="步骤二-列出相关证据"><a href="#步骤二-列出相关证据" class="headerlink" title="步骤二:列出相关证据"></a>步骤二:列出相关证据</h4><blockquote><ul><li>证据 1:媒体报道,有乘客冒用他人护照登上失联<br>航班,此外,奥地利外交部证实,失联客机乘客名单中 的奥地利籍乘客本人没有登机。</li><li>证据 2:马来西亚官方证实,吉隆坡国际机场现场 监控确认使用虚假护照信息登机的乘客画面。</li><li>证据 3:参与马航失联客机调查的调查人员说,在 客机 8 日凌晨从雷达消失后,不止一颗通讯卫星收到 来自客机的微弱电子脉冲信号。 信号每隔大约一小时 传输一次,卫星大约监听到 5 ~ 6 次这样的信号。</li><li>证据 x：…………</li><li>证据 20:马来西亚警察总长哈立德·阿布·巴卡 尔 15 日在吉隆坡表示对印尼警长的言论感到震惊,而 且也打算就此事与其进行谈话。 苏达尔曼称,“ 我已经将自己知道的信息告知了马来西亚监察警长巴卡尔 ( Khalid Abu Bakar) 冶 ,然而,马来西亚当地媒体则报道 称,巴卡尔对上述传言表示震惊,并公开否认自己收到 过此类信息,他表示“我很想知道是什么媒体在什么 时候发布了这样的报道。 我将会询问印尼警方是否已 将该消息告知马来西亚冶 。</li></ul></blockquote><p>论文中列出了 20 个相关证据，大多来自官方声明及媒体报道，但是信息的真实性并未得到完全确认，因此，后续需要更严谨的审视。</p><h4 id="步骤三-列矩阵图"><a href="#步骤三-列矩阵图" class="headerlink" title="步骤三:列矩阵图"></a>步骤三:列矩阵图</h4><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191129234035.png" alt=""></p><ul><li>1： 支持假设</li><li>0：与假设无关</li><li>-1：反对假设</li></ul><h4 id="步骤四-完善矩阵图"><a href="#步骤四-完善矩阵图" class="headerlink" title="步骤四:完善矩阵图"></a>步骤四:完善矩阵图</h4><p>论文中，这一步的具体操作没看到。作者根据矩阵图得知，假设 4 和假设 6 是最有可能的假设。</p><h4 id="步骤五-得出初步结论"><a href="#步骤五-得出初步结论" class="headerlink" title="步骤五:得出初步结论"></a>步骤五:得出初步结论</h4><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191224211430.png" alt=""></p><p>假设 4 和假设 6 的得分相对较高，分别是 4 分和 5 分。论文作者认为，“假设6的证据与假设依赖程度更高”，因此，初步结论为假设 6，马航失联是政治阴谋操纵的。</p><h4 id="步骤六-证据敏感性分析"><a href="#步骤六-证据敏感性分析" class="headerlink" title="步骤六:证据敏感性分析"></a>步骤六:证据敏感性分析</h4><p>这一步，需要对假设 6 的强相关的证据，再进行严格审视，重点关注其“敏感性”。</p><blockquote><p>证据 6:马航消息混乱引质疑,马民航局:军方可能有所隐瞒,马来西亚被疑掩盖真相;<br>证据12:MH370 乘客家属:没有任何人进行过所谓的见面沟通(马方政府报道有进行见面)<br>证据 15:飞机制造专家周济生表示,“ 波音 777的飞机,可靠性和性能是很高的,要想所有的东西都坏掉几乎是不可能的。肯定是遇到了外界不可抗拒的力量。<br>证据 19:英国《每日邮报》9 月 15 日报道,印度尼西亚国家警察总长苏达尔曼上将在一次会议中称“事实上,我知道马航发生了什么事。 ”<br>证据 20:马来西亚警察总长哈立德·阿布·巴卡尔15日在吉隆坡表示对印尼警长的言论感到震惊,而 且也打算就此事与其进行谈话。 苏达尔曼称,“ 我已 经将自己知道的信息告知了马来西亚监察警长巴卡尔 ( Khalid Abu Bakar) 冶 ,然而,马来西亚当地媒体则报道 称,巴卡尔对上述传言表示震惊,并公开否认自己收到过此类信息,他表示“我很想知道是什么媒体在什么 时候发布了这样的报道。 我将会询问印尼警方是否已将该消息告知马来西亚。</p></blockquote><p>文中认为，证据 15“飞机不可能失灵，来自不可抗拒力量”与假设4、假设 5、假设 6都可能有联系，因此，它在3种假设中不具备诊断价值。<br>假设 6 的其他证据都来源媒体报道和当事人，具有一定可靠性，对假设的判断具有诊断价值。</p><h4 id="步骤七-总结报告"><a href="#步骤七-总结报告" class="headerlink" title="步骤七:总结报告"></a>步骤七:总结报告</h4><p>这一部分，文中只给出了最可能的假设：政治阴谋。<br>但根据原书的方法，应该把其他可能的假设也进行一番论证，比如得分也比较高的假设 4 恐怖袭击，最好不要只报告最可能的一个假设。</p><h4 id="步骤八-设定未来观察标记"><a href="#步骤八-设定未来观察标记" class="headerlink" title="步骤八:设定未来观察标记"></a>步骤八:设定未来观察标记</h4><p>书中设定的观察标记是：</p><ul><li>a.欧洲某些国家的行为</li><li>b.后续搜寻活动</li></ul><p>笔者认为，以上的证据都不算是强有力的“实锤”证据，各方言论和小道消息的真实性都有待进一步验证。马航空难究竟是否源自政治阴谋，尚无定论。<br>所以，我们不能言之凿凿，还需要密切关注后续的重大进展，但是这样的ACH分析方法，值得借鉴。</p><h1 id="原版电子书链接"><a href="#原版电子书链接" class="headerlink" title="原版电子书链接"></a>原版电子书链接</h1><p><a href="https://www.cia.gov/library/center-for-the-study-of-intelligence/csi-publications/books-and-monographs/psychology-of-intelligence-analysis/PsychofIntelNew.pdf" target="_blank" rel="external"> Psychology of Intelligence Analysis-CIA 官方免费PDF 电子书</a></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>施国良, &amp; 周晓帆. . 竞争性假设分析法在大型突发性事件分析中的应用研究–以“马航mh370失联事件”为例. 情报杂志(1), 27-31.<br><a href="https://zhuanlan.zhihu.com/p/54387752" target="_blank" rel="external">美国是如何开展军事情报工作的？</a><br><a href="https://www.jianshu.com/p/d2bbd9b0ec06" target="_blank" rel="external">常见的分析方法之竞争性假设</a></p><h1 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h1><p>2019.12.24 校对 0.5h<br>2019.11.30 新增作者言论的引用 0.2h<br>2019.11.29 修改开头及细节编辑 2h<br>2019.11.24 新增例子2部分的内容 1h<br>2019.11.21 撰写作者及图书背景部分 2.5h<br>2019.11.20 撰写例子1部分 1.5h<br>2019.11.19 整合草稿 0.5h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;心存疑虑令人不快，但过分肯定却令人发笑。（Doubt is not a pleasant state, but certainty is a ridiculous one.）——《竞争情报分析法》读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://adi0229.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub+PicGo个人图床配置记录</title>
    <link href="https://adi0229.github.io/2019/11/25/2019-11-25-cloudimg/"/>
    <id>https://adi0229.github.io/2019/11/25/2019-11-25-cloudimg/</id>
    <published>2019-11-25T13:26:56.000Z</published>
    <updated>2019-11-26T15:32:31.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近，笔者的GitHubPage博客，图片挂了不少，于是尝试使用 GitHub 图床，来满足Markdown 格式下的图片存储和上传的稳定，记录如下。<br>图床一般是指储存图片的服务器，写文章时，使用 markdown 格式来插图，需要传入图片地址，这时，将图片上传到图床服务器，获得链接，就可以粘贴在自己的博文里，别人可以访问到了。<br>图床使用指南 -&gt; <a href="[https://sspai.com/post/40499](https://sspai.com/post/40499">少数派-嗯，图片就交给它了</a></p></blockquote><h1 id="创建GitHub图床"><a href="#创建GitHub图床" class="headerlink" title="创建GitHub图床"></a>创建GitHub图床</h1><p>首先，登录GitHub 账号，点击右上角头像左侧的“+”号图标，点击【新建仓库】（New Repository）<br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224938.jpg" alt=""><br>勾选【公共仓库】&amp;【初始化 README】选项，创建仓库。<br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224928.jpg" alt=""><br>点击右上角头像图标，点击【设置】（Settings）。<br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224919.jpg" alt=""><br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224908.jpg" alt=""></p><p>点击左侧导航的【开发者设置】（Developer settings），点击【个人连接密匙】（Personal access tokens）。<br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224849.jpg" alt=""></p><p> 填写【注释】（note），再勾选【仓库】（ repo），点击【生成密匙】（Generate Token）。</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224843.jpg" alt=""></p><p>注意：生成Token后马上安全存储起来，因为它是“阅后即焚”。</p><h1 id="PicGo图片上传管理工具"><a href="#PicGo图片上传管理工具" class="headerlink" title="PicGo图片上传管理工具"></a>PicGo图片上传管理工具</h1><p>PicGo介绍：<a href="https://sspai.com/post/42310" target="_blank" rel="external">PicGo：基于 Electron 的图片上传工具</a></p><p>下载：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="external">PicGo</a>，安装并打开 PicGo。</p><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224832.jpg" alt=""><br><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191125224554.jpg" alt=""></p><p>在左侧抽屉导航栏，点击【GitHub 图床】，然后根据图示设置自己的参数，点击确定。</p><p>自定义域名：<a href="https://raw.githubusercontent.com/[username]/[仓库名]/master" target="_blank" rel="external">https://raw.githubusercontent.com/[username]/[仓库名]/master</a></p><p>接下来，就可以上传图片，贴到博客文章里了。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://blog.csdn.net/yefcion/article/details/88412025" target="_blank" rel="external">CSDN：PicGo + GitHub 搭建个人图床工具</a></p><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>19.11.25 init 1h </p><p>19.11.26 增加一些参考链接 0.2h </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近，笔者的GitHubPage博客，图片挂了不少，于是尝试使用 GitHub 图床，来满足Markdown 格式下的图片存储和上传的稳定，记录如下。&lt;br&gt;图床一般是指储存图片的服务器，写文章时，使用 markdown 格式来插图，需要传入图片地
      
    
    </summary>
    
    
      <category term="工具" scheme="https://adi0229.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AI编剧续写《老友记》-- 基于 GPT2 开源版</title>
    <link href="https://adi0229.github.io/2019/06/27/2019-06-27-gpt2-friends/"/>
    <id>https://adi0229.github.io/2019/06/27/2019-06-27-gpt2-friends/</id>
    <published>2019-06-27T02:45:34.000Z</published>
    <updated>2019-08-28T14:58:47.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019-06"><a href="#2019-06" class="headerlink" title="2019-06"></a>2019-06</h2><h4 id="6-27"><a href="#6-27" class="headerlink" title="6.27"></a>6.27</h4><p>引子：“Like, you guys all have job? ”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-90f85681b021d0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>大萧条时代再度降临？大家都失业了，Ross的在职朋友，也是异类。</li><li>原本斯文的博士Ross，变得古怪–大呼小叫，次日飞往佛蒙特州，参加某个免费的活动？</li><li>Rachel 捧着一束花，以祝贺 Joey。Joey 谦虚回答，这很容易啦，去书店。Rachel 接话，拿起“她”的书就好啦。her book 指的是谁的书呢？</li></ul><h4 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-a6d77cedc8f15064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>盼星星，盼月亮，盼周末？Chandler厌倦了整天面对数字的日常工作？奇怪的是，钱德勒不适应快言快语？其实，在真实剧集中，钱德勒妙语连珠，常开冷笑话。</li><li>Rachel 带了音乐专辑？记得某一集里，大家讨论 Kiss 接吻，Rachel 建议“Word of advice: Bring back the comedian.Or next time you’ll find yourself listening to that album alone” Rachel出现在音乐专辑封面？她跨界玩音乐了？客串嘉宾？MV 女主角？</li><li>奇怪的场景：Rachel观赏鸭子游泳，Joey在帮忙划水？ - - </li></ul><p>（AI 写手，还真的是脑洞大开啊，还写得快。）</p><h4 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-a645767f0e36d0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>续写上集「鸭子游泳」</p><ul><li>鸭子在水桶里戏水。Rachel又和意大利人约会，叫 Pete。</li><li>Joey 出场，带着巨型陶瓷杯，对比之下，Rachel 拿着小啤酒杯，里头是巧克力摩丝。双方互相吐槽，Rachel 笑话 Joey：“你不懂给陶瓷杯加热”，Joey 反击：“你都没做过这事。”</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-5a05451c93824e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>续写上集的一句话「瑞秋拿着啤酒杯回来了」-&gt; “Rachel returns carrying a beer mug”</p><ul><li>Phoebe和 Monica 争吵，因为 Phoebe 带朋友的孩子来玩，但是孩子走丢了。于是，她想离开 Central Perk&amp;老伙计们。Monica 反应激烈，在浴室哭泣，“砰砰砰”，摔门而出。</li><li>GPT2写手对电视剧里的「广告插播」这一套路，是了然于胸，他写道“Commercial Break”，接着就是广告回来的 Scene：四个家伙在抢盘子。</li></ul><p>进化中的AI 写手，在「内隐化」-&gt; 「戏剧化冲突」这一故事内核？</p><h2 id="2019-07"><a href="#2019-07" class="headerlink" title="2019-07"></a>2019-07</h2><h4 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-d4c42a224c517b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>四人抢夺盘子之后……</p><ul><li>Chandler幽默嘲讽Rachel：“一个人吃完整个小麦面包，挺难的。”</li><li>Rachel转头对Monica说：“你是职业大厨，应该给咱们大家庭全部供餐。”</li><li>Monica毫不领情：“等等，只有一个顾客。”指的是自己只给老公Chandler一人做菜？</li><li>Ross温情帮腔：“Rachel是我妻子，我给她做菜吧。但是我不擅长做菜，姐姐你得帮我。”</li></ul><p>简短对话，无厘头风延续 -&gt; GPT2写手，了然于胸-&gt; Rachel 是 Ross 妻子。</p><h4 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-36f8e84bdbe682ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这个GPT2-Friends 写手，喜欢转移场景，它续写人类句子，很少对「灵感激活句」扩展，只是一笔带过。比如，Monica 是职业大厨，她空余时间，就爱清理地板。（嗯，AI 写手知道 Monica 的洁癖）而关于Monica 在哪做厨师，擅长什么菜，做菜有何特别之处？没有写出。</li><li>场景依然围绕「饮食」展开，比如，免费开胃菜（free appetizer）、牛排(steak), 出现新人物 -&gt; 慈善女孩（Charity Girl)， 话题围绕的是慈善女孩的梦境 -&gt; 在梦里，她是国王，而中国武士集合列队(assembled china people)，守护着她。</li></ul><h4 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-0de8a2cb0ad4e484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Monica厨娘风范尽显，回家做甜饼，是给 Chandler 准备？第一集开场时，Chandler说过一句：“Cookie？”，他爱吃甜饼。</li><li>奇葩事情，Rachel 从 Monica 手中夺过电话，然后递给 Monica？似乎 GPT2-Friends 写手对「人物概念关系」还不太熟悉。 </li></ul><h4 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-fbb4eda230af9c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>场景：Monica与某个男人调情。他试着抚慰她，与此同时，在电话一端，她跟 Rachel抱怨：“我的脸颊疼疯了。” Rachel打趣道：“你可以把你的不爽，发泄到他身上啊。”最后，那个男人很满意，他说第三次约会很赞。（这让我联想到了某一集里，Monica 跟红酒先生Paul说的，“So there will be a fifth date.”）</li><li>场景：月之舞餐厅。（这个场景定位，学得惟妙惟肖。）Joey 的约会对象 Emily 想让他越说越多。故意闲扯了各种让人紧张得竖起耳朵的话，“要不，我告诉 Phoebe，我怀孕了，我们有小孩了。”“哈哈，别紧张，开玩笑哒。”“你知道吗？有些事我没告诉你，我爸爸曾是色情明星，你们一周能看一次。”Joey 这一回学乖了，盯着背景，有来有回的 -&gt; “得了吧，你说的是我吧。”这段话有启发，张力十足，狗血剧情。</li></ul><h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-45321d6c3ce00ce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>“What’s your problem？”（根据近日著名的泼水事件得到启发的句子。）</p><p>GPT2-Friends 写手，续写了一个少男少女式对话，Joey 和 Alice，关于吉他练习，关于吃醋和分手。</p><ul><li>Joey 勾搭上了另一个叫 Alice 的女孩，她想要 Joey 的华丽吉他，彻夜弹奏它。同时，她吃醋，逼着 Joey跟Emily 分手。Joey 安抚她，说自己正在赶走 Emily。Joey 太坏了，跟正剧里一样，有「一吨前女友」。</li></ul><h4 id="7-6"><a href="#7-6" class="headerlink" title="7.6"></a>7.6</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c19f60e84782adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的剧本，略凌乱，略无聊。</p><ul><li>Monica&amp;Phoebe 是蕾丝&amp;女同性恋？她们看上了 Monica丈夫之妹？<ul><li>“She’s beautiful,she got these big breasts and a crush on you!”<ul><li>女同性恋也看「大胸」？那个小姐姐也喜欢 Monica？？</li></ul></li></ul></li></ul><p>小结：GPT2 -Friends 微调写手学到了各种八卦式对话，依然是老问题，人物的关系和事件，没学到。只是表面模仿人类的词句组合。这当然，只是一个拟合统计模型。</p><h4 id="7-7"><a href="#7-7" class="headerlink" title="7.7"></a>7.7</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-16c58477190de11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>回到「最初的开始」，剧本首句，”There’s nothing to tell, just some guy I work with!”。人们常说 -&gt;「莫忘初心，方得始终」-&gt; ( ´◔ ‸◔’)</p><p>但是，GPT2-Friends 写手并不领情，他没有写什么常规的剧情，“只是我一个同事”之类的陈词滥调。</p><ul><li>它思维跳跃,如此写道 -&gt; Phoebe 刚出狱，她很开朗，但她的老伙计们，中央公园(Central Perk)的朋友们，反而难以承受 -&gt; Ross 闷闷不乐，Chandler 躲起来。</li><li>Phoebe 是开心果，戴上勋章，给 Ross 逗乐-&gt; 看， 我都没事，嗨起来。</li><li>Phoebe找到 Chandler的号码，“铃铃铃！”，嗨，快接电话啊，老伙计 Chandler！</li></ul><h4 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-c7b538eacb6c0445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的引子，来自第一季的纽约大停电，“This is so cool, the entire city is  black out.”(这是我根据松散记忆敲出来的，似乎句子并不合语法。）</p><ul><li>Joey忘拿了通往纽约尼克斯队的密匙？或者是他要上场打篮球？英文词典里，keys 也有着「罚球区」的语义。或者是 Ross 说的，这是类似老牌隧道羞辱游戏，是纽约尼克斯主场的球迷互动游戏?</li><li>剩下的对话，又进入了「闲扯」频道，各种「你要杀我啊」之类的吐槽。Ross 神补刀-&gt;Joey 这家伙，好像都折腾死了一百万个姑娘。</li></ul><h4 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-09b00a237a9c847a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>(问题来了 -&gt; 前端界面，体验不佳–&gt; 排版混乱, 不同人物角色的对白，都密密麻麻，难以区分。少了「留白」。好吧，待办事项+1)</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-a71af66a0a6410ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在命令行界面，GPT2 生成模型的输出，都是另起一行的。</p><p>今天的引子，依然来自第一季的纽约大停电，“This is so cool, you guys, the entire city is  blacked out.”(这次用了过去时，照着剧本复制进来的。语法应该是准确无误的。）</p><ul><li>AI 写手硬伤——不按给定的「主题」来续写剧本。我的 GPT2-Friends写手蛮任性——不按给定的「主题」来续写剧本。今天，我给她的引子句子，其话题是「停电」，她「一意孤行」写了「结婚旅行」的对话场景。上面的其他对话，也是如此。与其说是续写剧本，不如说是接过话题，开始满嘴跑火车。当然了，如果对她的奇异跳跃思维，进行修葺，创造出合乎情理的「远距离联想」，也未可知。</li><li>奇怪&amp;搞笑的对话。似乎六个老伙计之中，有两人结婚了，也不知道是 Ross &amp; Rachel 还是 Monica &amp; Chandler。只是，在结尾处，Chandler 跟Joey开冷笑话，“有机会，咱也结个婚吧。”其他，主要是旅游中的话痨场景，诸如“地铁里怎么换乘啊，地图看起来很乱。”“在纽约旅行？看看如何在纽约蒸发吧。”“快看!那里有个疯子””你记得吗？上班时，我有几个晚上能回家的？”</li></ul><h4 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-ca7c3a7cde4ad5ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天是个艳阳天，从猖狂的恶魔奴才们开始吧。<br>“Satan’s minions at work again!”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-466314c4a6253044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>GPT2-Friends写手，他闻过则喜，接受了昨天的反馈。它续写话题了。</li></ul><p>“恶魔的奴才们开始活动了！”<br>“这就是为什么，Rachel 邀请他们来！他们一点也不好，我可不想跟他们在一块，都是推销商！”——爱嘲讽的 Chandler</p><ul><li>转场 -&gt; 考古生物学家 Ross 的主场 -&gt; 场景「自然历史博物馆」</li></ul><p>“看，窗口外那个姑娘，她拿着化石耶。天啊，她真是与众不同”。Ross一边说，一边模仿蝙蝠的动作。<br>“这个姑娘，我最喜欢的一点——她超级聪明。她说，科学就是她的生命。虽然她有点瘦，但是她超可爱哒。天啊，她是我见过的最棒的姑娘了！”</p><p>这个情景，似乎是从第一季里 Ross 在博物馆里得知他的女同性恋前妻怀孕消息得到启发的。这段场景，我给五星评价，对话自然有趣，符合人物特点。<br>在这个生成模型的文本里，Ross 很幽默，以身作则，带她逛自然历史博物馆，感染了妻子 Rachel ，让她对女科学家产生崇敬之情。</p><h4 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c04b26d58e19083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的开头台词，是第一季里经典的”Welcome to the real world, it sucks, you gonna love it” ——欢迎来到现实，它很渣，但是你会爱上它的！</p><ul><li>机器人写手的自嘲！现实很骨感，但是你会爱它，胜过爱机器人的！“Welcome to the real world, it sucks, you gonna love it <strong>more with a robot</strong>.”</li><li>Rachel 的文艺与愤怒：“你怎么会不欣赏这样的人——它迷上了自己看不见的东西。”</li><li>Ross 卡在床上，动弹不得，难以脱离。也许可以设计一个搞笑的「内事」场景——就想某一集里，Ross 喝醉之后，跟 Rachel 睡到一张床上。</li></ul><h4 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c04b26d58e19083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的开头台词，是第一季里经典的”If you spent it, it will be like shopping!” Pecebo收到了某个银行神秘的钱和足球电话，她感到烦恼，感觉像是偷东西（Stealing）。瑞秋给她打气，激发自信，如果你花掉这些钱，就像去购物一样啦。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-e99108698b1fb083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在Ellen 脱口秀节目里，Rachel的扮演者Jennifer Aniston仍然能顺出这句台词。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-27144409f494fa8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天续写的剧情，显得很「普通」。</p><p>邀请「某个她」来「聚会」，或者叫「开趴」，关键词也是常见的「吸引」、「晚餐」&amp;「礼物」等等。当然了，几个老伙计，邀请年轻朋友来聚餐，享受一个乐呵乐呵的普通日子，你嘟哝几句，他唠叨几句，也是极好的。</p><p>嘟嘟哝哝，也是参差百态&amp;生机勃勃，进而获得幸福本源。</p><h4 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h4><p>笔者今天路过国家博物馆，看到了路边指示牌上的英文「National Museum」，因此，今天的开头台词——“Today, we go to the National Museum”。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-da2445113cc1446a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2-Friends 学乖了，这一次剧情紧扣主题「博物馆」，而且只有 2 个人物，对话线索清晰，易读。</p><ul><li>它又玩黑色幽默了。Rachel 和一个叫「博物馆」的人，准备去参观自然历史国家博物馆。</li><li>这个叫「博物馆」的人，从对话上看，说话显得刻薄「你忘了带上那些装着古生代恐龙的盒子吗？我可要抓住你，把你跟那些恐龙化石一起扁死！」、「我看你在找那些化石，你知道我要做什么吗？把你的头丢到后面」。这时候，我脑海里，这是一个叫「博物馆」的 AI 机器人，开始叛变了，十分绝情冷酷，它痛恨人类，又不得不跟人类合作生活。因此，它有着毒舌属性。</li></ul><h4 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h4><p>今天的开头，来自上周的慈善女孩疯狂之梦。<br>“Charity Girl’s wild dream.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-171b8c02b6140835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>场景「没糖吃的生气女孩」——Rachel 气得在卧室里进进出出，来来回回地摔门，还说：“好吧，就是该我来拿钥匙！”兴许，她摔门时，特别气愤，忘记给自己带钥匙，于是把自己锁在了门里。记得正剧里，有一集特别搞笑的场景，就是 Rachel 和 Monica 争吵。”你说你拿了钥匙的！”“你才说你拿了钥匙的！”也不记得她们是否上手打了起来。</li><li>场景「办公室里的产品评测报告」。正剧里，Rachel 进军时尚业，如今自称律师。Monica 老妈曾经吹嘘过，Monica 是开餐馆。难道这一次，Rachel 做了律师，帮助 Monica 审阅某个餐饮业的产品报告？</li></ul><p>看得出，这个AI 文本生成器，是对语料里的文本结构有着超强的模仿能力。对于「门外的钥匙」&amp;「办公室里的文档」等事物，都模仿得惟妙惟肖。</p><h4 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h4><p>今日，人工智能媒体《机器之心》刊文，介绍了一位大四小哥，基于GPT-2的NLP模型，制作了一个编程插件Tabline，用于编程中的「智能关联推荐」任务。所以，两个文本模型都是系出同门。因此，今天就吹捧一下OpenAI团队开源的这个自然语言处理大杀器吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-aa1de51991a6a5f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>截图：构思创作中的 GPT2</p><p>今天的 GPT2-Friend 微调写手，开了几个冷幽默。<br><img src="https://upload-images.jianshu.io/upload_images/452087-1cda3403759aa5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>“GPT-2 can help developers to write codes better. Maybe a 3D Touch game controls the end. ”——用 3D Touch 游戏作为结束吧。机器学习智能补全代码了？那么码农社畜们，可以下班前玩一把采用了 3D Touch 技术的游戏了？或者。或者，意思是——将来3D Touch 技术将成为主流交互方式，长按按钮，发出命令，让 AI 自己生成一堆代码去吧。</li><li>Monica 的冷笑话——“我发现一件特别的事！” “是什么？”“网上什么也找不到了！”哈哈，信息爆炸时代，在网上找不到一点东西，确实是诡异的小概率事件。Rachel 也不甘示弱——“没事，找不到东西不要紧。看看这玩意！”她拿出了一个 CD-ROM，在互联网的“上古时代”，在宽带网络普及之前，老哥老姐们用 CD 碟片来安装软件和游戏啊。</li></ul><h4 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h4><p> 笔者喜欢 Chandler 的富有文化的冷幽默。今天用他在第一季第六集的台词——对 Joey 饰演话剧的评价。</p><p>“You can spot someone who’s never seen his plays.”<br>“Notice, no fear. No sense of impending doom.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-1082aeaf13e62c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>今天的草稿，写的似乎是一个「追逐巨型气球」&amp;「被室友锁在屋外」的场景。也许是某个以热气球做为标志的反派，要来追杀老友记四个朋友们，他面无表情的直奔屋子，正要撞开们。有些小伙伴在外面，想敲门进去，其他小伙伴恐惧过度，不敢开门。</p><p>嗯，契合了第一句——厄运将至</p><h4 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h4><p>今天，笔者刚刚读了36 氪的一篇商业报道，关于计算机视觉技术驱动的创业公司「格灵深瞳」的低谷。简而言之，创始人过分关注技术，「每一分钟都想写代码」，而他的创业搭档 CEO 也没有「下注」中彩，他们在创业初期，没有找对适合三维CV技术落地的市场——当时零售市场不景气。细节参见：<a href="[https://tech.sina.com.cn/it/2019-07-18/doc-ihytcerm4587044.shtml](https://tech.sina.com.cn/it/2019-07-18/doc-ihytcerm4587044.shtml">格灵深瞳 天才AI公司跌入谷底之后</a>)</p><p>于是，下意识地用微软的翻译应用，将“人工智能技术，需要符合市场需求，而不是一群技术人员在实验室里研究不实用的技术。”转成了英文——“Artificial intelligence technology needs to meet market demand, rather than a group of technicians working on less practical technology in the lab.”</p><p>看看 AI 写手怎么看待 AI 落地（如何模仿人类文本）？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-135dba8d12b6b8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>也许是发现了”Artificial Intelligence” 经常与”Engine”&amp;”Computer”等词汇出现,都是计科领域高频词汇。</li><li>这段剧集草稿里，大家互相都用高音（High pitch voice）在尖叫，在体现冲突的场景里，角色们歇斯底里，显得很戏剧性吗？</li><li>“The Pope’ coming tonight.”&amp;”Scuse me”——《教皇今夜降临》&amp;《借过》，特别文艺范的标题，是AI 拟好的话剧名？</li></ul><h4 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h4><p>(竟然遗漏了一天7.19日，嗯，证明我是血肉真人，不是机器人写手。)</p><p>音乐操纵情绪。嗯，今日的开头，我的金句。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-bdc2c3e142f88938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>于是，我的 GPT-2 是情绪化了吗？今天写了一段完整的约会对话。而且跟真实剧集无缝连接啊。</p><p>Ross 在高中便暗恋 Rachel，一直念念不忘。Joey 在他和同性恋前妻离婚之后，给他做过一个隐喻暗示——「Grab a spoon」，拿起一个勺子——找一个姑娘勾搭起来。</p><p>于是——</p><ul><li>Rachel 和 Ross 在讨论 「Grab a big plate」，嗯 Rachel 是盘子，比勺子的容量要大。两口子的余生，互相指教吧。</li><li>Rachel 邀请 Ross 一起看电影，还各种变相夸赞和表白 Ross。甜蜜的场景。</li></ul><h4 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h4><p>今天，以笔者的桌面，编程大师 Linus Torvalds 的名言：“A computer is like air conditioning, it becomes useless when you open windows.”作为第一句。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-941d57bdc4f2fb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2 对剧情里的设定还是挺了解的，它知道 Rachel 老是忘记带钥匙，Joey 是演电影的。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-354abd1483754331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第一个场景：Rachel 去见 2 个医生，但是因为没带钥匙，所以没有收到某种消息。诡异的是 Haldane 医生在脸颊上夹着一个很大的酒瓶。这是描写医生嗜酒如命？</li><li>第二个场景： Joey 家里来了一个漂亮女郎，看起来很像他在电影里亲吻过的女人。Rachel 通过门前的窥视孔查看 Joey 金屋里的娇女郎——一个穿着长裙的光头美女。Joey 摇头，但是 Rachel 没有摇头。</li></ul><h4 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h4><p>刚刚看了两篇文章，分别是《中年职场男创业开店一年实录》&amp;《下班后 ①》，文章都浓浓地透露出了互联网职场人士的「丧&amp;焦虑」。</p><p>于是，写一句「互联网人很焦虑」作为开头吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-6c2d76fab9f681d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>「动作场景」——抢夺巨扇。抛开Ross 手拿巨扇，Rachel 把扇子抢走（Ross with Huge Fan in Hand &amp; She grabs the fan in her hand）——经济大萧条，大热天的，大家只能抢夺一把巨型扇子吗？嗯，这很黑色幽默。</li><li>GPT-2 的毒舌嘲讽？Phoebe 讲了一句意味深长的话：你知道吗，有些人，与自己无关的人死了，他也会深感不安。（Phoebe: Hey, listen, you know how people get really upset when someone they’re not related dies? ）意思是别人开店失败，别人加班焦虑，你看了也跟着焦虑个啥？做好自己的事先！嗯。</li></ul><h4 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h4><p>今天，从著名金句「I have a dream」作为开头。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-c50e414127e1cfc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Monica “歌颂”Janice，你是我的女神（goddess）啊——因为她照顾孩子很周全。</li><li>其他的对话内容，显得比较口水，也许是微调过程中使用的语料库里，有很多「女朋友」&amp;「约会」之类的话题吧。</li></ul><h4 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h4><p>今天，以电台司令 RadioHead 的歌词「Let down and hanging around , Crushed like a bug in the ground」作为开头。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-b168eca62b699117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Rachel 捧回残花，欣喜若狂。Monica 要去戴上真戒指，在真正的笔记——手写卡片上，Monica 得知了自己继父的死亡消息（信息量有点大 –&gt; 生死婚嫁，是人类故事永恒的主题。）然后，她们是珠光宝气的女孩，要参加婚礼——谁知道是不是 Rachel 自己的。嗯，广告回来（Commercial Break），继续精彩。</li><li>更文艺的词汇，引发了 GPT-2 更富有张力的情景创作？–&gt; 继父死亡。残破的花朵。</li></ul><h4 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h4><p>今天，续写一个月前之前，6.27所生成文本的最后一句「Joey:Look, that’s great! I should’ve been there. Turns back to look」作为开头。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-44187e2c5bac3dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>云吸猫大行其道，GPT-2 自然也加入了居家必备的萌猫元素。情景是这样的，Joey 的猫要跑到屋顶，被 Rachel 拦了下来。Joey 连连拍马屁，“Rachel 你是一个厉害的女摄影家，给我拍张照吧。”Rachel 骄傲回忆，“对啊，我拍了好多照片，我经常在花园里，拍摄玫瑰（Rose）、樱花（cherry blossom）和杏树（apricot）”。正在浓情回忆之时，闯祸的 Joey 家的猫，悄悄溜走了。</li></ul><h4 id="7-31"><a href="#7-31" class="headerlink" title="7.31"></a>7.31</h4><p>今天，续写上次的剧情，最后一句「Scene: Monica, Chandler, and Phoebe’s, Rachel and Chandler, are about to make out again, and Monica walks away.」，四个人「Make out again」，画风很污，GPT2 真是敢写啊，心狠手辣。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-0e37d19bdfaf365f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这一段生成的文本，大体还是「老伙计之间絮絮叨叨的日常」，诸如「你好烦，信不信我杀了你！」、「你在干嘛啊？真的假的啊？你老是来来回回做这种事！」、「我讨厌这个女人！」</li><li>Joey 身上结霜，却亮眼不过 Chandler 的毒舌冷嘲 –&gt; “上一次她把糖吐出嘴唇是啥时候来着了？”</li></ul><h4 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h4><p>今天，开始学习音乐课程。那么，打开那个音乐黑盒子吧。 –&gt; “Open the black box of music.”</p><p>今天的场景很流畅自然啊，关于「音乐黑盒」。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-3b868dfb186a15bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Monica 在音乐黑盒子上面加冰，然后慷慨陈词，她要追梦音乐了–&gt;”虽然我永远不会在娱乐界大红大紫，但是我十分努力，虽然我不会弹钢琴，也不会写歌，但是我有一副好嗓子呢！”</p><p>嗯，这还是公然叫板Phoebe 呢，要知道，Phoebe 是距离是一个吉他弹唱达人。哈哈。</p><h4 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h4><p>今天，选了 Chrome 的插件 Momentum 的每日心灵鸡汤 –&gt; “If you have good thoughts they will shine out of your face like sunbeams and you will always look lovely.”</p><p>如果你的思想美妙，那么它们会像阳光一样，闪耀你的脸，你会永远迷人。</p><p>今日无截图，原因是 –&gt; [图片上传失败…(image-956583-1565019007282)]</p><ul><li>“They all laugh”续写第一句，似乎是四个老友对这句中二心灵鸡汤嗤之以鼻。然后，剧本迅速转场到了 Ross 带回一个叫 ELizabeth 的女孩。一如既往地，两个人絮絮叨叨，郑重其事地吵一些鸡毛蒜皮的事，但某种角度看，这些也是「爱之废语」。Love of Tosh。<br>最后，惊奇的一幕出现了，为了讨好 Elizabeth，Ross 说：“如果你对，那么 Rachel 也对。你知道，我恨她。”</li></ul><h4 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h4><p>今天，选择的是桌面背景里的金句 –&gt; “A computer is like air conditioning, it becomes useless when you open windows ”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d45e4d6fb135d474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>嗯，GPT2 调皮了一下 –&gt; 空调是不用动手打开的，虽然意念控制不了，但是可以点击遥控器。</li><li>下面的场景，挺有趣的。他们发现了一个盒子里，印着《三个火枪手》，Monica 皮了一下：“你知道为什么他们在你的公寓里挂上《三个火枪手》的海报，而不是什么《三个部落》吗？因为那些不够酷。”</li><li>Chandler 嘲讽起来，连自己都拖下水，他调戏 Joey，你不打算跟 Chandler 结婚吗?Joey也不甘示弱，Chandler 是我最爱的男人。哈哈，够腐，足够激情四射，Gay 气十足。</li></ul><h4 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h4><p>今天，用《Deep Work》的概念来开头 –&gt; “ DEEP work is the ability to spend (4or more)disconnected, uninterrupted, undistracted&amp; fully focused hours a day practicing new skills OR generating high-level output whilst leveraging an expertise”。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-5b8b23785311e5c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>如果是通用版的 GPT2，我想，它会续写一篇有模有样的高效工作笔记吧。但这是用《老友记》剧本微调过的 GPT2，所以，生成的文本都是以老友记剧本格式为主，带着主角和配角们的生活化碎片场景为主。</p></li><li><p>Phoebe 即将大婚，亲朋好友个个都要来庆祝。她一边清理房间里的个人用品。可能她有着拿朋友东西 –&gt; 然后不说的习惯。言下之意是，嗯，都那么熟了，好姐妹拿东西 –&gt; 不用吱声哒。然后，Monica 来了一句嘲讽，今早我买了一块金属板（等同于防身用的板砖？），你可以整天在家练习偷盗的艺术！</p></li><li>Joey 的正式名称是Tribbiani，意大利风味。Mrs Tribbiani是剧集里，只存在于对话之中的Joey老妈？</li><li>第一季里有过 Chandler在办公室里的场景，看来 GPT2 也发现了这个常见「模式」。写了一个司空见惯的办公室琐碎场景（因为高频出现？）。 </li></ul><h4 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h4><p>今天，笔者尝试了 音乐软件Logic从 Apple Loop 拼贴。那么，就让 GPT2 给我续写一下故事吧。 –&gt; “ Apple loop is awesome. ”。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-c7805234f55fc320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对话依然是絮絮叨叨的风格。可以启发灵感的几个点：</p><ul><li>Joey 回到老房子就餐，怀念故人。开始哭泣。印象里，真实的剧集里头，Joey 不是一个忧伤的人，他很思维相对简单，是个乐天派。哭泣的 Joey，来自他性格的另一面。</li><li>Joey 用上了纸尿布，他当了奶爸，所以是他自己生儿育女了，还是收养孤儿呢？嗯，是一种 Drama 的常规设定。</li></ul><h4 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h4><p>今天，开头是 –&gt; “ We can use Transformer in Pytorch ”，GPT2 给加了三个感叹号。哈哈。笔者笑了，笑点很奇怪。但这一次，它找到了“We can use…”句式经常接着是激动的感叹号吗？Interesting</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-848b38c4c9d84446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Transformer 是变形金刚，变形金刚会变成车。嗯。理所当然。<br>今天写的情境很魔幻啊。Phoebe 能手抓赛车？赛车旁边的鸭子，是巨型异化鸭，还能威胁到 Joey 的生命？难道这是一个物体能够任意缩小放大的异世界？</p><h4 id="8-13"><a href="#8-13" class="headerlink" title="8.13"></a>8.13</h4><p>今天，开头是 –&gt; 一句鸡汤 “ When you wake up in the morning you have two choices: go back to sleep, or wake up and chase those dreams. ”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-181e9faf5506213d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2 自相矛盾了。” She kisses his cheek “, “ Phoebe: You kissed her?”.看来，GPT2 只是机械而精准地模仿人类的文本序列，它搞不清楚人物之间的关系。这是逻辑，而不是统计。</p><h4 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h4><p>今天，开头是 –&gt; 一句音乐相关的句子 “ I like strummed acoustic.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-b2fc625dfec4544d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="i"></p><ul><li><p>GPT2 学会根据主题续写了，它写一个 Joey 做音乐的对话情景， Joey想专注音乐，但没法在真正的录音棚里做，他喜欢复杂编曲的歌曲。</p></li><li><p>只是，GPT2搞不清楚人物关系，前两句是 Joey 与 Joey「副本」 在对话。</p></li><li><p>它也学到了括号里对语气进行形容–&gt;(sarcastic)</p></li></ul><h4 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h4><p>今天， 伴随着夏夜鸣蝉声，找了霍金的名言金句，开头是 –&gt; “Look up at the stars and not down at your feet. Try to make sense of what you see, and wonder about what makes the universe exist. Be curious.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-18467d6aa08b7c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>GPT2 读了霍金关于仰望星空，脚踏实地的诗意段落之后，它写了一个老友记们的对话，关于描绘了千年以前的太阳画作。</li></ul><h4 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h4><p>今天，开头是 –&gt; 我爱深度工作 “ I love Deep Work.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-9b18b6c095e09f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>开头的文字越口水（普通），根据概率统计，GPT2 就写得很口水。几个小亮点：</p><ul><li>Chandler 要跟 Ross 去蕾丝酒吧猎奇</li><li>Monica 认为怀孕生娃是深度工作，急不来，下个月能否正常生产，未可知。</li><li>最后一句，八卦悬念升起 –&gt; Chandler 的妻子Monica 爆出惊雷，“Chandler 爱Rachel！”。GPT2在胡扯，这太狗血了。</li></ul><h4 id="8-18"><a href="#8-18" class="headerlink" title="8.18"></a>8.18</h4><p>今天，开头是 –&gt; 我爱深度工作 “ Do we need User Define Recommender?”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d232af06c0863743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个 GPT2，还挺能根据给定的句子的关键词，做远距离联想（正经脸），还好猜心（其实是凑巧？）因为笔者正在了解音乐推荐系统。这一回，它写了一个大家在茶道商店不耐烦时哼歌的情景。奇奇怪怪的组合，读起来欢乐。还挺适合情景喜剧的。</p><h4 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h4><p>今天，开头句子改编自《Digital Minimalism》扉页里，作者挚Julie的句子 –&gt;  “My Partner, My muse, My voice of reason.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-4ef18e3248ea3af7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GPT2衔接了 Monica来开头， 还挺符合故事线的，在老友记的情景之下，这理所应当是 Chandler 的妻子写给他的。画面该是如此  –&gt; 某一场浪漫剧情之后，Monica 写了信件给 Chandler，平时玩世不恭的 Chandler 读了之后，心里泛起一阵暖意，开始有点温馨而不知所措。然后，就跟GPT2 写的剧本那样，Monica 莞尔一笑，化解尴尬，牵起 Chandler 的手，说我带你出门走走吧，吹吹风，看星星啥的。</p><p>但是第二段就有点「人工智障」了。它开始狗血地写道，Monica 跟 Phoebe 分手。它分不清人物关系，这个智障缺点，经过多次的「续写」练习，是「实锤」了。</p><h4 id="8-20"><a href="#8-20" class="headerlink" title="8.20"></a>8.20</h4><p>今天，开头句子写的是「人工智能作曲 」–&gt;  “AI for Music Composition.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-112c13db913648c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>好吧，GPT2 最近总是开了好头，但是没有善始善终。<br>它一开始接着“Music”，编写了 Joey 创作音乐的句子（还衔接了之前的剧本草稿）。但是后面，就开始了天马行空（毫无逻辑）的远距离联想，一会是创作音乐片段，一会是打造一颗有屋顶的大树（木屋）。然后 Chandler 过来扯谈之后， Rachel 说，想要「礼物的礼物」，它意指的是「元礼物」吗（嘲讽脸）？</p><h4 id="8-23"><a href="#8-23" class="headerlink" title="8.23"></a>8.23</h4><p>今天，开头句子写的是人工智能先驱，赫伯特-西蒙的名言「A wealth of information creates a poverty of attention.」–&gt; “信息的富足容易导致注意力匮乏。”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-32021914f7a9dbf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>老伙计们讨论一本书《Monopoly》，中译名《大富翁》或《垄断大亨》。除了一句“为啥你把所有的金钱都投入进去”以为，都是信息量较低的对话，换句话说，这些话套在其他场景，也不显得违和。</p><p>要说，也跟 Wealth&amp;poverty&amp;Information等词语有关系。</p><h4 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h4><p>今天，第一次用对话来开头（多久了，才想到试一试用对话来做启动文本？）“Girl: You would be a good dancer except for two things. Boy: What are the two things? Girl: Your feet.”。</p><p>这是一个笑话。</p><p>女孩：“有两样东西会阻碍你成为一名出色的舞者。”<br>男孩：“哪两样东西？”<br>女孩：“你的两只脚。”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-f7f5205fce8c794b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>哈哈，GPT2 续写了两句，男孩和女孩翻脸了。<br>男孩们：“滚出去。”<br>女孩：“你们别待着这里太久。”</p><p>接着，GPT2 写出了奇葩又很污的情境。<br>Rachel 读着 Chandler 裙子背后的吊牌，Monica 对 Monica 说（自我分裂？），你想照一张你和 Chandler 裸身在众人面前的照片吗？</p><p>GPT2 太污了，辣眼睛。  = = </p><h4 id="8-27"><a href="#8-27" class="headerlink" title="8.27"></a>8.27</h4><p>今天，试用了一个限时打字的极限“危险”写作应用–&gt;“The MostDangerousWriting App, the link is <a href="https://maebert.github.io/themostdangerouswritingapp/#/”" target="_blank" rel="external">https://maebert.github.io/themostdangerouswritingapp/#/”</a></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-1dac5f482c022c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>智障文本生成器。哭笑不得的是，一开始，GPT2 没有写剧情。，而是煞有其事地在网址后面加了“u/121323”,好吧，你所使用的训练课本（英文巨型语料库），经常出现这样的序列关系对吧?嗯，真是一个超强模仿机器。</li><li>今天的剧情主要是：某某换新号码了，某某问某某，你为啥不给我打电话？亮点是：Joey 学小丑，做出在垃圾桶里捡啤酒瓶的动作。“He mimes getting a beer in the trash can.”</li></ul><h4 id="8-28"><a href="#8-28" class="headerlink" title="8.28"></a>8.28</h4><p>今天，用英文来记录了一个想法，GPT2 老友记写手自动化脚本。–&gt;“Next time, I should try an automated script that lets GPT2 write sentences at regular intervals each day, based on the last generated sentence, and push them to me automatically. Automating the boring stuff with GPT2.”</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-6060f5abeca3f3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>GPT2 是学到了一点点“语义”，它“知道”我给了一个提议，所以大家都连声附和：“好主意”。</li><li>（嘲讽语气）GPT2 大开脑洞的能力是与生俱来的啊–&gt;温文尔雅的大男人 Ross要分娩了。</li><li>Chandler 的冷不丁冒出的幽默屡见不鲜，不仅是“我感觉我已经失去了你。（I feel like I lost you.）”，在 Ross 说自己“昨天进行分娩活动……”之后，他火力全开，嘲讽道：“好啊，一个小孩要分娩了！”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019-06&quot;&gt;&lt;a href=&quot;#2019-06&quot; class=&quot;headerlink&quot; title=&quot;2019-06&quot;&gt;&lt;/a&gt;2019-06&lt;/h2&gt;&lt;h4 id=&quot;6-27&quot;&gt;&lt;a href=&quot;#6-27&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>2018 世界杯 -&gt; 看数据，猜全场最佳球员？机器学习可解释性 -&gt; 特征重要性</title>
    <link href="https://adi0229.github.io/2019/06/24/2019-06-24-fifa18eda/"/>
    <id>https://adi0229.github.io/2019/06/24/2019-06-24-fifa18eda/</id>
    <published>2019-06-24T09:08:20.114Z</published>
    <updated>2019-06-24T09:16:48.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/452087-ad8d8d0c9e5f04ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2018 男足世界杯（128 场比赛）基本统计信息</p><p>完整数据分析报告：<a href="https://github.com/adi0229/ML-DL/blob/master/fifa2018.ipynb" target="_blank" rel="external">https://github.com/adi0229/ML-DL/blob/master/fifa2018.ipynb</a></p><h3 id="数据特征包含："><a href="#数据特征包含：" class="headerlink" title="数据特征包含："></a>数据特征包含：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Index([&apos;Date&apos;, &apos;Team&apos;, &apos;Opponent&apos;, &apos;Goal Scored&apos;, &apos;Ball Possession %&apos;,</div><div class="line">       &apos;Attempts&apos;, &apos;On-Target&apos;, &apos;Off-Target&apos;, &apos;Blocked&apos;, &apos;Corners&apos;, &apos;Offsides&apos;,</div><div class="line">       &apos;Free Kicks&apos;, &apos;Saves&apos;, &apos;Pass Accuracy %&apos;, &apos;Passes&apos;,</div><div class="line">       &apos;Distance Covered (Kms)&apos;, &apos;Fouls Committed&apos;, &apos;Yellow Card&apos;,</div><div class="line">       &apos;Yellow &amp; Red&apos;, &apos;Red&apos;, &apos;Man of the Match&apos;, &apos;1st Goal&apos;, &apos;Round&apos;, &apos;PSO&apos;,</div><div class="line">       &apos;Goals in PSO&apos;, &apos;Own goals&apos;, &apos;Own goal Time&apos;],</div><div class="line">      dtype=&apos;object&apos;)</div></pre></td></tr></table></figure><h3 id="随机森林分类器（Baseline）及特征重要性"><a href="#随机森林分类器（Baseline）及特征重要性" class="headerlink" title="随机森林分类器（Baseline）及特征重要性"></a>随机森林分类器（Baseline）及特征重要性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import pandas as pd</div><div class="line">from sklearn.model_selection import train_test_split</div><div class="line">from sklearn.ensemble import RandomForestClassifier</div><div class="line"></div><div class="line"></div><div class="line">data = pd.read_csv(path + &apos;FIFA_2018_Statistics.csv&apos;)</div><div class="line"></div><div class="line">y = (data[&apos;Man of the Match&apos;] == &quot;Yes&quot;)  </div><div class="line"></div><div class="line"># 特征工程 -&gt; 选取numerical类数值作为训练特征</div><div class="line"></div><div class="line">feature_names = [i for i in data.columns if data[i].dtype in [np.int64]]</div><div class="line"></div><div class="line">X = data[feature_names]</div><div class="line"></div><div class="line">train_X, val_X, train_y, val_y = train_test_split(X, y, random_state=1)</div><div class="line"></div><div class="line">rf = RandomForestClassifier(random_state=0).fit(train_X, train_y)</div><div class="line"></div><div class="line">from sklearn.metrics import accuracy_score</div><div class="line"></div><div class="line">predictions = rf.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.59375</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import eli5</div><div class="line">from eli5.sklearn import PermutationImportance</div><div class="line"></div><div class="line">perm = PermutationImportance(rf, random_state=1).fit(val_X, val_y)</div><div class="line">eli5.show_weights(perm, feature_names = val_X.columns.tolist())</div></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/452087-837533ba4cf64c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="随机森林分类器（微调）及特征重要性变化"><a href="#随机森林分类器（微调）及特征重要性变化" class="headerlink" title="随机森林分类器（微调）及特征重要性变化"></a>随机森林分类器（微调）及特征重要性变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rf = RandomForestClassifier(random_state=0,n_estimators=500).fit(train_X, train_y)</div><div class="line"></div><div class="line">predictions = rf.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.71875</div></pre></td></tr></table></figure><p>分析：「随机森林」准确率（60% - 72%）提升之后</p><ul><li><p>扑救、传球准确率、射门命中率的重要性上升</p></li><li><p>角球、全场跑动距离的重要性下降</p><p>符合足球战术常识</p></li></ul><h3 id="Xgboost-分类器（微调）及特征重要性"><a href="#Xgboost-分类器（微调）及特征重要性" class="headerlink" title="Xgboost 分类器（微调）及特征重要性"></a>Xgboost 分类器（微调）及特征重要性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from xgboost import XGBRFClassifier</div><div class="line"></div><div class="line">xgb = XGBRFClassifier(silent=False, </div><div class="line">                      scale_pos_weight=1,</div><div class="line">                      learning_rate=0.01,  </div><div class="line">                      colsample_bytree = 0.4,</div><div class="line">                      subsample = 0.8, </div><div class="line">                      n_estimators=1000, </div><div class="line">                      reg_alpha = 0.3,</div><div class="line">                      max_depth=4, </div><div class="line">                      gamma=10).fit(train_X, train_y)</div><div class="line"></div><div class="line">predictions = xgb.predict(val_X)</div><div class="line">print(&quot;accuracy_score: &quot; + str(accuracy_score(predictions, val_y)))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">accuracy_score: 0.71875</div></pre></td></tr></table></figure><p>Xgboost发现进球是唯一重要特征。<br>简单粗暴，也更符合足球常理。进球多，更容易获胜，获胜一方容易出 MVP 球员。其他数据的关系并不大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perm_xgb = PermutationImportance(xgb, random_state=1).fit(val_X, val_y)</div><div class="line">eli5.show_weights(perm_xgb, feature_names = val_X.columns.tolist())</div></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-e34d1c02dcd6787f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>特征重要性（Permutation Importance）</p><p>Ref: <a href="https://eli5.readthedocs.io/en/latest/blackbox/permutation_importance.html?highlight=PermutationImportance" target="_blank" rel="external">https://eli5.readthedocs.io/en/latest/blackbox/permutation_importance.html?highlight=PermutationImportance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/452087-ad8d8d0c9e5f04ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
      <category term="技术, 机器学习" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>百事可乐 Or 可口可乐？深度学习图片分类器部署</title>
    <link href="https://adi0229.github.io/2019/06/18/2019-06-24-cola-image-clf/"/>
    <id>https://adi0229.github.io/2019/06/18/2019-06-24-cola-image-clf/</id>
    <published>2019-06-18T04:23:12.000Z</published>
    <updated>2019-06-24T09:38:57.557Z</updated>
    
    <content type="html"><![CDATA[<p>简单的可乐图片分类器 Web 部署，根据 fastai MOOC 2019 版制作。</p><p>URL 地址：<a href="https://adi-pic.onrender.com/" target="_blank" rel="external">https://adi-pic.onrender.com/</a></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-3b757a8ab88b172a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百事可乐"></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-17499fdd67485562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可口可乐"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的可乐图片分类器 Web 部署，根据 fastai MOOC 2019 版制作。&lt;/p&gt;
&lt;p&gt;URL 地址：&lt;a href=&quot;https://adi-pic.onrender.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://a
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>「ML 笔记」- 假阳性&amp;假阴性</title>
    <link href="https://adi0229.github.io/2019/06/07/2019-06-07-ml-fp-fn/"/>
    <id>https://adi0229.github.io/2019/06/07/2019-06-07-ml-fp-fn/</id>
    <published>2019-06-07T15:35:23.000Z</published>
    <updated>2019-07-11T07:23:35.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题：机器学习里，什么是假阳性，什么是假阴性？"><a href="#问题：机器学习里，什么是假阳性，什么是假阴性？" class="headerlink" title="问题：机器学习里，什么是假阳性，什么是假阴性？"></a>问题：机器学习里，什么是假阳性，什么是假阴性？</h1><blockquote><p>学习ing，在机器学习之旅，麻省博士小姐姐带我 ︿(￣︶￣)︿</p></blockquote><p>曾经，在 python 的机器学习开源库 sklearn 的混淆矩阵模块 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" target="_blank" rel="external">scikit-learn-confusion_matrix</a> 里，笔者常常看<code>tn</code>, <code>fp</code>, <code>fn</code>, <code>tp</code>等缩写变量，百思不得其解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tn, fp, fn, tp = confusion_matrix([0, 1, 0, 1], [1, 1, 1, 0]).ravel()</div><div class="line">&gt;&gt;&gt; (tn, fp, fn, tp)</div><div class="line">(0, 2, 1, 1)</div></pre></td></tr></table></figure></p><p>如下图，检索得到的网络资料，专业论述严谨准确，但解释起来冷冰冰，对我而言，仍然显得晦涩</p><blockquote><p>混淆表格（有时候也称为混淆矩阵），是由false positives，falsenegatives，true positives和true negatives组成的两行两列的表格。<br><img src="https://upload-images.jianshu.io/upload_images/452087-85ccefae584f7319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/452087-0152fc1d4e7b9fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>True positive (TP) ：真实为P，预测为P<br>True negative (TN): 真实为N，预测为N<br>False positive (FP)：真实为N，预测为P<br>False negative (FN)：真实为P，预测为N</p></blockquote><p>包括博客文章里解释的「猫狗识别分类」例子，听过之后，笔者依然「一头雾水」。</p><p>看过这个视频之后，豁然开朗。</p><p><a href="https://www.youtube.com/watch?v=Ivc8c9ijWIQ" target="_blank" rel="external">ML Basics: False Positives, False Negatives</a></p><p><img src="https://upload-images.jianshu.io/upload_images/452087-ec97920487dfdf56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="回答：假阳性False-Positives-amp-假阴性False-Negatives"><a href="#回答：假阳性False-Positives-amp-假阴性False-Negatives" class="headerlink" title="回答：假阳性False Positives&amp;假阴性False Negatives"></a>回答：假阳性False Positives&amp;假阴性False Negatives</h1><p>快乐学习，从形象的例子开始。</p><p>假设：给你一百张图片。让你来判断 -&gt; 每张图片中是否有人类？</p><p>这个任务需要预测两种情况——有人&amp;没人，叫做二元分类。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-53b15fbdff30e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>图片里有人，你识别「有人」——叫做「真阳性(True positive)」</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-9e11ab4508d3ee0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>图片里没人，你识别「没人」——叫做「真阴性(True negative)」<br><img src="https://upload-images.jianshu.io/upload_images/452087-250e40bbe0e8ca2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>图片里没人，你识别「有人」——叫做「假阳性(False postive)」<br><img src="https://upload-images.jianshu.io/upload_images/452087-6f3ad1036400de98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>图片里有人，你识别「没人」——叫做「假阴性(False negative)」</p></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>预测正确，以「True」开头。</li><li>预测错误，以「False」开头。</li><li>预测结果是阳性（比如「有人」、「患病」），以「 postive」结尾。</li><li>预测结果是阴性（比如「没人」、「无病」），以「 negative」结尾。</li></ul><h3 id="术语：准确率（Accuracy）"><a href="#术语：准确率（Accuracy）" class="headerlink" title="术语：准确率（Accuracy）"></a>术语：准确率（Accuracy）</h3><p><img src="https://upload-images.jianshu.io/upload_images/452087-1f2993d2e211ae53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>正确识别的图片的百分数——准确率（Accuracy）= TP+TN / TP+TN+FP+FN</p><h3 id="误区：TP-amp-TN-比-FP-amp-FN-更重要"><a href="#误区：TP-amp-TN-比-FP-amp-FN-更重要" class="headerlink" title="误区：TP&amp;TN 比 FP&amp;FN 更重要"></a>误区：TP&amp;TN 比 FP&amp;FN 更重要</h3><p>比如，在医学影像诊断疾病的应用中。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-45c6976689334aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于没有疾病的监测者，预测 TA 可能有病，需要进一步检查。这个无伤大雅。<br>但对于患病的监测者，预测 TA 没有疾病风险，那就是严重问题。</p><p>我们会更关注「假阴性率（False Negative Rate）」 = FN/FN+FP<br>换句话说，我们关注——对于多少包含患病风险的检测者，我们预测错误的比例是多少？</p><p>在安全防护领域，「假阳性率」需要关注：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-1ac9ab3229a8e5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于，自己手机的指纹识别功能，识别错了自己的指纹，这是「假阴性」，几秒钟之内多按几次，也能解锁手机，那也还好。<br>但如果，用别人的指纹，也能解锁你的手机。那就问题严重了，这是「假阳性」。</p><p>这个例子里，我们会更关注「假阳性率（False Postive Rate）」 = FP/FP+TN。换句话说，我们关注——对于多少不是本机主人指纹的打开尝试，我们预测错误的比例是多少？</p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>在智能医疗领域，比如患病风险监测的应用，我们会更关注「假阴性率（False Postive Rate）」，对于多少包含患病风险的检测者，我们预测错误的比例是多少？备注：阴性定义是——检测者没有患病风险，无需进一步检查。</li><li>在安全防护领域，比如指纹解锁功能，我们会更关注「假阳性率（False Postive Rate）」，对于多少不是本机主人指纹的打开尝试，我们预测错误的比例是多少？备注：阳性定义是——指纹是本机主人的。</li></ul><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>19.06.07 init<br>19.07.11 publish</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：机器学习里，什么是假阳性，什么是假阴性？&quot;&gt;&lt;a href=&quot;#问题：机器学习里，什么是假阳性，什么是假阴性？&quot; class=&quot;headerlink&quot; title=&quot;问题：机器学习里，什么是假阳性，什么是假阴性？&quot;&gt;&lt;/a&gt;问题：机器学习里，什么是假阳性，什
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>「ML笔记」- 机器学习生命周期（Machine Learning Lifecycle）</title>
    <link href="https://adi0229.github.io/2019/05/13/2019-05-13-ml-lifecyle/"/>
    <id>https://adi0229.github.io/2019/05/13/2019-05-13-ml-lifecyle/</id>
    <published>2019-05-13T05:34:21.000Z</published>
    <updated>2019-07-09T07:59:58.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h4 id="问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。"><a href="#问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。" class="headerlink" title="问题：公众视角 -&gt; 机器学习是「黑盒&amp;黑魔法」。"></a>问题：公众视角 -&gt; 机器学习是「黑盒&amp;黑魔法」。</h4><p>一些研究调查表明，尽管机器学习技术以及渗透到了各行各业的应用之中，但公众对机器学习知之甚少。</p><p>2017 年The Royal Society对英国普通大众进行采访，发现大部分被试对机器学习“一无所知”。虽然大部分人都知道一些采用了机器学习的科技应用，但是他们不知道机器学习如何运作，就算是比较宽泛的概念也不了解。</p><p>另一项调研，对机器学习项目里的 UX 设计师进行了调查，发现他们对机器学习也缺乏常识了解。其中一位被试，TA 把机器学习看做「黑魔法」，TA 表示：“设计师不理解科技的「边界限制」以及如何合理地应用它。”</p><p>传送门：<a href="https://mltidbits.github.io/aboutus.html" target="_blank" rel="external">mltidbits小姐姐们自我简介</a></p><h4 id="问题：机器学习从业者-gt-缺乏人种多样性-gt-「女性-amp-黑人」是少数派"><a href="#问题：机器学习从业者-gt-缺乏人种多样性-gt-「女性-amp-黑人」是少数派" class="headerlink" title="问题：机器学习从业者-&gt; 缺乏人种多样性 -&gt; 「女性&amp;黑人」是少数派"></a>问题：机器学习从业者-&gt; 缺乏人种多样性 -&gt; 「女性&amp;黑人」是少数派</h4><ul><li>2018 年，在 21 个机器学习学术会议中，仅有 18%的第一作者是女性。</li><li>黑人在谷歌员工中占比 2.5%。</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在油管的ML Tidbits频道，2位麻省AI相关专业的女博士，通过视频来阐释机器学习的整个工作循环周期，内容通俗易懂且有趣，通过此举，她们致力于减少公众对机器学习的理解偏差，以及提升机器学习相关从业人士的背景多样性。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-8548308bb6edbc70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>视频传送门：<a href="https://www.youtube.com/watch?v=ZmBUnJ7lGvQ" target="_blank" rel="external">https://www.youtube.com/watch?v=ZmBUnJ7lGvQ</a></p><h1 id="总流程：机器学习生命周期"><a href="#总流程：机器学习生命周期" class="headerlink" title="总流程：机器学习生命周期"></a>总流程：机器学习生命周期</h1><p><img src="https://upload-images.jianshu.io/upload_images/452087-31738854d768981d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>定义问题（Problem Definition） -&gt; 数据收集(Data Collection) -&gt; 数据分割(Dataset Spit up) -&gt; 模型训练(Model Training) -&gt; 模型评估(Model Evaluation) -&gt; 应用部署(System Deployment) -&gt; 改变世界(Impact the world)！</p><h1 id="例子-gt-一个类似朋友圈的-APP"><a href="#例子-gt-一个类似朋友圈的-APP" class="headerlink" title="例子 -&gt; 一个类似朋友圈的 APP"></a>例子 -&gt; 一个类似朋友圈的 APP</h1><p>MIT 的博士2位小姐姐，通过介绍一个有趣好懂的例子，来讲解机器学习应用的全流程。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-9b16f71f759b66cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设: 你有一个点子，想要为朋友们做一个类似微信朋友圈的APP</p><ul><li>这个 APP，采用机器学习技术（图片分类 -&gt; 人脸情绪识别）<ul><li>根据他们上传的照片，判断TA是不是心情悲伤。</li><li>如果判断TA心情悲伤，给TA发送提示消息，让TA给朋友打语音电话，或者发送一张萌图给 TA<ul><li>默认假设：看了萌图，你的朋友更容易高兴起来。</li></ul></li></ul></li></ul><p>问题来了：</p><ul><li>如何创建这个机器学习应用系统？</li><li>相应的道德问题有哪些？如何处理？</li></ul><h4 id="1-定义问题-Problem-Definition"><a href="#1-定义问题-Problem-Definition" class="headerlink" title="1.定义问题(Problem Definition)"></a>1.定义问题(Problem Definition)</h4><p><img src="https://upload-images.jianshu.io/upload_images/452087-0ec8b714e911488e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从点子 -&gt; 应用，需要走过很长的流程啊。</p><ul><li>定义问题</li></ul><p>首先，我们需要定义待解决的问题，明确问题的可操作性定义。<br>然后，问题明确之后，相关的团队成员才能协同开展工作，整个团队可以围绕着同一个目标，朝着同一个轨道在前进。</p><p>根据本次例子中的产品逻辑，使用机器学习术语来表述，这个问题定义该为「二元分类」任务。也就说，我们让电脑来预测情绪，你的朋友上传的照片是否体现了 TA 有着悲伤情绪，这里包含两个情况，也就是两种分类，因此称为「二元分类」任务。</p><ul><li>问题假设</li></ul><p>同时，我们需要对情绪下一个可操作性定义，这样，在后续工作中，我们才能确认数据集图片样本对应的标签，是准确无误的。<br>比如什么是悲伤，什么是不悲伤，如何定义，如何判断？如果是复合情绪呢？本例中，我们假设人们只有 2 种情绪，悲伤或不悲伤。这样做，牺牲了对复合情绪的考虑。（当然，有人可以既悲伤又高兴，或者看起来悲伤，其实内心狂喜。同时，如果脸部表情不能准确呈现用户内心情绪呢？（根据莉莎.巴瑞特教授的「情绪建构论」）。</p><ul><li>问题限制</li></ul><p>本例中，我们本能地「假设」，根据用户上传的照片（包含 TA的影像），我们可以判断用户的情绪。现实世界中，这个假设成立吗？如何界定对假设的置信度？</p><p>总之，模型难以完美，要有妥协。</p><p>如果悲伤的人，上传照片之后，收看了萌图，或者得到提示，给朋友打了一通语音电话，心情变好了，那不就是实现了初心吗？</p><h4 id="2-数据收集（Data-Collection）"><a href="#2-数据收集（Data-Collection）" class="headerlink" title="2. 数据收集（Data Collection）"></a>2. 数据收集（Data Collection）</h4><ul><li>第一步：总体定义</li></ul><p>从哪些用户总体（Population）收集数据？用来做什么？</p><p>若用户总体不具有代表性，那么机器从数据集中学到的特征，也是没有代表性的，实际的模型应用表现，会很差劲。</p><p>样本群体需要如何从用户总体中获取，他们之间的相似度及差别是什么？<br>用户总体数量需要多少，也就是说，多少人你需要考虑顾及到？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-061f33696dc08fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>第二步：特征衡量</li></ul><blockquote><p>你无法管理你不能衡量的东西 – [Morris A. Cohen]<br>You can’t manage things you can’t measure</p></blockquote><p>考虑下列问题：</p><ul><li>我们假设，要从总体用户群中手机照片图片，那么，在总体中，他们的照片（自拍/他拍）的质量是否稳定可靠？</li><li>是否收集其他信息 -&gt; 用户人口学特征（性别/年龄/坐标等）？</li><li>是否需要收集标签（label）？本例中，图片的标签类别分为悲伤（sad）或不悲伤（not sad）</li><li>标签如何收集？拍照时做调研，或者找专业人员来手工标注？注意，务必评估标签的准确程度，包括偏差（bias，有些标签存在争议。）乃至错误的比率。</li><li>样本平衡。每种标签类别都有足够的样本数，以及比例均衡。本例中，悲伤和不悲伤的标签数目应该是五五开。这样，模型才能充分学习到图片中的人物悲伤与否的视觉特征。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-c5d93bbb487f0e5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>接着，数据科学&amp;机器学习工作的脏话累活到了。</p><p>这一步叫做「数据预处理」。（以下省略数十万字）<br>本例中，数据预处理或许是图片处理成为一致的大小和分辨率。</p><ul><li>数据收集（其他可选方法）：</li></ul><p>获取开源数据集。例如，我们在网上找到已经处理好的数据集，对图片进行了是否在微笑的标注。为了能处理我们的任务，我们可以-&gt;转换标签–&gt;微笑/不微笑 -&gt; 不悲伤/悲伤</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d7265ad3602d92a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>同时，需要验证数据是否可靠：</p><p>这个公开数据集，是否可信？数据是如何收集的，总体是多少？是否很好的测量？是否适合我们的任务？</p><p>有时候，根据手头可用数据及标签，我们会迭代&amp;修正初始的「问题定义」。也就是说，重新定义问题（Redefine Problem）。此外，真实的机器学习工作流，并不是一个顺时针不变的进程，流程有时会根据现实变化，反复回溯修改，这是一个螺旋式进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-431376e7018762af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="3-数据集分割"><a href="#3-数据集分割" class="headerlink" title="3.数据集分割"></a>3.数据集分割</h4><p>数据收集完毕之后，我们需要分割数据集，一般会把数据集分成三份：训练集-验证集-测试集。</p><p>训练集：模型学习数据特征的那部分，数量占比最大。类似我们考试时，做的常规习题<br>验证集：模型做常规习题之后，会做模拟题，比如高考前每月进行月考模拟考，以此来评估日常学习的效果。<br>测试集：模型学习了训练集及在验证集评估之后，类似于真正一锤定音的高考题目。需要真刀真枪地在一些它没有学习过的题目上，进行预测分类等任务。</p><h4 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4.  定义模型"></a>4.  定义模型</h4><p>前期的数据准备好了之后，万事俱备只欠东风。这时候，就是「机器」学习的时候了。</p><p>模型结构，需要根据数据类型来搭建。比如，如果你的数据是时序数据（timeseries），那么你最好选择擅长学习时序关系的模型架构。</p><p>常见的数据结构类型：</p><p>文本数据（text）<br>结构数据（tabular）<br>图片数据（image）</p><p>本例中，对于图片数据，卷积神经网络是当前最合适的。卷积神经网络的简易应用，参见笔记[旧调重弹—— Fastai-v3版尝鲜之猫狗图片识别(<a href="https://www.jianshu.com/p/7f315d0482a4" target="_blank" rel="external">https://www.jianshu.com/p/7f315d0482a4</a>)</p><p>模型结构的深度及广度，不是越高级越复杂越好，针对具体的数据集，合适就好。<br>对于简单的数据集，模型无需太复杂。<br>对于复杂的数据集，模型不能太简单。</p><p>如何微调模型的结构和参数等，目前更多地依靠数据科学家们的直觉经验，更像一门艺术，而非严谨的科学。fastai创始人Jeremy曾解释过，他都是根据经验法则（Rule of Thumb）来选择超参数（HyperParameters）中的学习率（LearningRate）的。</p><h4 id="5-训练模型"><a href="#5-训练模型" class="headerlink" title="5.   训练模型"></a>5.   训练模型</h4><ul><li>不同模型，有着不同的步骤来优化表现。例如，神经网络反向传播技术（BackPropagation）来迭代模型各层的权重来优化模型整体表现。</li><li>通过对比评估在验证集上的表现，我们可以选择最优的模型结构，选择训练时长。（比如，在过拟合之前停止训练。）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-af5f63dbeb9a0659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="6-评估模型"><a href="#6-评估模型" class="headerlink" title="6.   评估模型"></a>6.   评估模型</h4><ul><li>测试集。模型训练完毕之后，我们可以在测试集上评估其整体表现。</li><li>基准（benchmark）数据集。我们可以在公开的基准数据集上测试，以对比我们与其他模型的性能。别忘了「交叉验证」思维，同时，需要对基准数据集的是否可靠进行评估。</li><li>衡量模型的指标。针对不同任务，我们需要选择不同的指标（metrics）来评估模型。如果你了解「真阳性（True Positive）」、「False Negative（假阴性）」等概念，那么，在本例中，你应该明白，模型预测时出现了太多的「假阳性」的错误判断，并不是那么重要，因为如果你的朋友并不悲伤，但是给 TA 发送萌图，也并不影响，这是锦上添花。但是如果模型有太多的「假阴性（False Negative）」，那就表现差劲了，因为，我们不想错失那些上传了在图片里表现悲伤的朋友们。所以，我们更密切关注「 假阴性率（False Negative Rate）」这一指标。</li><li>评估模型在不同用户群（sub-group）中的表现，我们需要保证，在不同的用户分群中，模型的表现都是一致的。比如，如果训练集的图片，大多来自女性，那么在预测其他性别朋友的图片时，模型的表现会很差。在部署模型前，我们需要测试，及时发现这些表现不均衡的问题。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/452087-de52b9f123eb97ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="7-应用部署"><a href="#7-应用部署" class="headerlink" title="7.   应用部署"></a>7.   应用部署</h4><ul><li>第一步</li></ul><p>为了确保模型高效及正确地部署到现实世界，请考虑模型的外在呈现：</p><p>用户交互界面如何设计？模型预测结果如何在界面中视觉化呈现？<br>如何让用户上传图片？是否需要考虑相应地调整亮度？<br>如何获取用户实时反馈：如果某些图片中的用户情绪，我们的模型预测错了，如何收集这些错误的例子？</p><ul><li>第二步</li></ul><p>假如，这个产品原型冷启动之后，在朋友之间大受欢迎，我们想要提升（Scale it up）用户规模和群体。请考虑如何 适配新增的用户群：</p><ul><li>新增用户群：其他用户群？比如，老年人&amp;小孩，模型是否还适用？是否需要新增关于「老年人」&amp;「小孩」的数据集？甚至邀请「老年人」来做用研测试？</li><li>与利益相关者沟通：随着应用的影响力范围规模增大，更多的利益相关者会参与进来，如何协同平衡各方的利益？</li><li>用户隐私&amp;数据知情权：用户数据如何收集？如何使用？本例中，最开始，我们假设用户都知道了他们的图片会被收集，但如果我们提升了用户群体的规模，我们也需要让其他用户对自己的隐私数据是如何被收集/存储/处理的。</li></ul><p>当模型在现实中运转时，我们需要密切监控的表现，保证其朝着积极的方向在运行。<br>如果出现故障bugs或社会争议（比如，有人认为YouTube推荐系统存在政治偏见及用户内容的刻意诱导。<a href="https://www.fast.ai/2019/05/28/google-nyt-mohan/" target="_blank" rel="external">Was this Google Executive deeply misinformed or lying in the New York Times?</a>）</p><p>结尾鸡汤：记住，世界在变，新问题每天降临，让我们用机器学习的集体智慧，来拥抱不确定吧。</p><h1 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h1><p>2019.5.13 init<br>2019.5.15 add content<br>2019.5.17 finish draft<br>2019.7.06 edit<br>2019.7.09 publish</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h4 id=&quot;问题：公众视角-gt-机器学习是「黑盒-amp-黑魔法」。&quot;&gt;&lt;a href=&quot;#问题：公众视角-gt-机器学习是「黑盒-amp-
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>在Google Colab 中显示Plotly</title>
    <link href="https://adi0229.github.io/2019/04/10/2019-04-10-plotly-colab/"/>
    <id>https://adi0229.github.io/2019/04/10/2019-04-10-plotly-colab/</id>
    <published>2019-04-10T14:42:57.000Z</published>
    <updated>2019-04-10T14:42:54.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Google-Colab-中显示-Plotly"><a href="#在-Google-Colab-中显示-Plotly" class="headerlink" title="在 Google Colab 中显示 Plotly"></a>在 Google Colab 中显示 Plotly</h1><h2 id="Python绘图可视化工具包-Plotly"><a href="#Python绘图可视化工具包-Plotly" class="headerlink" title="Python绘图可视化工具包-Plotly"></a>Python绘图可视化工具包-Plotly</h2><p>Plotly 能够绘制交互式的数据可视化图表，提供印刷品质的图表图片。</p><p> 近日，笔者在 colab 上使用 Plotly，遇到了一个小坑，需要运行特定函数，才能在 colab 上显示 Plotly 的交互图表。</p><p>解决代码分享：</p><p><a href="https://colab.research.google.com/drive/14oudHx5e5r7hm1QcbZ24FVHXgVPD0k8f" target="_blank" rel="external">Plotly in Colab.ipynb</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import plotly.plotly as py</div><div class="line">from plotly.offline import init_notebook_mode, iplot</div><div class="line"></div><div class="line"></div><div class="line">def configure_plotly_browser_state():</div><div class="line">  import IPython</div><div class="line">  display(IPython.core.display.HTML(&apos;&apos;&apos;</div><div class="line">        &lt;script src=&quot;/static/components/requirejs/require.js&quot;&gt;&lt;/script&gt;</div><div class="line">        &lt;script&gt;</div><div class="line">          requirejs.config(&#123;</div><div class="line">            paths: &#123;</div><div class="line">              base: &apos;/static/base&apos;,</div><div class="line">              plotly: &apos;https://cdn.plot.ly/plotly-latest.min.js?noext&apos;,</div><div class="line">            &#125;,</div><div class="line">          &#125;);</div><div class="line">        &lt;/script&gt;</div><div class="line">        &apos;&apos;&apos;))</div><div class="line"></div><div class="line">configure_plotly_browser_state()</div><div class="line">init_notebook_mode(connected=False)</div></pre></td></tr></table></figure><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.04.10 init</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在-Google-Colab-中显示-Plotly&quot;&gt;&lt;a href=&quot;#在-Google-Colab-中显示-Plotly&quot; class=&quot;headerlink&quot; title=&quot;在 Google Colab 中显示 Plotly&quot;&gt;&lt;/a&gt;在 Google Co
      
    
    </summary>
    
    
      <category term="技术" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python新手练习-PyBite</title>
    <link href="https://adi0229.github.io/2019/03/02/2019-03-02-pybite/"/>
    <id>https://adi0229.github.io/2019/03/02/2019-03-02-pybite/</id>
    <published>2019-03-02T04:47:11.000Z</published>
    <updated>2019-07-19T14:59:07.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python新手练习-PyBite"><a href="#Python新手练习-PyBite" class="headerlink" title="Python新手练习-PyBite"></a>Python新手练习-PyBite</h2><h4 id="Bite-108-循环历遍可命名元祖计算总分-Loop-over-a-dict-of-namedtuples-calculating-a-total-score"><a href="#Bite-108-循环历遍可命名元祖计算总分-Loop-over-a-dict-of-namedtuples-calculating-a-total-score" class="headerlink" title="Bite 108 循环历遍可命名元祖计算总分(Loop over a dict of namedtuples calculating a total score)"></a>Bite 108 循环历遍可命名元祖计算总分(Loop over a dict of namedtuples calculating a total score)</h4><blockquote><p>有一个字典，字典中包含了不同颜色的pybite忍者腰带奖章，以及对应的分数及获得人数。需要构建一个函数，计算python所有忍者的总得分。</p></blockquote><p>知识点：</p><ul><li><code>collection</code> 的 <code>nametuple</code></li><li>列表推导式</li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"></div><div class="line">BeltStats = namedtuple(&apos;BeltStats&apos;, &apos;score ninjas&apos;)</div><div class="line"></div><div class="line">ninja_belts = &#123;&apos;yellow&apos;: BeltStats(50, 11),</div><div class="line">               &apos;orange&apos;: BeltStats(100, 7),</div><div class="line">               &apos;green&apos;: BeltStats(175, 1),</div><div class="line">               &apos;blue&apos;: BeltStats(250, 5)&#125;</div><div class="line"></div><div class="line"></div><div class="line">def get_total_points(belts=ninja_belts):</div><div class="line">    &quot;&quot;&quot;Calculate the amount of points rewarded on PyBites given the</div><div class="line">       ninja_belts dictionary, formula: belt score x belt owners (aka ninjas)</div><div class="line">       (of course there are more points but let&apos;s keep it simple)</div><div class="line"></div><div class="line">       Make your code generic so if we update ninja_belts to include</div><div class="line">       more belts (which we do in the tests) it will still work.</div><div class="line"></div><div class="line">       Ah and you can get score and ninjas from the namedtuple with nice</div><div class="line">       attribute access: belt.score / belt.ninjas (reason why we get</div><div class="line">       you familiar with namedtuple here, because we love them and use</div><div class="line">       them all over the place!)</div><div class="line">       </div><div class="line">       Return the total number of points int from the function.&quot;&quot;&quot;</div><div class="line">       </div><div class="line">       total_points = 0</div><div class="line">    </div><div class="line">    for belt in belts.values():</div><div class="line">        scores = belt.score * belt.ninjas</div><div class="line">        total_points += scores</div><div class="line">    </div><div class="line">    return total_points</div></pre></td></tr></table></figure><p>列表推导式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return sum([belt[0] * belt[1] for belt in belts.values()])</div></pre></td></tr></table></figure><h4 id="Bite-109-健身字典查询及抛出异常-Workout-dict-lookups-and-raising-an-exception"><a href="#Bite-109-健身字典查询及抛出异常-Workout-dict-lookups-and-raising-an-exception" class="headerlink" title="Bite 109 健身字典查询及抛出异常(Workout dict lookups and raising an exception)"></a>Bite 109 健身字典查询及抛出异常(Workout dict lookups and raising an exception)</h4><blockquote><p>查询健身周计划的字典，并在日期输入键值错误时，抛出异常</p></blockquote><p>知识点：</p><ul><li>抛出异常 -&gt; <code>exception</code></li><li><code>format</code></li><li><code>title()</code></li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">workout_schedule = &#123;&apos;Friday&apos;: &apos;Shoulders&apos;,</div><div class="line">                    &apos;Monday&apos;: &apos;Chest+biceps&apos;,</div><div class="line">                    &apos;Saturday&apos;: &apos;Rest&apos;,</div><div class="line">                    &apos;Sunday&apos;: &apos;Rest&apos;,</div><div class="line">                    &apos;Thursday&apos;: &apos;Legs&apos;,</div><div class="line">                    &apos;Tuesday&apos;: &apos;Back+triceps&apos;,</div><div class="line">                    &apos;Wednesday&apos;: &apos;Core&apos;&#125;</div><div class="line">rest, chill, go_train = &apos;Rest&apos;, &apos;Chill out!&apos;, &apos;Go train &#123;&#125;&apos;</div><div class="line"></div><div class="line"></div><div class="line">def get_workout_motd(day):</div><div class="line">    &quot;&quot;&quot;Title case passed in day argument (monday or MONDAY -&gt; Monday)</div><div class="line">       and check if it is in the given workout_schedule dict.</div><div class="line"></div><div class="line">       If it is there retrieve the workout, if not raise a KeyError.</div><div class="line"></div><div class="line">       Return the chill or go_train variable depending the retrieved</div><div class="line">       workout value (&apos;Rest&apos; or workout bla)</div><div class="line"></div><div class="line">       Trivia: /etc/motd is a file on Unix-like systems that contains</div><div class="line">       a &apos;message of the day&apos;&quot;&quot;&quot;</div><div class="line">    try:</div><div class="line">        workout = workout_schedule[day.title()]</div><div class="line">    except KeyError:</div><div class="line">        raise KeyError(&apos;Workout does not exist.&apos;)</div><div class="line">    return chill if workout == rest else go_train.format(workout)</div></pre></td></tr></table></figure><h4 id="Bite-110-类型转换-amp-处理异常-Type-conversion-and-exception-handling"><a href="#Bite-110-类型转换-amp-处理异常-Type-conversion-and-exception-handling" class="headerlink" title="Bite 110 类型转换&amp;处理异常(Type conversion and exception handling)"></a>Bite 110 类型转换&amp;处理异常(Type conversion and exception handling)</h4><blockquote><p>写一个函数，输入包含分子&amp;分母，把分子&amp;分母转换成整数的数据类型，然后分子除以分母。处理两种异常，输入值异常&amp;分母为零。</p></blockquote><p>知识点</p><ul><li><code>ValueError</code></li><li><code>ZeroDivisonError</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def divide_numbers(numerator, denominator):</div><div class="line">    &quot;&quot;&quot;For this exercise you can assume numerator and denominator are of type</div><div class="line">       int/str/float.</div><div class="line">       Try to convert numerator and denominator to int types, if that raises a</div><div class="line">       ValueError reraise it. Following do the division and return the result.</div><div class="line">       However if denominator is 0 catch the corresponding exception Python</div><div class="line">       throws (cannot divide by 0), and return 0&quot;&quot;&quot;</div><div class="line">    try:</div><div class="line">        numerator = int(numerator)</div><div class="line">        denominator = int(denominator)</div><div class="line">    except ValueError:</div><div class="line">        raise</div><div class="line"></div><div class="line">    try:</div><div class="line">        return numerator / denominator</div><div class="line">    except ZeroDivisionError:</div><div class="line">        return 0</div></pre></td></tr></table></figure><h4 id="Bite-1-累加-N-个数字-Sum-n-numbers"><a href="#Bite-1-累加-N-个数字-Sum-n-numbers" class="headerlink" title="Bite 1 累加 N 个数字(Sum n numbers)"></a>Bite 1 累加 N 个数字(Sum n numbers)</h4><blockquote><ul><li>输入：n个数字或者无输入</li><li>计算：将所有输入的序列元素数字相加，计算它们总数。如果没有输入数字，则返回从 1、2、3、……到 100 的总数</li><li>输出：总数</li></ul></blockquote><p>知识点</p><ul><li><code>sum</code></li><li><code>range</code></li></ul><p>思路：</p><ol><li>判断 numbers 是否是 None，如果是None,计算并返回 1……100（<code>range(1,101)</code>） 的叠加总数</li><li>如果 numbers 不是 None，计算并返回所输入的数字的叠加总数</li></ol><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def sum_numbers(numbers=None):</div><div class="line">    if numbers is None:</div><div class="line">        return sum(range(1,101))</div><div class="line">    else:</div><div class="line">        return sum(numbers)</div></pre></td></tr></table></figure><h4 id="Bite-5-解析一个列表中的名字-Parse-a-list-of-names"><a href="#Bite-5-解析一个列表中的名字-Parse-a-list-of-names" class="headerlink" title="Bite 5 解析一个列表中的名字(Parse a list of names)"></a>Bite 5 解析一个列表中的名字(Parse a list of names)</h4><blockquote><ul><li>输入：一个列表，包含一串名字的字符串</li><li>计算：1. 对名字去重 2.按照surname倒序排序 3. 获取长度最短的 firstname</li><li>输出：1.去重后的名字，每个单词首个字母大写 2. 返回排序后的名字列表 3.返回最短的首名 firstname</li></ul></blockquote><p>知识点</p><ul><li><code>sorting</code></li><li><code>min</code></li><li><code>lambda</code></li><li><code>list comprehesions</code></li></ul><p>思路：</p><ol><li>set()获取NAMES独特值(unique),（set 是 unordered）,再用列表推导式，将每一个 set 中的元素 title(), 返回列表</li><li>匿名函数 lambda x: x.split(“ “),将NAMES的元素按照空格 whitespace 拆分成 firstname surname</li><li>string[-1]切片获取列表中的倒数第一个元素</li><li><code>sorted</code>方法对元素进行排序,reverse=True(Desending order)</li><li>列表推导式，生成只包含 first name的列表。再用 min()返回最短的firstname</li></ol><p>问题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NAMES = [&apos;arnold schwarzenegger&apos;, &apos;alec baldwin&apos;, &apos;bob belderbos&apos;,</div><div class="line">         &apos;julian sequeira&apos;, &apos;sandra bullock&apos;, &apos;keanu reeves&apos;,</div><div class="line">         &apos;julbob pybites&apos;, &apos;bob belderbos&apos;, &apos;julian sequeira&apos;,</div><div class="line">         &apos;al pacino&apos;, &apos;brad pitt&apos;, &apos;matt damon&apos;, &apos;brad pitt&apos;]</div><div class="line"></div><div class="line"></div><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    pass</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    # ...</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    # ...</div></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from names import (NAMES, dedup_and_title_case_names,</div><div class="line">                   sort_by_surname_desc, shortest_first_name)</div><div class="line"></div><div class="line"></div><div class="line">def test_dedup_and_title_case_names():</div><div class="line">    names = dedup_and_title_case_names(NAMES)</div><div class="line">    assert names.count(&apos;Bob Belderbos&apos;) == 1</div><div class="line">    assert names.count(&apos;julian sequeira&apos;) == 0</div><div class="line">    assert names.count(&apos;Brad Pitt&apos;) == 1</div><div class="line">    assert len(names) == 10</div><div class="line">    assert all(n.title() in names for n in NAMES)</div><div class="line"></div><div class="line"></div><div class="line">def test_sort_by_surname_desc():</div><div class="line">    names = sort_by_surname_desc(NAMES)</div><div class="line">    assert names[0] == &apos;Julian Sequeira&apos;</div><div class="line">    assert names[-1] == &apos;Alec Baldwin&apos;</div><div class="line"></div><div class="line"></div><div class="line">def test_shortest_first_name():</div><div class="line">    assert shortest_first_name(NAMES) == &apos;Al&apos;</div></pre></td></tr></table></figure><p>解题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    return [name.title() for name in set(names)]</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return sorted(names, key = lambda x: x.split(&quot; &quot;)[-1] , reverse = True )</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return min([name.split(&quot; &quot;)[0] for name in names])</div></pre></td></tr></table></figure><p>参考答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">NAMES = [&apos;arnold schwarzenegger&apos;, &apos;alec baldwin&apos;, &apos;bob belderbos&apos;,</div><div class="line">         &apos;julian sequeira&apos;, &apos;sandra bullock&apos;, &apos;keanu reeves&apos;,</div><div class="line">         &apos;julbob pybites&apos;, &apos;bob belderbos&apos;, &apos;julian sequeira&apos;,</div><div class="line">         &apos;al pacino&apos;, &apos;brad pitt&apos;, &apos;matt damon&apos;, &apos;brad pitt&apos;]</div><div class="line"></div><div class="line"></div><div class="line">def dedup_and_title_case_names(names):</div><div class="line">    &quot;&quot;&quot;Should return a list of names, each name appears only once&quot;&quot;&quot;</div><div class="line">    return list(&#123;name.title() for name in names&#125;)</div><div class="line"></div><div class="line"></div><div class="line">def sort_by_surname_desc(names):</div><div class="line">    &quot;&quot;&quot;Returns names list sorted desc by surname&quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    return sorted(names,</div><div class="line">                  key=lambda x: x.split()[-1],</div><div class="line">                  reverse=True)</div><div class="line"></div><div class="line"></div><div class="line">def shortest_first_name(names):</div><div class="line">    &quot;&quot;&quot;Returns the shortest first name (str).</div><div class="line">       You can assume there is only one shortest name.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    names = dedup_and_title_case_names(names)</div><div class="line">    names = [name.split()[0] for name in names]</div><div class="line">    return min(names, key=len)</div></pre></td></tr></table></figure><p>缺漏处：</p><ul><li>第一个函数，用的是字典推导式。因为字典不允许重复 Key</li><li>第三个函数，min()的key参数设置为 len</li></ul><h4 id="Bite-8-调换字母顺序-Rotate-string-characters"><a href="#Bite-8-调换字母顺序-Rotate-string-characters" class="headerlink" title="Bite 8 调换字母顺序(Rotate string characters)"></a>Bite 8 调换字母顺序(Rotate string characters)</h4><blockquote><ul><li>输入：字符串string&amp;整数n</li><li>计算：若整数大于0，则将前 n 个字母调换到末尾。/ 若整数小于0，则将后n 个字母调换到末尾。</li><li>输出：调换后的字符串（rotated string）</li></ul></blockquote><p>知识点</p><ul><li><code>slice</code>切片</li><li><code>deque</code>双端队列</li></ul><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Last login: Wed Jul 10 14:50:31 on ttys004</div><div class="line">adi0229 (adi0229 *) ~</div><div class="line"></div><div class="line">&gt;&gt;&gt; string = &apos;hello&apos;</div><div class="line">&gt;&gt;&gt; string[2:] + string[:2]</div><div class="line">&apos;llohe&apos;</div><div class="line">&gt;&gt;&gt; string[-2:] + string[:-2]</div><div class="line">&apos;lohel&apos;</div></pre></td></tr></table></figure><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def rotate(string, n):</div><div class="line">    &quot;&quot;&quot;Rotate characters in a string.</div><div class="line">       Expects string and n (int) for number of characters to move.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    return string[n:] + string[:n]</div></pre></td></tr></table></figure><h4 id="Bite-15-列举-2-个序列-Enumerate-2-sequence"><a href="#Bite-15-列举-2-个序列-Enumerate-2-sequence" class="headerlink" title="Bite 15 列举 2 个序列(Enumerate 2 sequence)"></a>Bite 15 列举 2 个序列(Enumerate 2 sequence)</h4><blockquote><ul><li>输入：2 个列表，包含名字和国家字段</li><li>计算：列举2个列表的字段——名字和国家，根据索引位置，一一对应。</li><li>输出：按照索引的数字顺序，打印出对应的列表字段。</li></ul></blockquote><p>知识点</p><ul><li><code>enumerate</code>列举，枚举</li><li><code>string formatting</code>字符串格式</li></ul><p>代码实例参考</p><p><code>enumerate</code>列举，枚举</p><p><a href="https://stackoverflow.com/questions/16326853/enumerate-two-python-lists-simultaneously/16326876" target="_blank" rel="external">https://stackoverflow.com/questions/16326853/enumerate-two-python-lists-simultaneously/16326876</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for index, (value1, value2) in enumerate(zip(data1, data2)):</div><div class="line">    print index, value1 + value2</div></pre></td></tr></table></figure><ul><li><code>string formatting</code>字符串对齐</li></ul><p>在 <code>format</code>方法中，使用<code>&lt;</code>,<code>&gt;</code>,<code>^</code>等符号来指定左对齐、右对齐或者居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;&#123;1:&lt;15&#125;&#123;0:^10&#125;&#123;2:&gt;15&#125;&quot;.format(center, left_aligned, right_aligned)</div><div class="line">&apos;Left Align      Centered     Right Align&apos;</div></pre></td></tr></table></figure><p>python 3.6 的 <code>f-string</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f&quot;&#123;left_aligned:&lt;15&#125;&#123;center:^10&#125;&#123;right_aligned:&gt;15&#125;&quot;</div><div class="line">&apos;Left Align      Centered     Right Align&apos;</div></pre></td></tr></table></figure><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Last login: Wed Jul 10 14:50:31 on ttys004</div><div class="line">adi0229 (adi0229 *) ~</div><div class="line"></div><div class="line">&gt;&gt;&gt; names = &apos;Julian Bob PyBites Dante Martin Rodolfo&apos;.split()</div><div class="line">&gt;&gt;&gt; countries = &apos;Australia Spain Global Argentina USA Mexico&apos;.split()</div><div class="line">&gt;&gt;&gt; names</div><div class="line">[&apos;Julian&apos;, &apos;Bob&apos;, &apos;PyBites&apos;, &apos;Dante&apos;, &apos;Martin&apos;, &apos;Rodolfo&apos;]</div><div class="line">&gt;&gt;&gt; countries</div><div class="line">[&apos;Australia&apos;, &apos;Spain&apos;, &apos;Global&apos;, &apos;Argentina&apos;, &apos;USA&apos;, &apos;Mexico&apos;]</div></pre></td></tr></table></figure><p>解决代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">names = &apos;Julian Bob PyBites Dante Martin Rodolfo&apos;.split()</div><div class="line">countries = &apos;Australia Spain Global Argentina USA Mexico&apos;.split()</div><div class="line"></div><div class="line"></div><div class="line">def enumerate_names_countries():</div><div class="line">    &quot;&quot;&quot;Outputs:</div><div class="line">       1. Julian     Australia</div><div class="line">       2. Bob        Spain</div><div class="line">       3. PyBites    Global</div><div class="line">       4. Dante      Argentina</div><div class="line">       5. Martin     USA</div><div class="line">       6. Rodolfo    Mexico&quot;&quot;&quot;</div><div class="line">    for index, (name, country) in enumerate(zip(names, countries)):</div><div class="line">        print(&quot;&#123;0:&lt;3&#125;&#123;1:&lt;11&#125;&#123;2&#125;&quot;.format(str(index+1)+&apos;.&apos;,name,country))   </div><div class="line">        </div><div class="line">enumerate_names_countries()</div><div class="line"></div><div class="line">$ /Users/apple/anaconda3/envs/magenta/bin/python /Users/apple/Desktop/pybite_intro_08.py</div><div class="line">1. Julian     Australia</div><div class="line">2. Bob        Spain</div><div class="line">3. PyBites    Global</div><div class="line">4. Dante      Argentina</div><div class="line">5. Martin     USA</div><div class="line">6. Rodolfo    Mexico</div></pre></td></tr></table></figure><p>思路：</p><ul><li><code>zip</code>打包，name和 country2 个可迭代的列表对象</li><li>在 for 循环中，<code>enumerate</code>组合成索引序列</li><li><code>format</code>指定第二个位置左对齐 11 个chars。第一个位置是调试出来的，字符串的间距3chars？</li></ul><h4 id="Bite-16-PyBite日期生成器-PyBites-date-generator"><a href="#Bite-16-PyBite日期生成器-PyBites-date-generator" class="headerlink" title="Bite 16 PyBite日期生成器(PyBites date generator)"></a>Bite 16 PyBite日期生成器(PyBites date generator)</h4><blockquote><ul><li>输入：2 个列表，包含名字和国家字段</li><li>计算：  每年每一百天</li><li>输出：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import datetime</div><div class="line">from itertools import islice</div><div class="line"></div><div class="line">from gendates import gen_special_pybites_dates</div><div class="line"></div><div class="line"></div><div class="line">def test_gen_special_pybites_dates():</div><div class="line">    gen = gen_special_pybites_dates()</div><div class="line">    dates = list(islice(gen, 100))</div><div class="line"></div><div class="line">    expected = [datetime.datetime(2017, 3, 29, 0, 0),</div><div class="line">                datetime.datetime(2017, 7, 7, 0, 0),</div><div class="line">                datetime.datetime(2017, 10, 15, 0, 0),</div><div class="line">                datetime.datetime(2017, 12, 19, 0, 0),</div><div class="line">                datetime.datetime(2018, 1, 23, 0, 0),</div><div class="line">                datetime.datetime(2018, 5, 3, 0, 0),</div><div class="line">                datetime.datetime(2018, 8, 11, 0, 0),</div><div class="line">                datetime.datetime(2018, 11, 19, 0, 0),</div><div class="line">                datetime.datetime(2018, 12, 19, 0, 0),</div><div class="line">                datetime.datetime(2019, 2, 27, 0, 0)]</div><div class="line"></div><div class="line">    assert dates[:10] == expected</div></pre></td></tr></table></figure><p>知识点</p><ul><li><code>islice</code></li></ul><p><a href="http://funhacks.net/2017/02/13/itertools/" target="_blank" rel="external">http://funhacks.net/2017/02/13/itertools/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">islice(iterable, [start,] stop [, step])</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from itertools import count, islice</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice([10, 6, 2, 8, 1, 3, 9], 5))</div><div class="line">[10, 6, 2, 8, 1]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice(count(), 6))</div><div class="line">[0, 1, 2, 3, 4, 5]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; list(islice(count(), 3, 10))</div><div class="line">[3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; list(islice(count(), 3, 10 ,2))</div><div class="line">[3, 5, 7, 9]</div></pre></td></tr></table></figure><p>关于<code>itertool</code>里的<code>count</code></p><p>官方文档：<a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.count" target="_blank" rel="external">https://docs.python.org/zh-cn/3/library/itertools.html#itertools.count</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def count(start=0, step=1):</div><div class="line">    # count(10) --&gt; 10 11 12 13 14 ...</div><div class="line">    # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</div><div class="line">    n = start</div><div class="line">    while True:</div><div class="line">        yield n</div><div class="line">        n += step</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">itertools.count(start=0, step=1)</div></pre></td></tr></table></figure><p>可见，count()返回 0 开头，1 为步长的序列。</p><p>上面的代码块，最后一行代码解读，count()返回一个可迭代对象（），开始索引是 3，结束索引 10，step 步长是 2。<br>所以，加上list()之后，输出是[3,5,7,9]</p><p><code>datetime.datetime</code></p><p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="external">https://docs.python.org/3/library/datetime.html</a></p><p>一个<code>datetime</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)</div></pre></td></tr></table></figure><p>年月日是必需参数。测试脚本里的 2 个0，指的是小时hour和分钟minute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">PYBITES_BORN = datetime(year=2016, month=12, day=19)</div><div class="line"></div><div class="line"></div><div class="line">def gen_special_pybites_dates():</div><div class="line">    pass</div></pre></td></tr></table></figure><p><code>datetime</code></p><p><a href="https://www.guru99.com/date-time-and-datetime-classes-in-python.html#5" target="_blank" rel="external">https://www.guru99.com/date-time-and-datetime-classes-in-python.html#5</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt; datetime.today()</div><div class="line">datetime.datetime(2019, 7, 12, 19, 27, 59, 688655)</div><div class="line">&gt;&gt;&gt; from datetime import timedelta</div><div class="line">&gt;&gt;&gt; timedelta(days=100)</div><div class="line">datetime.timedelta(100)</div><div class="line">&gt;&gt;&gt; datetime.timedelta(100)</div></pre></td></tr></table></figure><p>语言问题，对题目具体要求不甚了解，代码没写出，因此直接看了答案，恍然大悟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime, timedelta</div><div class="line"></div><div class="line">PYBITES_BORN = datetime(year=2016, month=12, day=19)</div><div class="line"></div><div class="line"></div><div class="line">def gen_special_pybites_dates():</div><div class="line">    days = 0</div><div class="line">    while True:</div><div class="line">        days += 1</div><div class="line">        if days % 100 == 0 or days % 365 == 0:</div><div class="line">            yield PYBITES_BORN + timedelta(days=days)</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建 Days 变量，初始赋值 0</li><li>永久循环，每次循环迭代变量+1</li><li>当days 是 100 或者 365 的整数时，返回 PYBITES_BORN + 当前天数的时间 delta</li></ol><p>反思：</p><ul><li>查询<code>timedelta()</code>等相关函数知识，是必要的</li><li>需要强化英语语言的理解水平</li></ul><h4 id="Bite-19-写一个简单的属性-Write-a-Simple-Property"><a href="#Bite-19-写一个简单的属性-Write-a-Simple-Property" class="headerlink" title="Bite 19 写一个简单的属性(Write a Simple Property)"></a>Bite 19 写一个简单的属性(Write a Simple Property)</h4><blockquote><ul><li>输入：格式为字符串的名称（name），格式为 datetime 的过期时间（expires）</li><li>计算：当前时间，是否大于过期时间。</li><li>输出：一个名为番茄钟的类（class），包含过期与否的布尔值属性</li></ul></blockquote><p>知识点：</p><ul><li><code>datetime</code></li><li><code>properties</code></li></ul><p>一个疑问，如何指定函数参数的类型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def pick(l: list, index: int) -&gt; int:</div><div class="line">    return l[index]</div></pre></td></tr></table></figure><p>从上面的示例可知，pick 函数输入 2 个参数，一个<code>l</code>列表，一个<code>index</code>整数，输出是整数（integer）。</p><p>另一个疑问，如何传入<code>datetime</code>类型的对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">class Person:</div><div class="line"></div><div class="line">    def __init__(self, first_name, last_name, birth_date):</div><div class="line">        self.first_name = first_name</div><div class="line">        self.last_name = last_name</div><div class="line">        self.birth_date = datetime.strptime(birth_date, &apos;%b %d %Y&apos;)</div><div class="line"></div><div class="line">    def fullname(self):</div><div class="line">        return self.first + &apos; &apos; + self.last_name</div><div class="line"></div><div class="line">person = Person(&apos;John&apos;, &apos;Doe&apos;, &apos;Jun 1 2005&apos;)</div><div class="line"></div><div class="line">print(person.birth_date)</div></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2005-06-01 00:00:00</div></pre></td></tr></table></figure><p>想法：判断 -&gt; NOW(当前时间) 大于&gt; expires(过期时间),返回布尔值</p><p>解题过程：</p><p>查看datetime.now()的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; datetime.now()</div><div class="line">datetime.datetime(2019, 7, 15, 14, 13, 34, 943274)</div></pre></td></tr></table></figure><p>检索“compare date python”,获得示例代码</p><p>来源：<a href="https://www.geeksforgeeks.org/comparing-dates-python/" target="_blank" rel="external">https://www.geeksforgeeks.org/comparing-dates-python/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import datetime </div><div class="line">  </div><div class="line"># date in yyyy/mm/dd format </div><div class="line">d1 = datetime.datetime(2018, 5, 3) </div><div class="line">d2 = datetime.datetime(2018, 6, 1) </div><div class="line">  </div><div class="line"># Comparing the dates will return </div><div class="line"># either True or False </div><div class="line">print(&quot;d1 is greater than d2 : &quot;, d1 &gt; d2) </div><div class="line">print(&quot;d1 is less than d2 : &quot;, d1 &lt; d2) </div><div class="line">print(&quot;d1 is not equal to d2 : &quot;, d1 != d2)</div></pre></td></tr></table></figure><p>测试脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import timedelta</div><div class="line"></div><div class="line">from simple_property import Promo, NOW</div><div class="line"></div><div class="line"></div><div class="line">def test_promo_expired():</div><div class="line">    past_time = NOW - timedelta(seconds=3)</div><div class="line">    twitter_promo = Promo(&apos;twitter&apos;, past_time)</div><div class="line">    assert twitter_promo.expired</div><div class="line"></div><div class="line"></div><div class="line">def test_promo_not_expired():</div><div class="line">    future_date = NOW + timedelta(days=1)</div><div class="line">    newsletter_promo = Promo(&apos;newsletter&apos;, future_date)</div><div class="line">    assert not newsletter_promo.expired</div></pre></td></tr></table></figure><p>解题代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line"></div><div class="line">NOW = datetime.now()</div><div class="line"></div><div class="line"></div><div class="line">class Promo:</div><div class="line">    </div><div class="line">    def __init__(self, name, datetime):</div><div class="line">        self.name = name</div><div class="line">        self.datetime = datetime</div><div class="line">        self.expired = NOW-datetime</div></pre></td></tr></table></figure><p>显然，函数的「参数格式」以及「datetime」格式转化，在本题中不需要处理。<br>只需要 -&gt; 添加 self.expired 属性，通过判断时间大小，返回 True&amp;False 的布尔值</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-00a6dc8800bbae1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="Bite-21-查询一个嵌入式数据结构-Query-a-nested-data-structure"><a href="#Bite-21-查询一个嵌入式数据结构-Query-a-nested-data-structure" class="headerlink" title="Bite 21 查询一个嵌入式数据结构(Query a nested data structure)"></a>Bite 21 查询一个嵌入式数据结构(Query a nested data structure)</h4><blockquote><ul><li>输入：一个<code>cars</code>字典</li><li>计算：1、根据字符的 key，获取value 2、匹配字符串 3、根据阿拉伯字母顺序排序</li><li>输出：1、所有 jeeps 的模型名称 2、获取每个制造商的第一种车型 3、获取所有名称中包含字符串<code>Trail</code>的车型 3、按照阿拉伯字母对车型字典中的值进行排序</li><li>根据论坛讨论，2018.12.18日的讨论，每个函数都传入 cars 字典作为局部变量(Scope local)，这样写法更好。</li></ul></blockquote><p>知识点</p><ul><li><code>dictionary comprehesions</code></li><li><a href="https://stackoverflow.com/questions/14032521/python-data-structure-sort-list-alphabetically" target="_blank" rel="external"><code>sorted</code></a></li><li></li></ul><p>任务 1</p><p>获取所有 jeeps 的型号名称，返回相应字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def get_all_jeeps(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a comma  + space (&apos;, &apos;) separated string of jeep models</div><div class="line">       (original order)&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>思路：</p><p><code>join()</code>将序列中的元素以指定字符串连接生成新的字符串,输出：’, ‘（逗号+空格）分割的 Jeep models（吉普车型号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.join(sequence)</div></pre></td></tr></table></figure><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def get_all_jeeps(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a comma  + space (&apos;, &apos;) separated string of jeep models</div><div class="line">       (original order)&quot;&quot;&quot;</div><div class="line">    </div><div class="line">    # print(&apos;, &apos;.join(cars[&apos;Jeep&apos;]))</div><div class="line"></div><div class="line">    return &apos;, &apos;.join(cars[&apos;Jeep&apos;])</div><div class="line"></div><div class="line">get_all_jeeps()</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Grand Cherokee, Cherokee, Trailhawk, Trackhawk</div></pre></td></tr></table></figure><p>任务 2</p><p>获取所有制造商的第一个车型名称,返回相应列表 list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def get_first_model_each_manufacturer(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a list of matching models (original ordering)&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    grep_list = []</div><div class="line"></div><div class="line">    for models in cars.values():</div><div class="line">        for model in models:</div><div class="line">            if grep.casefold() in model.casefold():</div><div class="line">                grep_list.append(model)</div><div class="line">    return sorted(grep_list)</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;Falcon&apos;, &apos;Commodore&apos;, &apos;Maxima&apos;, &apos;Civic&apos;, &apos;Grand Cherokee&apos;]</div></pre></td></tr></table></figure><p>任务 3</p><p>获取所有包含某段字符串（本例是<code>trail</code>）的型号名称，按照阿拉伯字母顺序排序，返回相应列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建一个空的列表</li><li>使用<code>in</code>运算符,历遍所有字典中的values(注：case-insensitive,意思是大小写不敏感，所以用<a href="https://stackoverflow.com/questions/319426/how-do-i-do-a-case-insensitive-string-comparison" target="_blank" rel="external"><code>casefold()</code></a>转换),判断其对应的字符串中，是否包含grep所对应的’trail’字符串</li><li>如果包含’trail’添加入空列表之中，最后，按照阿拉伯字母排序(注：sorted(list),如果列表元素是数字，那么默认是按照增序排序。如果列表元素是字符串，则按照字母顺序（alphabetical order）排序）。</li></ol><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line">    grep_list = []</div><div class="line"></div><div class="line">    for models in cars.values():</div><div class="line">        for model in models:</div><div class="line">            if grep.casefold() in model.casefold():</div><div class="line">                grep_list.append(model)</div><div class="line">    return sorted(grep_list)</div></pre></td></tr></table></figure><p>终端输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&apos;Trailblazer&apos;, &apos;Trailhawk&apos;]</div><div class="line">[&apos;Accord&apos;, &apos;Commodore&apos;, &apos;Falcon&apos;]</div></pre></td></tr></table></figure><p>任务 4</p><p>获取型号名称，按照阿拉伯字母顺序排序，返回相应字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_all_matching_models(cars=cars, grep=&apos;trail&apos;):</div><div class="line">    &quot;&quot;&quot;return a list of all models containing the case insensitive</div><div class="line">       &apos;grep&apos; string which defaults to &apos;trail&apos; for this exercise,</div><div class="line">       sort the resulting sequence alphabetically&quot;&quot;&quot;</div><div class="line"> pass</div></pre></td></tr></table></figure><p>思路：</p><ol><li>新建一个空的字典</li><li>历遍<code>cars</code>字典，获取它的所有键值</li><li>按照所有键值，添加入新字典，并使用<code>sorted</code>方法来重新按字母排序 value 里的元素。</li></ol><p>解题代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def sort_car_models(cars=cars):</div><div class="line">    &quot;&quot;&quot;return a copy of the cars dict with the car models (values)</div><div class="line">       sorted alphabetically&quot;&quot;&quot;</div><div class="line">    cars_sorted = &#123;&#125;</div><div class="line"></div><div class="line">    for key, value  in cars.items():</div><div class="line">        cars_sorted[key] = sorted(value)</div><div class="line"></div><div class="line">    return cars_sorted</div></pre></td></tr></table></figure><p>最后通关成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-fb97cd300fedd548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>小结：</p><ul><li>Debug 时，务必查看<code>test_cars.py</code>,里面详细写明了代码是如何得到验证的，也熟悉了 asert。在任务三时，发现会另外传入一个’CO’，包含大写字母的字符串。这时候，把原来的变量grep“加上<code>casefold</code>便通过测试了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">from cars import (get_all_jeeps, get_first_model_each_manufacturer,</div><div class="line">                  get_all_matching_models, sort_car_models)</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_jeeps():</div><div class="line">    expected = &apos;Grand Cherokee, Cherokee, Trailhawk, Trackhawk&apos;</div><div class="line">    actual = get_all_jeeps()</div><div class="line">    assert type(actual) == str</div><div class="line">    assert actual == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_first_model_each_manufacturer():</div><div class="line">    actual = get_first_model_each_manufacturer()</div><div class="line">    expected = [&apos;Falcon&apos;, &apos;Commodore&apos;, &apos;Maxima&apos;, &apos;Civic&apos;, &apos;Grand Cherokee&apos;]</div><div class="line">    assert actual == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_matching_models_default_grep():</div><div class="line">    expected = [&apos;Trailblazer&apos;, &apos;Trailhawk&apos;]</div><div class="line">    # sorting requirement might be missed and is not essential for this method</div><div class="line">    assert sorted(get_all_matching_models()) == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_get_all_matching_models_different_grep():</div><div class="line">    expected = [&apos;Accord&apos;, &apos;Commodore&apos;, &apos;Falcon&apos;]</div><div class="line">    # sorting requirement might be missed and is not essential for this method</div><div class="line">    assert sorted(get_all_matching_models(grep=&apos;CO&apos;)) == expected</div><div class="line"></div><div class="line"></div><div class="line">def test_sort_dict_alphabetically():</div><div class="line">    actual = sort_car_models()</div><div class="line">    # Order of keys should not matter, two dicts are equal if they have the</div><div class="line">    # same keys and the same values.</div><div class="line">    # The car models (values) need to be sorted here though</div><div class="line">    expected = &#123;</div><div class="line">        &apos;Ford&apos;: [&apos;Fairlane&apos;, &apos;Falcon&apos;, &apos;Festiva&apos;, &apos;Focus&apos;],</div><div class="line">        &apos;Holden&apos;: [&apos;Barina&apos;, &apos;Captiva&apos;, &apos;Commodore&apos;, &apos;Trailblazer&apos;],</div><div class="line">        &apos;Honda&apos;: [&apos;Accord&apos;, &apos;Civic&apos;, &apos;Jazz&apos;, &apos;Odyssey&apos;],</div><div class="line">        &apos;Jeep&apos;: [&apos;Cherokee&apos;, &apos;Grand Cherokee&apos;, &apos;Trackhawk&apos;, &apos;Trailhawk&apos;],</div><div class="line">        &apos;Nissan&apos;: [&apos;350Z&apos;, &apos;Maxima&apos;, &apos;Navara&apos;, &apos;Pulsar&apos;],</div><div class="line">    &#125;</div><div class="line">    assert actual == expected</div></pre></td></tr></table></figure><h4 id="Bite-26-字典推导式-gt-酷炫-Dictionary-comprehensions-are-awesome"><a href="#Bite-26-字典推导式-gt-酷炫-Dictionary-comprehensions-are-awesome" class="headerlink" title="Bite 26 字典推导式 -&gt; 酷炫(Dictionary comprehensions are awesome)"></a>Bite 26 字典推导式 -&gt; 酷炫(Dictionary comprehensions are awesome)</h4><blockquote><p>字典推导式与列表推导式相似，只是构建的是字典，而不是列表。它是方便快速地操作键和值的方法。通常只有一行代码，或者在检查 PEP8 规范之后是两行代码。<br>知识点：<br>输入：原始字典，排除的键值<br>计算：复制字典，匹配排除的键值，并从字典从删除<br>输出：排除对应键之后的字典</p></blockquote><ul><li><code>collection</code> 的 <code>nametuple</code></li><li>列表推导式</li></ul><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">bites = &#123;6: &apos;PyBites Die Hard&apos;,</div><div class="line">         7: &apos;Parsing dates from logs&apos;,</div><div class="line">         9: &apos;Palindromes&apos;,</div><div class="line">         10: &apos;Practice exceptions&apos;,</div><div class="line">         11: &apos;Enrich a class with dunder methods&apos;,</div><div class="line">         12: &apos;Write a user validation function&apos;,</div><div class="line">         13: &apos;Convert dict in namedtuple/json&apos;,</div><div class="line">         14: &apos;Generate a table of n sequences&apos;,</div><div class="line">         15: &apos;Enumerate 2 sequences&apos;,</div><div class="line">         16: &apos;Special PyBites date generator&apos;,</div><div class="line">         17: &apos;Form teams from a group of friends&apos;,</div><div class="line">         18: &apos;Find the most common word&apos;,</div><div class="line">         19: &apos;Write a simple property&apos;,</div><div class="line">         20: &apos;Write a context manager&apos;,</div><div class="line">         21: &apos;Query a nested data structure&apos;&#125;</div><div class="line">exclude_bites = &#123;6, 10, 16, 18, 21&#125;</div><div class="line"></div><div class="line"></div><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    pass</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    return &#123;  k:v    for k,v in  bites.items() if k not in bites_done  &#125;</div></pre></td></tr></table></figure><p>查看了例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># dict comprehension example to reverse key:value pair in a dictionary</div><div class="line">&gt;f_dict = &#123;f:i for i,f in enumerate(fruits)&#125;</div><div class="line">&gt;f_dict</div><div class="line">&#123;&apos;apple&apos;: 0, &apos;banana&apos;: 2, &apos;cherry&apos;: 3, &apos;mango&apos;: 1&#125;</div><div class="line"># dict comprehension to reverse key:value pair in a dictionary</div><div class="line">&gt;&#123;v:k for k,v in f_dict.items()&#125;</div><div class="line">&#123;0: &apos;apple&apos;, 1: &apos;mango&apos;, 2: &apos;banana&apos;, 3: &apos;cherry&apos;&#125;</div></pre></td></tr></table></figure><p>思路：若 k 不在给定的 set 里，便添加入新的字典之后。第一次拼写少了<code>in</code>，之后通关。<img src="https://upload-images.jianshu.io/upload_images/452087-4ba80f57adc238c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def filter_bites(bites=bites, bites_done=exclude_bites):</div><div class="line">    &quot;&quot;&quot;return the bites dict with the exclude_bites filtered out&quot;&quot;&quot;</div><div class="line">    return &#123;  k:v    for k,v in  bites.items() if k not in bites_done  &#125; </div><div class="line">    </div><div class="line">a = filter_bites(bites=bites, bites_done=exclude_bites)</div><div class="line">print(a)</div></pre></td></tr></table></figure><h1 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h1><blockquote><p>改成每题一小篇，以固定标题的形式，组织成专栏，写给六个月前的自己，帮助 0 基础，甚至是负基础的小白入门同学朋友。</p><p>重新调整笔记结构，让别人更易读，而不是偏私人的呢喃。</p></blockquote><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.03.02 init pybite108</p><p>2019.03.05 update pybite109</p><p>2019.03.08 update pybite110</p><p>2019.03.12 update pybite8</p><p>2019.03.16 update pybite15</p><p>2019.03.19 update pybite16</p><p>2019.03.20 update pybite19</p><p>2019.03.22 update pybite21</p><p>2019.03.23 update pybite26</p><p>2019.03.24 update pybite1</p><p>2019.03.27 update pybite5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python新手练习-PyBite&quot;&gt;&lt;a href=&quot;#Python新手练习-PyBite&quot; class=&quot;headerlink&quot; title=&quot;Python新手练习-PyBite&quot;&gt;&lt;/a&gt;Python新手练习-PyBite&lt;/h2&gt;&lt;h4 id=&quot;Bite-
      
    
    </summary>
    
    
      <category term="技术" scheme="https://adi0229.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>人生是选择的总和——读《畅销的原理》</title>
    <link href="https://adi0229.github.io/2019/01/17/2019-01-17-the-business-of-choice_new/"/>
    <id>https://adi0229.github.io/2019/01/17/2019-01-17-the-business-of-choice_new/</id>
    <published>2019-01-17T08:54:57.000Z</published>
    <updated>2019-11-26T14:48:16.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人生的选择"><a href="#人生的选择" class="headerlink" title="人生的选择"></a>人生的选择</h1><p> <img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191126224348.png" alt=""></p><p>在电影《罪与罚》结尾，艾迪-伍伦让剧中人物莱维教授说出了一句话：</p><blockquote><p>人生，事实上是选择的总和。——路易斯-莱维教授</p></blockquote><p>《畅销的原理》作者马修-威尔科克斯觉得，这句话“听上去似乎有点轻蔑，却是显而易见的事实。”</p><p>如果说，人生每一次选择，都是在面对分叉的道路，选择向左还是向右，那么，马修-威尔科克斯从30年前选择的广告公司入口，选择20年后在旧金山的商务策划，进而选择了与《选择的悖论》作者巴里-施瓦茨接触，最后，选择了写出《畅销的原理：为什么好观念、好产品会一炮而红？》。</p><h1 id="我们是消费者，还是选择者？"><a href="#我们是消费者，还是选择者？" class="headerlink" title="我们是消费者，还是选择者？"></a>我们是消费者，还是选择者？</h1><p>曾经，笔者一看到「营销」一词，想到西装革履的“直销”销售员在讲台上口吐横沫，把一个劣质无用的产品吹得天花乱坠，便会心生反感。后来，翻过大学教科书《市场营销》等书，脑海里的「营销」是销售人员巧舌如簧地安利商品，是公交站旁的贴着明星笑脸的广告牌。简而言之，营销是商业方面的市场推广和品牌管理等活动。在过去，这是我的营销常识。</p><p>对于「营销」是什么，马修-威尔科克斯给出反常识解读：<strong>营销是影响人们选择的过程。</strong></p><p>本书英文标题为《The Business of Choice:Marketing to Consumer’s Instincts》,顾名思义，书中强调的「营销思维」，指的是在商业领域中，<br>选择者面对汽车、保险、球鞋或者移动软件，他们特定的选择或许不同，但演化600万年而来的人类，他们都有着类似的大脑，都是用着类似的决策选择系统来思考。（消费者作者建议少用“消费者”一次，而是推荐“选择者”一词。）</p><p>原因如下：</p><ul><li>了解更宏大的背景，对于如何理解人们如何做出决策至关重要</li></ul><p>从行为科学的角度，他引述《影响力》作者西奥迪尼的观点：</p><blockquote><p>市场调研行业存在一个巨大的缺口，营销人员要更多地关注人类做出决策的一般规律，而不是只关心特定产品市场中对决策过程的理解。</p></blockquote><p>书中有一个例子，解释了为什么了解更宏大的背景，对于如何理解人们如何做出决策至关重要——对于「尾骨疼痛」这一疾病，普通医生只能从尾骨的医学性质来理解，但想不到从进化史来理解尾骨（人类和其他无尾灵长动物尾巴退化的遗迹），因此，无法理解整个环境、整个身体与尾骨的关系。</p><ul><li>选择耗费了人们生活中大量的时间</li></ul><p>2010年《经济学人》的一篇文章《你选择》显示:</p><blockquote><p>“根据食品市场营销协会的数据，如今美国普通超市就有超过 48,750 种商品，这一数字是 1975 年的五倍多。英国乐购超市出售 91 种不同的洗发水，93 个品种的牙膏，家用清洁剂品种的数量则达到 115。”</p></blockquote><ul><li>营销越来越复杂</li></ul><p>因为，在大数据时代，营销越来越复杂，数据海洋一波未平一波又起，冲刷到企业写字楼里。在2014年的大数据广告研究基金会上，作者即兴发言:</p><blockquote><p>“数据分析一半徒劳无功，但我不知道是哪一半。”</p></blockquote><p>这句话，对应了广告界的老谚语“广告奏效了一半，但我不知道是哪一半。”</p><p>下面摘录书中几个关于消费者选择的反常识案例：</p><h2 id="人们选择奢侈品的原因是什么？"><a href="#人们选择奢侈品的原因是什么？" class="headerlink" title="人们选择奢侈品的原因是什么？"></a>人们选择奢侈品的原因是什么？</h2><p>印象里，消费者总是容易这么想——那些陈列的装潢富丽堂皇的店铺里的奢侈品，比如爱马仕、迪奥和路易威登包包，人们购买他们，是因为他们做工精致，用料考究，设计奢华等等。”其实，根据书中所给的例子，在《Spent:Sex, Evolution, and Consumer Behavior》一书中，进化心理学家杰弗里-米勒写道（Geoffrey Miller）写道：“所有广告都有两种观众：潜在的产品买家和潜在的产品看客。产品看客会将各种想要的性状与产品联系起来。产品越昂贵、越独特，看客越多，买家越少。”他认为，奢侈品是性选择的标记。我们珍视美丽稀有的事物，代表想要别人珍视我们，这依赖于别人熟悉这些“标记”。所以，人们买奢侈品包包，不只是因为包包奢华无比，而是因为左邻右舍或者同事领导能认出来，“哇哦，你拿的是爱马仕的包哦。”</p><h2 id="为什么人们有时候选择随波逐流，有时候选择特立独行"><a href="#为什么人们有时候选择随波逐流，有时候选择特立独行" class="headerlink" title="为什么人们有时候选择随波逐流，有时候选择特立独行?"></a>为什么人们有时候选择随波逐流，有时候选择特立独行?</h2><p>在书中，作者引述心理学教授弗拉达斯·格里斯克维西思（Vladas Griskevicius）的一个实验：让被试观看赌城拉斯维加斯的两版旅游广告。一版强调「流行」—— 每年数百万人涌入赌城观光。一版强调「独特」—— 旅游者是特立独行的。在观看广告之前，不同分组的实验对象分别观看了心理惊悚片《闪灵》(The Shining)和浪漫爱情片《爱在黎明破晓前》（Before Sunrise）。实验结果显示，观看了《闪灵》的被试，更喜欢强调「流行」的那版广告。观看了《爱在破晓黎明前》的被试，更喜欢强调「独特」的那版广告。本次实验说明，人们有时从众，有时自我。电影能够激发观众的进化心理，如果观看了恐怖片，他们更偏向于引发自卫本能，此时观众更容易有从众心理。如果观看的是浪漫爱情片，则会激发他们的求偶本能，这时候，观众更偏向于独一无二的心理感觉。</p><h1 id="作者：马修·威尔科克斯"><a href="#作者：马修·威尔科克斯" class="headerlink" title="作者：马修·威尔科克斯"></a>作者：马修·威尔科克斯</h1><p><img src="https://raw.githubusercontent.com/adi0229/cloudimg/master/imgs/20191126224629.png" alt=""></p><blockquote><p>马修·威尔科克斯（Matthew Willcox），博达大桥广告公司（FCB）决策制定研究所的创立者和执行常委。博达大桥广告公司（FCB）是世界最早的广告公司之一，也是全球最早上市的广告公司之一，决策制定研究所是其中一个非常独特的机构，它把研究人类行为和人们如何做 选择的科学新发现拓展应用于市场营销实践中。马修在品牌战略领域已经有25年的从业经历，足迹遍布欧洲、亚洲和北美洲。他服务过李维斯、美国艺电、希尔顿酒店集团、联合利华、雀巢、壳牌和葛兰素史克等大企业。在马修的帮助下，这些企业的产品比以往更受消费者的喜爱。在这个过程中，他还为客户们赢得了8座艾菲奖（Effie）。马修还是美国食品和药品管理局的行为变化事务专家，经常在各大商学院和营销交流大会上做演讲。</p></blockquote><p>人容易对有着相同爱好的人有好感，作者威尔科克斯跟我一样，都是足球迷。他是爱尔兰人，在书中提到了他观看爱尔兰队对阵法国队的世界杯预选赛里亨利手球获利进球，而引发他呼吁各个足协协会让球员在赛前签字承诺，以借助“助推”影响球员公平竞赛行为。</p><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>针对书中的营销建议，我列出了对应的术语概念：</p><ul><li>靠直觉还是靠分析？过滤信息才能高效决策。<br>「启发法」——选择者们常用直觉，而不是理性分析来做决策。</li><li>被人熟知还是保持距离？<br>「熟悉的扭曲」悖论——要持续吸引选择者，不仅需要维持熟悉度，更要有新奇与惊喜。</li><li>“曾经拥有的”带来损失的更大<br>「损失厌恶」——就像陈奕迅 Eson 唱的那样：“你的背包，背到现在还没烂，却成为我身体另一半。千金不换，它已熟悉我的汗。”</li><li>“给人们带去聪明、好看和幸运的感觉”<br>「自我效能」—— 让人们感觉到胜任感，他们会更乐意去做某事。</li></ul><h1 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h1><p>2019.01.16 初稿 2.5h</p><p>2019.04.02 删除封面图</p><p>2019.11.26 更新 GitHub图床的图片地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人生的选择&quot;&gt;&lt;a href=&quot;#人生的选择&quot; class=&quot;headerlink&quot; title=&quot;人生的选择&quot;&gt;&lt;/a&gt;人生的选择&lt;/h1&gt;&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/adi0229/cloud
      
    
    </summary>
    
    
      <category term="运营" scheme="https://adi0229.github.io/tags/%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>队服撞衫？如何让AI区分相似球衣？</title>
    <link href="https://adi0229.github.io/2019/01/04/2019-01-04-aisimilarshirt/"/>
    <id>https://adi0229.github.io/2019/01/04/2019-01-04-aisimilarshirt/</id>
    <published>2019-01-04T04:44:23.000Z</published>
    <updated>2019-04-06T13:49:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>#问题</p><p>笔者最近在学人工智能领域的深度学习技术，在 fast.ai的课程里，我学会了：复用简洁的示例代码来训练卷积神经网络CNN。它能够精准地让机器对图片进行分类。（课程里的例子是识别猫狗图片的二元分类任务，在2000张测试图片中，它的识别准确率达到了99%。）</p><p>我认为，真正的学习，是带着好奇心，自己来解决实际问题，探究输入-输出之间的关系，从而构建自己的知识体系。</p><p><strong>因为自己是多年的足球迷，从兴趣出发，我“凿开”了一个脑洞：能否训练一个卷积神经网络训练，识别区分两件相似足球队衣图片？</strong></p><p>于是，我搜索到了公众号点妹侃球的一篇帖子 <a href="https://kuaibao.qq.com/s/20180511G1NJ6N00?refer=spider" target="_blank" rel="external">《撞衫不可怕，谁丑谁尴尬！这些球衣相似度竟高达99％》</a>，看看都有哪些足球队的队服比较相似。</p><p>其中，我发现，大名鼎鼎的巴塞罗那队服是红蓝箭条衫，而瑞士巴赛尔队的队服也是红蓝箭条衫，两队的主场战袍相似度很高。因此，我打算用 fast.ai的模块来以及预训练的 CNN 卷积神经网络（比如，resnet34）来进行迁移学习，看看我们的 AI 图片分类器，能否较好地识别两个队的队服。</p><p>下面是两队的队服示例:</p><p><img src="http://inews.gtimg.com/newsapp_match/0/3549393347/0" alt="巴塞罗那队服"></p><p><img src="http://inews.gtimg.com/newsapp_match/0/3549393346/0" alt="巴塞尔队服"></p><p>任务定义：区分图片是「巴塞罗那队队服」还是「巴赛尔队队服」？</p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><ul><li>通过开源的 Python 脚本 <a href="https://github.com/hardikvasa/google-images-download" target="_blank" rel="external">google-images-download</a>，根据关键词来批量谷歌图片里的图像。每队批量下载了140张图片，训练集每队约83张图片，验证集每队约60张图片。</li></ul><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><p>定义数据路径及图片大小（324*324）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PATH = &quot;./data/basel_or_barcelona/&quot;</div><div class="line">sz=324</div></pre></td></tr></table></figure></p><p>设置预训练模型为resnet34，然后生成模型，学习率设为0.01，并训练10次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">arch=resnet34</div><div class="line">data = ImageClassifierData.from_paths(PATH, tfms=tfms_from_model(arch, sz)) </div><div class="line">learn = ConvLearner.pretrained(arch, data, precompute=True) </div><div class="line">learn.fit(0.01, 10)</div><div class="line"></div><div class="line">100% 10/10 [00:01&lt;00:00, 5.81it/s]</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.773914   0.711084   0.586777  </div><div class="line">    1      0.694298   0.670647   0.644628                </div><div class="line">    2      0.597124   0.62849    0.710744                </div><div class="line">    3      0.505373   0.600698   0.735537                </div><div class="line">    4      0.450973   0.583853   0.760331        </div><div class="line">    5      0.42152    0.595698   0.768595        </div><div class="line">    6      0.373794   0.610405   0.785124        </div><div class="line">    7      0.33496    0.624578   0.77686                 </div><div class="line">    8      0.304601   0.634755   0.77686         </div><div class="line">    9      0.277069   0.641988   0.77686</div></pre></td></tr></table></figure></p><p>采用预训练的模型，120多张的测试数据，准确率达到了77.6%，还不错。这是最简单的办法，fast.ai课程还讲授了其他的提示准确率的办法，对于这个小型的足球图片数据集，我来实验一下，看看准确率能否有明显提升。</p><h3 id="寻找最佳学习率"><a href="#寻找最佳学习率" class="headerlink" title="寻找最佳学习率"></a>寻找最佳学习率</h3><p><img src="https://upload-images.jianshu.io/upload_images/452087-1e9de08bc7ee725b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用了一个寻找最佳学习率的函数，但是数据图里是空的，没有曲线，暂时无解，先跳过，我决定沿用0.01的学习率。</p><h3 id="数据扩充（Data-Argumentation）"><a href="#数据扩充（Data-Argumentation）" class="headerlink" title="数据扩充（Data Argumentation）"></a>数据扩充（Data Argumentation）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tfms = tfms_from_model(resnet34, sz, aug_tfms=transforms_side_on, max_zoom=1.5)</div></pre></td></tr></table></figure><p>随机对图片进行水平旋转，并放大1.5倍</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-2aba8a9bc2b3af4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = ImageClassifierData.from_paths(PATH, tfms=tfms)</div><div class="line">learn = ConvLearner.pretrained(arch, data, precompute=True)</div><div class="line">learn.fit(1e-2, 1)</div></pre></td></tr></table></figure><p>用了 数据扩充（Data Argumentation） 之后，第一次训练，准确率较低，只有52.8%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">learn.precompute=False</div><div class="line">learn.fit(1e-2, 3, cycle_len=1)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.711067   0.799083   0.561983  </div><div class="line">    1      0.673241   0.670506   0.652893                </div><div class="line">    2      0.632643   0.606632   0.644628</div></pre></td></tr></table></figure><h1 id="解冻-微调"><a href="#解冻-微调" class="headerlink" title="解冻-微调"></a>解冻-微调</h1><p>之前训练的是最后一层，通过 Unfreeze函数,“解冻”所有神经层，进一步做 Fine-Tuning 参数微调，并且，不同深浅的神经层，采用不同的学习率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">learn.unfreeze()</div><div class="line">lr=np.array([1e-4,1e-3,1e-2])</div><div class="line">learn.fit(lr, 3, cycle_len=1, cycle_mult=2)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.577406   0.585321   0.652893  </div><div class="line">    1      0.574191   0.495774   0.727273                </div><div class="line">    2      0.505914   0.456579   0.752066                 </div><div class="line">    3      0.456115   0.393354   0.801653                </div><div class="line">    4      0.408209   0.363914   0.818182                </div><div class="line">    5      0.370777   0.353467   0.834711                </div><div class="line">    6      0.342305   0.350941   0.842975 </div><div class="line"></div><div class="line">learn.fit(lr, 6, cycle_len=1, cycle_mult=2)</div><div class="line">epoch      trn_loss   val_loss   accuracy                </div><div class="line">    0      0.224649   0.351165   0.842975  </div><div class="line">    1      0.201187   0.343334   0.867769                </div><div class="line">    2      0.192907   0.339028   0.867769                </div><div class="line">    3      0.187865   0.32258    0.867769                </div><div class="line">    4      0.167363   0.309566   0.867769                </div><div class="line">    5      0.165586   0.302056   0.859504                </div><div class="line">    6      0.162697   0.303541   0.859504                </div><div class="line">    7      0.160678   0.301258   0.867769                </div><div class="line">    8      0.150494   0.315228   0.876033                </div><div class="line">    9      0.149012   0.333124   0.876033                </div><div class="line">    10     0.140085   0.341198   0.884298                </div><div class="line">    11     0.133135   0.343363   0.884298                </div><div class="line">    12     0.125423   0.339807   0.884298                </div><div class="line">    13     0.1168     0.33534    0.884298                </div><div class="line">    14     0.109273   0.33899    0.884298                </div><div class="line">    15     0.10801    0.32313    0.884298                </div><div class="line">    16     0.101856   0.313022   0.892562                </div><div class="line">    17     0.099126   0.29976    0.884298                 </div><div class="line">    18     0.094342   0.293067   0.884298                 </div><div class="line">    19     0.090559   0.291236   0.884298                 </div><div class="line">    20     0.089409   0.294657   0.884298                 </div><div class="line">    21     0.085061   0.292772   0.884298                 </div><div class="line">    22     0.080943   0.294916   0.884298                 </div><div class="line">    23     0.077687   0.289591   0.884298                 </div><div class="line">    24     0.073291   0.290864   0.884298                  </div><div class="line">    25     0.070136   0.289896   0.884298                  </div><div class="line">    26     0.071041   0.291556   0.876033                 </div><div class="line">    27     0.067812   0.287182   0.884298                  </div><div class="line">    28     0.06408    0.287058   0.884298                 </div><div class="line">    29     0.062913   0.288546   0.884298                  </div><div class="line">    30     0.060431   0.286025   0.884298                 </div><div class="line">    31     0.060556   0.284598   0.884298                 </div><div class="line">    32     0.058281   0.290405   0.884298                 </div><div class="line">    33     0.056919   0.295286   0.892562                  </div><div class="line">    34     0.054588   0.29396    0.900826                 </div><div class="line">    35     0.052521   0.292013   0.892562                 </div><div class="line">    36     0.051742   0.281408   0.892562                  </div><div class="line">    37     0.050915   0.274899   0.892562                  </div><div class="line">    38     0.048206   0.265904   0.892562                 </div><div class="line">    39     0.048089   0.2706     0.892562                 </div><div class="line">    40     0.045976   0.286523   0.892562                 </div><div class="line">    41     0.046062   0.297521   0.892562                  </div><div class="line">    42     0.043593   0.297748   0.900826                 </div><div class="line">    43     0.041344   0.293669   0.900826                 </div><div class="line">    44     0.040934   0.297795   0.900826                 </div><div class="line">    45     0.039792   0.300095   0.900826                 </div><div class="line">    46     0.038014   0.300615   0.900826                 </div><div class="line">    47     0.037288   0.298393   0.892562                 </div><div class="line">    48     0.037229   0.294151   0.900826                 </div><div class="line">    49     0.035728   0.290464   0.884298                 </div><div class="line">    50     0.034198   0.286805   0.884298                 </div><div class="line">    51     0.033855   0.286428   0.876033                 </div><div class="line">    52     0.032238   0.282124   0.884298                 </div><div class="line">    53     0.031438   0.276031   0.892562                 </div><div class="line">    54     0.031037   0.282506   0.876033                 </div><div class="line">    55     0.02959    0.285489   0.884298                 </div><div class="line">    56     0.028276   0.282334   0.892562                 </div><div class="line">    57     0.027054   0.278635   0.892562                 </div><div class="line">    58     0.025802   0.281353   0.892562                 </div><div class="line">    59     0.024861   0.282644   0.892562                 </div><div class="line">    60     0.023592   0.281519   0.892562                 </div><div class="line">    61     0.023124   0.283864   0.884298                 </div><div class="line">    62     0.022198   0.284992   0.892562</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">log_preds,y = learn.TTA()</div><div class="line">probs = np.mean(np.exp(log_preds),0)</div><div class="line">accuracy_np(probs, y)</div><div class="line">0.8925619834710744</div></pre></td></tr></table></figure><p>采用了 TTA（测试集也使用 Data Argumentation） 之后，最后的准确率达到了89.2%。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h3 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h3><p>画出一个混淆矩阵——查看不同分类，识别错误的图片都有哪些？</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-621fc190111f5c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Confusion Matrix"></p><p>看图可知</p><p>巴塞罗那队服：54张正确，6张错误。<br>巴塞尔队服：54张正确，7张错误。</p><p>下面我们看看具体哪些图片识别错了：</p><p><img src="https://upload-images.jianshu.io/upload_images/452087-d67f75a921cb63bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第一行几张图片，判断错误还是有点奇怪的，因为图片本身有着巴塞罗那队的标志，标志人物梅西和队徽。也许是训练集还太小的缘故吧。</p><p>第二行判断错误的巴赛尔队服，第二张是异常图片，呈黑白色。其他三张与训练集里典型的巴赛尔队服还是有点区别的。这样也许解释得过去。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://towardsdatascience.com/fun-with-small-image-data-sets-8c83d95d0159" target="_blank" rel="external">Fun with small image data-sets</a><br><a href="https://medium.com/@apiltamang/case-study-a-world-class-image-classifier-for-dogs-and-cats-err-anything-9cf39ee4690e" target="_blank" rel="external">Case Study: A world class image classifier for dogs and cats</a><br><a href="https://docs.fast.ai/" target="_blank" rel="external">fastai-doc</a></p><h1 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h1><p>2019.01.04 初稿<br>2019.04.05 删除时效图片，发布至博客 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#问题&lt;/p&gt;
&lt;p&gt;笔者最近在学人工智能领域的深度学习技术，在 fast.ai的课程里，我学会了：复用简洁的示例代码来训练卷积神经网络CNN。它能够精准地让机器对图片进行分类。（课程里的例子是识别猫狗图片的二元分类任务，在2000张测试图片中，它的识别准确率达到了99%。
      
    
    </summary>
    
    
      <category term="AI" scheme="https://adi0229.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念之树状笔记</title>
    <link href="https://adi0229.github.io/2018/04/11/2018-04-11-workflowy/"/>
    <id>https://adi0229.github.io/2018/04/11/2018-04-11-workflowy/</id>
    <published>2018-04-10T16:54:57.000Z</published>
    <updated>2019-04-02T11:35:03.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Workflowy-VS-幕布"><a href="#Workflowy-VS-幕布" class="headerlink" title="Workflowy VS 幕布"></a>Workflowy VS 幕布</h1><p>这一年来，有幸接触开智学堂，参与开智的认知写作学课程，信息密度超大，受益良多，尤其是其中强调的“卡片大法”和“树形结构”，我一直念念不忘。</p><p>其中，阳老曾在博文中提到：</p><blockquote><p>我提过多次的 MIT 认知科学家 Joshua B. Tenenbaum 发表在 PNAS 的论文（ The discovery of structural form ）中，比较了抽象知识的不同表征结构……最终还是意识到，人类的最佳知识结构是树形结构。只有树形结构，才是最符合人类认知特点的一种结构，从树的上一层到下一层，是具备唯一通道，便于大脑将知识从记忆底层快速提取出来，符合人类大脑是个认知吝啬鬼的特点；树又是兼具横向扩展与纵向扩展能力的最优雅的结构。——<a href="http://www.yangzhiping.com/tech/zotero2.html" target="_blank" rel="external">Zotero（2）：作为知识管理工具的Zotero - 阳志平的网志</a></p></blockquote><p>过去用印象笔记，笔记越用越臃肿，认知超载，继而行动瘫痪。换工具，势在必行。</p><p>一周前，开始接触一款轻量级的笔记软件——Workflowy，一番试用过后，喜出望外，漫存笔记喜欲狂。电闪雷鸣，350条免费空间已然塞满。它正好满足了我想要践行“卡片大法”和“树形结构”的工具需求。</p><p>曾因 Workflowy 不能添加图片而纠结，国产版的同类产品幕布支持在笔记中添加图片，还能将笔记导出思维导图，又是一番产品试用，结果不遂人意。原因无他，幕布的多文档，或者说多画布模式，不符合打开即用的原则。每次打开幕布，需要在三个文档中选择，点击进去，再做笔记。经过这一步，我早已没有了输出欲望。</p><p>对此，我有一则 Workflowy 笔记在次为证：</p><blockquote><p>启动后的第一屏，幕布是多文档对应多个树状笔记。而Workflowy一个白板，清清爽爽，一进去就有敲敲打打码字的冲动。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Workflowy-VS-幕布&quot;&gt;&lt;a href=&quot;#Workflowy-VS-幕布&quot; class=&quot;headerlink&quot; title=&quot;Workflowy VS 幕布&quot;&gt;&lt;/a&gt;Workflowy VS 幕布&lt;/h1&gt;&lt;p&gt;这一年来，有幸接触开智学堂，参与开智
      
    
    </summary>
    
    
      <category term="data" scheme="https://adi0229.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>拉新促活，了解一下？读《增长黑客》</title>
    <link href="https://adi0229.github.io/2017/09/04/2017-09-07-growthhacker/"/>
    <id>https://adi0229.github.io/2017/09/04/2017-09-07-growthhacker/</id>
    <published>2017-09-04T13:24:57.000Z</published>
    <updated>2018-04-07T17:54:25.353Z</updated>
    
    <content type="html"><![CDATA[<p>花了两个下午的时间，看完了同龄人范冰写的《增长黑客》，作者出书时，年纪轻轻，已是成绩斐然，他曾任职盛大创新院，担任「WiFi 万能钥匙」产品经理。</p><p>读完之后，对AARRR漏斗印象较深，书中有关增长黑客的工作，都是围绕着AARRR漏斗来开展的。</p><h2 id="何为增长黑客"><a href="#何为增长黑客" class="headerlink" title="何为增长黑客"></a>何为增长黑客</h2><p>与预想的不同，本书并不为难普通读者，并没有涉及繁杂的数据分析。整体行文较为友好，有IT科技媒体的风格。</p><p>作者简要地介绍了增长黑客的由来:</p><p>2012年4月，Andrew Chen发表了《Growth Hacker is the new VP Marketing》首次提出了增长黑客的概念。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00005.jpeg" alt=""></p><p>在外行眼里，他们就像是极客、发明家和广告狂人的混合体。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00006.jpeg" alt=""></p><p>这里的黑客，并不是一般常识所认为的，是入侵计算机系统，谋取不当利益的危险分子。黑客的含义，更多的是指不走寻常路的科技发烧友。</p><h2 id="AARRR漏斗"><a href="#AARRR漏斗" class="headerlink" title="AARRR漏斗"></a>AARRR漏斗</h2><p>产品增长是Growth Hacker的核心任务，根据不同阶段用户参与产品的行为，拆分成了 AARRR 转化漏斗，即Acquisition（获取用户）、Activation（激发活跃）、Retention（留存）、Revenue（收入）、Referral（口碑推荐传播）。对应着五个模块，书中列举了很多案例，不少提及的产品，当下活得并不好，比如作者参与过的“约TA”等。这说明了，一两个招式并不是整个产品生死的关键，只有产品符合PMF（Product&amp;Market Fit）的前提下，才适合谈增长。</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00007.jpeg" alt=""></p><h2 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h2><p>精细化地数据分析，根据数据来驱动增长，A/B测试是增长黑客的一大利器。书里提到了几个有意思的案例，体现了A/B测试得出的反常识结果</p><p>案例一：HubSpot注册表单页</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00113.jpeg" alt=""></p><p>营销公司HubSpot，在注册表单上增加了一位女性微笑的照片，以试图丰富页面和增加亲和度。但测试效果不符合效果，转化率降低了24％</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00114.jpeg" alt=""></p><p>案例二：奥巴马的竞选网站“Change”</p><p><img src="https://jobrest.gitbooks.io/growthhacking/content/assets/00115.jpeg" alt=""></p><p>原先，”Change”上呈现的选举视频，远不如奥巴马的全家福照片，后者对选举支持率的提升比前者高出40.6％</p><p>当然了，书里的阐述还是浅显，只是一笔带过。但是A/B测试通过对照试验，用数据验证假设，也是符合心理学的实验精神的，能减少主观偏见的影响。</p><h2 id="Talk-is-cheap，show-me-the-code"><a href="#Talk-is-cheap，show-me-the-code" class="headerlink" title="Talk is cheap，show me the code"></a>Talk is cheap，show me the code</h2><p>书中所讲的案例，涵盖面广，够典型，但阐述也略浅，属于有用之作。</p><p>纸上得来终觉浅，绝知此事要躬行。下一个5年，10年，也许AI会给产品带来变革，那AI时代的产品该如何增长呢？要回答这个问题，绝对不是看看案例，写点总结就能做到的。对我而言，还是要参与实战。</p><p>就像作者，虽然毕业没几年，但实战经验丰富，是一个创造者，比如，他从小学开始用 Dreamweaver 搭建网站，中学时编写共享软件被《大众软件》，大学开发塞班手机上的校园社区等等。</p><h2 id="问号：增长黑客的职业道德"><a href="#问号：增长黑客的职业道德" class="headerlink" title="问号：增长黑客的职业道德"></a>问号：增长黑客的职业道德</h2><p>在后记中，作者谈到了增长黑客需要遵守的职业道德。但在第3章《用数据抓取“借鸡下蛋”》小节里，他曾提及自己参与过交友产品“追TA”，团队在冷启动时，为了在社区中伪造真实用户，爬取了唱吧上用户分享的头像。</p><p>不知道这一举措，是否经过了版权方的允许？又如果版权方允许，书中介绍此法，是鼓励增长黑客们伪造“僵尸用户”？（值得注意的是，此款应用在2015年1月4日之后，在苹果商店中变不再更新，产品并没有火起来。虽然产品停更的主因，不该是由此引起的）</p><p>相反地，在第3章“获取用户”部分，作者提到了一个自相矛盾的“从最笨的事情做起”，比如Airbnb创始团队挨家挨户帮房东拍照，网易云协作团队邀请近百位意见领袖参与内测。</p><p>我更欣赏的是，“笨办法”获取用户。<br>让我们多一些真诚，少一些套路。</p><h2 id="一句金句"><a href="#一句金句" class="headerlink" title="一句金句"></a>一句金句</h2><p>促活，是做产品的重中之重，最后用一句书中引用的日本谚语来结束这篇读书笔记。</p><p>“鸟不鸣，信长杀之；鸟不鸣，秀吉使鸣之；鸟不鸣，家康待鸣之。”</p><p>注：文中图片引用自 gitbook，侵删。</p><h2 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h2><p>2017-09-02 添加行动卡和金句卡 0.5h<br>2017-08-31 初稿 2.5h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了两个下午的时间，看完了同龄人范冰写的《增长黑客》，作者出书时，年纪轻轻，已是成绩斐然，他曾任职盛大创新院，担任「WiFi 万能钥匙」产品经理。&lt;/p&gt;
&lt;p&gt;读完之后，对AARRR漏斗印象较深，书中有关增长黑客的工作，都是围绕着AARRR漏斗来开展的。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="note" scheme="https://adi0229.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>【译】站在20岁的尾巴上</title>
    <link href="https://adi0229.github.io/2017/08/17/2015-07-31-20tail/"/>
    <id>https://adi0229.github.io/2017/08/17/2015-07-31-20tail/</id>
    <published>2017-08-17T04:14:57.000Z</published>
    <updated>2017-08-17T04:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>过去翻译的一个Quora回答，一次自我激励。<br>也是促成成长型心智的一小步。<br>可是，光有大方向可不行。还需要踩油门，而不是只在车上喊口号<br>——20170817</em></p><blockquote><p>Q：“I am in my late 20s and feel I have wasted a lot of time. Is it too late for me to achieve something worthwhile?</p></blockquote><p>现在，我站在在二十多岁的尾巴上，感觉浪费了很多时间。对我来说，去达成一些值得去做的事情，是不是已经太晚了？</p><blockquote><p>Tim MacGougan：</p><p>When I turned 27 I was:<br>Unemployed, had been for a year<br>Sleeping on a friend’s couch<br>Painfully single<br>Wondering if it was too late</p></blockquote><p>在我年满27岁时：</p><p>失业一年</p><p>睡朋友的沙发</p><p>痛苦的单身着</p><p>疑惑着是否一切都太晚了</p><blockquote><p>I had:<br>No hard skills<br>No work experience worth repeating<br>College grades that didn’t open grad school doors I wanted to walk through<br>Scant motivation<br>No direction</p></blockquote><p>我：</p><p>没有硬技能</p><p>没有值得一提的工作经历</p><p>大学成绩未能为我打开想要通过的毕业之门</p><p>缺乏动力</p><p>没有方向</p><blockquote><p>I asked my dad for advice and he said:”You can’t steer a parked car.”</p></blockquote><p>我向父亲寻求建议，他说：“ 你无法开动一辆停住的车”。</p><blockquote><p>I stopped thinking about what to do and started doing.  I refocused my search on small growing companies and after a dozen rejections I applied for a customer service job at a company I’d never heard of but that seemed interesting. A week later I was working atBonobos (company)with 25 smart, fun, engaging people. I chipped in on work in different departments and eventually found an application for my natural skills in a career path I hadn’t anticipated.  At 29 I’m a beginner in a new role.  It’s fantastic.</p></blockquote><p>我停止去想该做什么，开始行动。我重新聚焦于成长中的小型公司，然后，在许多次被拒之后，在一家没听说过但似乎挺有趣的公司，我申请了一份客户服务的工作。一周之后，我就任职于Bonnobos公司，与25位聪明、有趣、热心的伙伴一起工作了。我凑进不同的部门工作，终于，我使自己的天赋应用到了一个我未曾预料到的职业道路里。在29岁时，在新的角色里，我是一名初学者。这很神奇。</p><blockquote><p>I can only recommend what I’ve done:Find some fertile ground.You’ll figure the rest out later. There are tons of young companies looking for people who are energetic and capable, but most importantly they’re looking for people who care.  Startups require hard work and long hours but if you care about the mission and the quality of your work it’ll feel more like a lifestyle than a job.</p></blockquote><p><strong>我只能建议我所做过的：寻找某片肥沃的土壤。</strong></p><p>你自己会弄明白其他的。现在有大量的新兴企业在寻找有激情有能力的人，但最重要的是，他们要找的是真正在乎他们的人。创业公司需要长时间的勤奋工作。如果你在乎工作的使命和品质，那么，这会更像一种生活方式而不只是一份工作。</p><blockquote><p>You only have to be lucky once. I was. Maybe you will be too. There’s only one way to find out: Take the car out of park and step on the gas.</p></blockquote><p>你仅仅需要幸运一回。我曾经如此。也许，你也将如此。</p><p><strong>只有一种方法去寻找：把车开出泊位，踩上油门。</strong></p><p><a href="www.quora.com/I-am-in-my-late-20s-and-feel-I-have-wasted-a-lot-of-time-Is-it-too-late-for-me-to-achieve-something-worthwhile">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;过去翻译的一个Quora回答，一次自我激励。&lt;br&gt;也是促成成长型心智的一小步。&lt;br&gt;可是，光有大方向可不行。还需要踩油门，而不是只在车上喊口号&lt;br&gt;——20170817&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：“I am in my late 2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《国王，武士，祭司，情人》</title>
    <link href="https://adi0229.github.io/2017/08/04/2016-01-16-warrior/"/>
    <id>https://adi0229.github.io/2017/08/04/2016-01-16-warrior/</id>
    <published>2017-08-04T03:24:57.000Z</published>
    <updated>2017-08-04T03:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>旧笔记。做了一个思维导图。文字部分，摘抄为主。<br>若能提炼主题，用精炼文字自行叙述，更好。<br>回头看，四个人物原型的隐喻，鲜明而深刻。有趣的神话隐喻。<br>理论模型虽好，还需践行。</p></blockquote><div style="text-align: center"><br><img src="http://upload-images.jianshu.io/upload_images/452087-dcb80f2303484a55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p><img src="http://ou1rce4mw.bkt.clouddn.com/kwml.png" alt=""></p><p><a href="http://ou1rce4mw.bkt.clouddn.com/kwml.png" target="_blank" rel="external">查看清晰大图</a></p><p><a href="http://www.jianshu.com/p/a98e4e67e39d" target="_blank" rel="external">笔记全文</a></p><p><a href="https://book.douban.com/subject/2893591/" target="_blank" rel="external">King, Warrior, Magician, Lover</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;旧笔记。做了一个思维导图。文字部分，摘抄为主。&lt;br&gt;若能提炼主题，用精炼文字自行叙述，更好。&lt;br&gt;回头看，四个人物原型的隐喻，鲜明而深刻。有趣的神话隐喻。&lt;br&gt;理论模型虽好，还需践行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style
      
    
    </summary>
    
    
      <category term="note" scheme="https://adi0229.github.io/tags/note/"/>
    
  </entry>
  
</feed>
